{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","permission":{"default":0},"type":"script","sort":100001,"flags":{},"scope":"global","command":"game.pf1.rollDefenses();","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/items/armor/shield-light-metal.png","actorIds":[]}
{"name":"Award XP","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _action = function(xp) {\r\n    if (!isNaN(xp)) {\r\n      actors.forEach(o => {\r\n        let curXP = getProperty(o.data, \"data.details.xp.value\") || 0;\r\n        if (typeof curXP === \"string\") curXP = parseInt(curXP);\r\n        o.update({ \"data.details.xp.value\": curXP + xp });\r\n      });\r\n    }\r\n  };\r\n\r\n  const msg = `Award XP to the following actors: <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n  const field = `<input type=\"text\" name=\"xp\" value=\"0\" placeholder=\"XP amount\" style=\"margin-bottom: 8px;\" />`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>${field}`,\r\n    buttons: {\r\n      ok: {\r\n        label: \"Give All\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          _action(xp);\r\n        },\r\n      },\r\n      distribute: {\r\n        label: \"Distribute\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          xp = Math.floor(xp / actors.length);\r\n          _action(xp);\r\n        }\r\n      }\r\n    },\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"icons/svg/book.svg","actorIds":[],"_id":"8VcUUx7d4TX4WTkt"}
{"name":"Wild Shape","permission":{"default":0,"ZuWclcb9BUy2aZSN":3},"type":"script","flags":{},"scope":"global","command":"// Author: @Adam\r\n\r\n// SETUP NEEDED: for each transformation option you want, please enter it as below\r\n// you also need to set imageFolder to the location of where you store your tokens.\r\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\r\n\r\n// support for elemental body is not complete yet - only air elemental is hardcoded\r\n\r\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\r\n\r\nconst transformationOptions = {\r\n  Bat: {\r\n    size: \"diminutive\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  \"Giant Squid\": {\r\n    size: \"huge\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  Tendriculos: {\r\n    size: \"huge\",\r\n    spellSource: \"plant shape\",\r\n  },\r\n  \"Air Elemental\": {\r\n    size: \"huge\",\r\n    spellSource: \"elemental body\",\r\n  },\r\n};\r\n\r\nconst sizes = [\"diminutive\", \"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"gargantuan\", \"colossal\"];\r\n\r\nconst sizeTranslation = {\r\n  fine: \"fine\",\r\n  diminutive: \"dim\",\r\n  tiny: \"tiny\",\r\n  small: \"sm\",\r\n  medium: \"med\",\r\n  large: \"lg\",\r\n  huge: \"huge\",\r\n  gargantuan: \"grg\",\r\n  colossal: \"col\",\r\n};\r\n\r\nconst createSizeObject = ({ w, h, scale }) => {\r\n  return {\r\n    width: w,\r\n    height: h,\r\n    scale,\r\n  };\r\n};\r\n\r\nconst mediumOrBigger = (size) => {\r\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\r\n};\r\n\r\nconst createAbilityChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ability\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createNACChange = (formula) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ac\",\r\n    subTarget: \"nac\",\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createSpeedChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"speed\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createBuffChanges = (name) => {\r\n  const creature = transformationOptions[name];\r\n  const bulking = mediumOrBigger(creature.size);\r\n  let buffLevel = null;\r\n\r\n  const changes = [];\r\n\r\n  if (bulking) {\r\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\r\n  } else {\r\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\r\n  }\r\n\r\n  switch (creature.spellSource.toLowerCase()) {\r\n    case \"beast shape\": {\r\n      const mainBonus = buffLevel * 2;\r\n      const nacBonus = buffLevel * 2;\r\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\r\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\r\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\r\n\r\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\r\n      changes.push(createAbilityChange(penalty, penaltyAbility));\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"plant shape\": {\r\n      const nacBonus = buffLevel * 2;\r\n      if (bulking) {\r\n        const strBonus = Math.pow(2, buffLevel);\r\n        const conBonus = Math.max(2, buffLevel / 2);\r\n        const penalty = -(buffLevel > 2 ? 2 : 0);\r\n\r\n        changes.push(createAbilityChange(strBonus, \"str\"));\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n        changes.push(createAbilityChange(penalty, \"dex\"));\r\n      } else {\r\n        const conBonus = buffLevel * 2;\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n      }\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"elemental body\": {\r\n      if (name === \"Air Elemental\") {\r\n        changes.push(createAbilityChange(4, \"str\"));\r\n        changes.push(createAbilityChange(6, \"dex\"));\r\n        changes.push(createNACChange(4));\r\n        changes.push(createSpeedChange(120, \"flySpeed\"));\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      ui.notifications.error(\r\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return changes;\r\n};\r\n\r\nconst createWSBuff = async (caster) => {\r\n  const itemData = { type: \"buff\", name: \"Wild Shape (Auto)\", data: { buffType: \"temp\", level: 1 } };\r\n  // Get templates\r\n  await caster.createOwnedItem(itemData);\r\n  return getWSBuff(caster);\r\n};\r\n\r\nconst getWSBuff = (caster) => {\r\n  return caster.items.find(\r\n    (i) =>\r\n    i.type === \"buff\" &&\r\n    i.name === \"Wild Shape (Auto)\"\r\n  );\r\n};\r\n\r\nconst transform = async (caster, token, name) => {\r\n  const creature = transformationOptions[name];\r\n  const changes = createBuffChanges(name);\r\n\r\n  let buff = getWSBuff(caster);\r\n  if (!buff) buff = await createWSBuff(caster);\r\n  buff.update({ \"data.changes\": changes });\r\n  buff.update({ \"data.active\": true });\r\n\r\n  token.update({ img: `${imageFolder}/${name}.png` });\r\n  token.update(\r\n    createSizeObject(CONFIG.PF1.tokenSizes[sizeTranslation[creature.size]])\r\n  );\r\n  caster.data.data.traits.size = sizeTranslation[creature.size];\r\n};\r\n\r\nconst revertForm = (caster, token) => {\r\n  getWSBuff(caster).update({ \"data.active\": false });\r\n  token.update({ img: caster.data.flags.originalData.image });\r\n  caster.data.data.traits.size = caster.data.flags.originalData.size;\r\n  token.update(\r\n    createSizeObject(CONFIG.PF1.tokenSizes[caster.data.flags.originalData.size])\r\n  );\r\n};\r\n\r\nconst tokens = canvas.tokens.controlled;\r\n\r\nif (tokens.length !== 1) {\r\n  ui.notifications.warn(\"Select a token.\");\r\n} else {\r\n  const token = tokens[0];\r\n  const actor = token.actor;\r\n  const caster = actor.data;\r\n\r\n  if (!Object.keys(caster.flags).includes(\"originalData\")) {\r\n    const originalData = {\r\n      image: caster.token.img,\r\n      size: caster.data.traits.size,\r\n    };\r\n    caster.flags.originalData = originalData;\r\n  }\r\n\r\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\r\n    label: optionName,\r\n    callback: () => transform(actor, token, optionName),\r\n  }));\r\n  buttons[\"Revert\"] = {\r\n    label: \"Revert\",\r\n    icon: '<i class=\"fas fa-user\"></i>',\r\n    callback: () => revertForm(actor, token),\r\n  };\r\n\r\n  new Dialog({\r\n    title: \"Wild Shape\",\r\n    content: \"Choose creature.\",\r\n    buttons: buttons,\r\n  }).render(true);\r\n}","author":"ZuWclcb9BUy2aZSN","img":"systems/pf1/icons/skills/green_27.jpg","actorIds":[],"_id":"GyuHEoeLTtLZCvhS"}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _roll = async function(type) {\r\n    for (let o of actors) {\r\n      await o.rollSavingThrow(type, { event: new MouseEvent({}) });\r\n    }\r\n  };\r\n\r\n  const msg = `Choose a saving throw to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>`,\r\n    buttons: {\r\n      fort: {\r\n        label: \"Fortitude\",\r\n        callback: () => _roll(\"fort\"),\r\n      },\r\n      ref: {\r\n        label: \"Reflex\",\r\n        callback: () => _roll(\"ref\"),\r\n      },\r\n      will: {\r\n        label: \"Will\",\r\n        callback: () => _roll(\"will\"),\r\n      },\r\n    },\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/feats/diehard.jpg","actorIds":[]}
{"_id":"ccZmfabwQrONq2kg","name":"Toggle Buff","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n  buffName: \"Mage Armor\"\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  for (let actor of actors) {\r\n    const buff = actor.items.find(o => o.name === c.buffName && o.type === \"buff\");\r\n    if (buff != null) {\r\n      let active = getProperty(buff.data, \"data.active\");\r\n      if (active == null) active = false;\r\n      buff.update({ \"data.active\": !active });\r\n    }\r\n  }\r\n}\r\n","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/spells/protect-blue-1.jpg","actorIds":[]}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\r\n  labels: [null, null, null, null],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _roll = async function(type) {\r\n    for (let o of actors) {\r\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true });\r\n    }\r\n  };\r\n\r\n  const buttons = c.skills.reduce((cur, s, a) => {\r\n    let label = c.labels[a];\r\n    if (label == null) label = CONFIG.PF1.skills[s] || \"Unknown Skill\";\r\n    cur[s] = {\r\n      label: label,\r\n      callback: () => _roll(s),\r\n    };\r\n    return cur;\r\n  }, {});\r\n\r\n  const msg = `Choose a skill to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>`,\r\n    buttons: buttons,\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/feats/skill-focus.jpg","actorIds":[]}
{"name":"Create Loot Sheets","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n/**\r\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\r\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.ENTITY_PERMISSIONS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\r\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\r\n */\r\n\r\nconst c = {\r\n    folder: \"Misc/Loot\",\r\n    defaultPermission: CONST.ENTITY_PERMISSIONS.OBSERVER,\r\n    sheetType: \"PF1.Loot\",\r\n};\r\n\r\n// END CONFIGURATION\r\n\r\n(async () => {\r\n\r\n    // Get selected tokens\r\n    let tokens = canvas.tokens.controlled;\r\n    if (!tokens.length) return;\r\n\r\n    // Create folder(s)\r\n    let lastFolder = null;\r\n    let lastIndex = 0;\r\n    if (c.folder) {\r\n        const folders = game.folders.filter(f => f.type === \"Actor\");\r\n        const folderNames = c.folder.split(\"/\");\r\n        for (let a = 0; a < folderNames.length; a++) {\r\n            let curName = folderNames[a];\r\n            let prevName = a > 0 ? folderNames[a-1] : null;\r\n            \r\n            const f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\r\n            if (f) {\r\n                lastFolder = f;\r\n                lastIndex = a+1;\r\n            }\r\n        }\r\n\r\n        for (let a = lastIndex; a < folderNames.length; a++) {\r\n            const newFolder = await Folder.create({\r\n                name: folderNames[a],\r\n                parent: lastFolder ? lastFolder._id : null,\r\n                type: \"Actor\",\r\n            });\r\n            lastFolder = newFolder;\r\n        }\r\n    }\r\n\r\n    // Gather currency\r\n    let [pp, gp, sp, cp] = tokens.reduce((cur, t) => {\r\n        cur[0] += t.actor.data.data.currency.pp;\r\n        cur[1] += t.actor.data.data.currency.gp;\r\n        cur[2] += t.actor.data.data.currency.sp;\r\n        cur[3] += t.actor.data.data.currency.cp;\r\n        return cur;\r\n    }, [0, 0, 0, 0]);\r\n\r\n    // Create loot NPC for selected tokens\r\n    const lootName = \"(Loot) \" + tokens.reduce((cur, o) => {\r\n        cur.push(o.name);\r\n        return cur;\r\n    }, []).join(\", \");\r\n    const lootNPC = await Actor.create({\r\n        name: lootName,\r\n        type: \"npc\",\r\n        img: tokens[0].actor.img,\r\n        folder: lastFolder ? lastFolder._id : null,\r\n        permission: {\r\n            default: c.defaultPermission,\r\n        },\r\n        flags: {\r\n            core: {\r\n                sheetClass: c.sheetType,\r\n            },\r\n        },\r\n        data: {\r\n            currency: {\r\n                pp: pp,\r\n                gp: gp,\r\n                sp: sp,\r\n                cp: cp,\r\n            },\r\n        },\r\n    });\r\n\r\n    // Gather item data\r\n    const itemData = tokens.reduce((cur, o) => {\r\n        for (let i of o.actor.items) {\r\n            if ([\"weapon\", \"equipment\", \"consumable\", \"loot\"].includes(i.type)) {\r\n                // Check for identical data\r\n                let addRaw = true;\r\n                let firstItem;\r\n                for (let i2 of cur) {\r\n                    if (i2.name === i.name) {\r\n                        firstItem = i2;\r\n                        addRaw = false;\r\n                        const diffData = flattenObject(diffObject(i.data.data, i2.data));\r\n                        for (let k of Object.keys(diffData)) {\r\n                            if (![\"quantity\"].includes(k)) addRaw = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (addRaw) {\r\n                    cur.push(duplicate(i.data));\r\n                }\r\n                else {\r\n                    firstItem.data.quantity += i.data.data.quantity;\r\n                }\r\n            }\r\n        }\r\n        return cur;\r\n    }, []);\r\n    \r\n    // Add items\r\n    await lootNPC.createOwnedItem(itemData);\r\n\r\n})();\r\n","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/items/inventory/chest-light.jpg","actorIds":[],"_id":"sQchIuqs9gHw09XC"}
