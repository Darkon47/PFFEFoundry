/*! For license information please see pf1.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("pf1",[],e):"object"==typeof exports?exports.pf1=e():t.pf1=e()}(window,(function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return t[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var a in t)n.d(r,a,function(e){return t[e]}.bind(null,a));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="systems/pf1/dist/",n(n.s="./pf1.js")}({"./module/actor/entity.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorPF", function() { return ActorPF; });\n/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dice.js */ "./module/dice.js");\n/* harmony import */ var _item_entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../item/entity.js */ "./module/item/entity.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib.js */ "./module/lib.js");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chat.js */ "./module/chat.js");\n/* harmony import */ var _combat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../combat.js */ "./module/combat.js");\n/* harmony import */ var _misc_links_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../misc/links.js */ "./module/misc/links.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Extend the base Actor class to implement additional logic specialized for D&D5e.\r\n */\r\nclass ActorPF extends Actor {\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  static chatListeners(html) {\r\n    html.on(\'click\', \'button[data-action]\', this._onChatCardButtonAction.bind(this));\r\n  }\r\n\r\n  static async _onChatCardButtonAction(event) {\r\n    event.preventDefault();\r\n\r\n    // Extract card data\r\n    const button = event.currentTarget;\r\n    const card = button.closest(".chat-card");\r\n    const action = button.dataset.action;\r\n\r\n    // Roll saving throw\r\n    if (action === "defense-save") {\r\n      const actor = _item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"]._getChatCardActor(card);\r\n      const saveId = button.dataset.save;\r\n      if (actor) actor.rollSavingThrow(saveId, { event: event });\r\n    }\r\n    else if (action === "save") {\r\n      const actor = ActorPF.getActiveActor()\r\n      const saveId = button.dataset.type;\r\n      if (actor) actor.rollSavingThrow(saveId, { event: event });\r\n    }\r\n  }\r\n\r\n  static getActiveActor({actorName=null, actorId=null}={}) {\r\n    const speaker = ChatMessage.getSpeaker();\r\n    let actor = game.actors.entities.filter(o => {\r\n      if (!actorName && !actorId) return false;\r\n      if (actorName && o.name !== actorName) return false;\r\n      if (actorId && o._id !== actorId) return false;\r\n      return true;\r\n    })[0];\r\n    if (speaker.token && !actor) actor = game.actors.tokens[speaker.token];\r\n    if (!actor) actor = game.actors.get(speaker.actor);\r\n    return actor;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  get spellFailure() {\r\n    return this.items.filter(o => { return o.type === "equipment" && o.data.data.equipped === true; }).reduce((cur, o) => {\r\n      if (typeof o.data.data.spellFailure === "number") return cur + o.data.data.spellFailure;\r\n      return cur;\r\n    }, 0);\r\n  }\r\n\r\n  get race() {\r\n    if (this.items == null) return null;\r\n    return this.items.filter(o => o.type === "race")[0];\r\n  }\r\n\r\n  get typeColor() {\r\n    return "#FDE600";\r\n  }\r\n\r\n  static _translateSourceInfo(type, subtype, name) {\r\n    let result = "";\r\n    if (type === "size") result = "Size";\r\n    if (type === "buff") {\r\n      result = "Buffs";\r\n      if (subtype === "temp") result = "Temporary Buffs";\r\n      if (subtype === "perm") result = "Permanent Buffs";\r\n      if (subtype === "item") result = "Item Buffs";\r\n      if (subtype === "misc") result = "Misc Buffs";\r\n    }\r\n    if (type === "equipment") result = "Equipment";\r\n    if (type === "weapon") result = "Weapons";\r\n    if (type === "feat") {\r\n      result = "Feats";\r\n      if (subtype === "classFeat") result = "Class Features";\r\n      if (subtype === "trait") result = "Traits";\r\n      if (subtype === "racial") result = "Racial Traits";\r\n      if (subtype === "misc") result = "Misc Features";\r\n    }\r\n    if (type === "race") {\r\n      result = "Race";\r\n    }\r\n\r\n    if (!name || name.length === 0) return result;\r\n    if (result === "") return name;\r\n    return `${result} (${name})`;\r\n  }\r\n\r\n  static _getChangeItemSubtype(item) {\r\n    if (item.type === "buff") return item.data.buffType;\r\n    if (item.type === "feat") return item.data.featType;\r\n    return "";\r\n  }\r\n\r\n  static _blacklistChangeData(data, changeTarget) {\r\n    let result = duplicate(data);\r\n\r\n    switch (changeTarget) {\r\n      case "mhp":\r\n        result.attributes.hp = null;\r\n        result.skills = null;\r\n        break;\r\n      case "wounds":\r\n        result.attributes.wounds = null;\r\n        result.skills = null;\r\n        break;\r\n      case "vigor":\r\n        result.attributes.vigor = null;\r\n        result.skills = null;\r\n        break;\r\n      case "str":\r\n        result.abilities.str = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n      case "con":\r\n        result.abilities.con = null;\r\n        result.attributes.hp = null;\r\n        result.attributes.wounds = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "dex":\r\n        result.abilities.dex = null;\r\n        result.attributes.ac = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "int":\r\n        result.abilities.int = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "wis":\r\n        result.abilities.wis = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "cha":\r\n        result.abilities.cha = null;\r\n        result.skills = null;\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "ac":\r\n      case "aac":\r\n      case "sac":\r\n      case "nac":\r\n        result.attributes.ac = null;\r\n        break;\r\n      case "attack":\r\n      case "mattack":\r\n      case "rattack":\r\n        result.attributes.attack = null;\r\n        break;\r\n      case "damage":\r\n      case "wdamage":\r\n      case "sdamage":\r\n        result.attributes.damage = null;\r\n        break;\r\n      case "allSavingThrows":\r\n      case "fort":\r\n      case "ref":\r\n      case "will":\r\n        result.attributes.savingThrows = null;\r\n        break;\r\n      case "skills":\r\n      case "strSkills":\r\n      case "dexSkills":\r\n      case "conSkills":\r\n      case "intSkills":\r\n      case "wisSkills":\r\n      case "chaSkills":\r\n        result.skills = null;\r\n        break;\r\n      case "cmb":\r\n        result.attributes.cmb = null;\r\n        break;\r\n      case "cmd":\r\n        result.attributes.cmd = null;\r\n        break;\r\n      case "init":\r\n        result.attributes.init = null;\r\n        break;\r\n    }\r\n\r\n    if (changeTarget.match(/^data\\.skills/)) {\r\n      result.skills = null;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  get _sortChangePriority() {\r\n    const skillTargets = this._skillTargets;\r\n    return { targets: [\r\n      "ability", "misc", "ac", "attack", "damage", "savingThrows", "skills", "skill"\r\n    ], types: [\r\n        "str", "dex", "con", "int", "wis", "cha",\r\n        "skills", "strSkills", "dexSkills", "conSkills", "intSkills", "wisSkills", "chaSkills", ...skillTargets,\r\n        "allChecks", "strChecks", "dexChecks", "conChecks", "intChecks", "wisChecks", "chaChecks",\r\n        "allSpeeds", "landSpeed", "climbSpeed", "swimSpeed", "burrowSpeed", "flySpeed",\r\n        "ac", "aac", "sac", "nac",\r\n        "attack", "mattack", "rattack",\r\n        "damage", "wdamage", "sdamage",\r\n        "allSavingThrows", "fort", "ref", "will",\r\n        "cmb", "cmd", "init", "mhp", "wounds", "vigor"\r\n    ], modifiers: [\r\n      "untyped", "base", "enh", "dodge", "inherent", "deflection",\r\n      "morale", "luck", "sacred", "insight", "resist", "profane",\r\n      "trait", "racial", "size", "competence", "circumstance",\r\n      "alchemical", "penalty"\r\n    ]};\r\n  }\r\n\r\n  get _skillTargets() {\r\n    let skills = [];\r\n    let subSkills = [];\r\n    for (let [sklKey, skl] of Object.entries(this.data.data.skills)) {\r\n      if (skl == null) continue;\r\n      if (skl.subSkills != null) {\r\n        for (let subSklKey of Object.keys(skl.subSkills)) {\r\n          subSkills.push(`skill.${sklKey}.subSkills.${subSklKey}`);\r\n        }\r\n      }\r\n      else skills.push(`skill.${sklKey}`);\r\n    }\r\n    return [...skills, ...subSkills];\r\n  }\r\n\r\n  _sortChanges(a, b) {\r\n    const priority = this._sortChangePriority;\r\n    const targetA = priority.targets.indexOf(a.raw.target);\r\n    const targetB = priority.targets.indexOf(b.raw.target);\r\n    const typeA = priority.types.indexOf(a.raw.subTarget);\r\n    const typeB = priority.types.indexOf(b.raw.subTarget);\r\n    const modA = priority.modifiers.indexOf(a.raw.modifier);\r\n    const modB = priority.modifiers.indexOf(b.raw.modifier);\r\n    let prioA = (typeof a.raw.priority === "string") ? parseInt(a.raw.priority) : a.raw.priority;\r\n    let prioB = (typeof b.raw.priority === "string") ? parseInt(b.raw.priority) : b.raw.priority;\r\n    prioA = (prioA || 0) + 1000;\r\n    prioB = (prioB || 0) + 1000;\r\n\r\n    return targetA - targetB || typeA - typeB || prioB - prioA || modA - modB;\r\n  }\r\n\r\n  _parseChange(change, changeData, flags) {\r\n    if (flags == null) flags = {};\r\n    const changeType = change.raw.modifier;\r\n    const changeValue = change.raw.value;\r\n\r\n    if (!changeData[changeType]) return;\r\n    if (changeValue === 0) return;\r\n    if (flags.loseDexToAC && changeType === "dodge") return;\r\n\r\n    change.source.value = changeValue;\r\n\r\n    const prevValue = { positive: changeData[changeType].positive.value, negative: changeData[changeType].negative.value };\r\n    // Add value\r\n    if (changeValue > 0) {\r\n      if (["untyped", "dodge", "penalty"].includes(changeType)) changeData[changeType].positive.value += changeValue;\r\n      else {\r\n        changeData[changeType].positive.value = Math.max(changeData[changeType].positive.value, changeValue);\r\n      }\r\n    }\r\n    else {\r\n      if (["untyped", "dodge", "penalty"].includes(changeType)) changeData[changeType].negative.value += changeValue;\r\n      else changeData[changeType].negative.value = Math.min(changeData[changeType].negative.value, changeValue);\r\n    }\r\n\r\n    // Add positive source\r\n    if (changeValue > 0) {\r\n      if (["untyped", "dodge", "penalty"].includes(changeType)) {\r\n        changeData[changeType].positive.sources.push(change.source);\r\n      }\r\n      else if (prevValue.positive < changeValue) {\r\n        changeData[changeType].positive.sources = [change.source];\r\n      }\r\n    }\r\n    // Add negative source\r\n    else {\r\n      if (["untyped", "dodge", "penalty"].includes(changeType)) {\r\n        changeData[changeType].negative.sources.push(change.source);\r\n      }\r\n      else if (prevValue.negative > changeValue) {\r\n        changeData[changeType].negative.sources = [change.source];\r\n      }\r\n    }\r\n  }\r\n\r\n  _getChangeFlat(changeTarget, changeType, curData) {\r\n    if (curData == null) curData = this.data.data;\r\n    let result = [];\r\n\r\n    switch(changeTarget) {\r\n      case "mhp":\r\n        return "data.attributes.hp.max";\r\n      case "wounds":\r\n        return "data.attributes.wounds.max";\r\n      case "vigor":\r\n        return "data.attributes.vigor.max";\r\n      case "str":\r\n        if (changeType === "penalty") return "data.abilities.str.penalty";\r\n        return "data.abilities.str.total";\r\n      case "dex":\r\n        if (changeType === "penalty") return "data.abilities.dex.penalty";\r\n        return "data.abilities.dex.total";\r\n      case "con":\r\n        if (changeType === "penalty") return "data.abilities.con.penalty";\r\n        return "data.abilities.con.total";\r\n      case "int":\r\n        if (changeType === "penalty") return "data.abilities.int.penalty";\r\n        return "data.abilities.int.total";\r\n      case "wis":\r\n        if (changeType === "penalty") return "data.abilities.wis.penalty";\r\n        return "data.abilities.wis.total";\r\n      case "cha":\r\n        if (changeType === "penalty") return "data.abilities.cha.penalty";\r\n        return "data.abilities.cha.total";\r\n      case "ac":\r\n        if (changeType === "dodge") return ["data.attributes.ac.normal.total", "data.attributes.ac.touch.total", "data.attributes.cmd.total"];\r\n        else if (changeType === "deflection") {\r\n          return ["data.attributes.ac.normal.total", "data.attributes.ac.touch.total",\r\n          "data.attributes.ac.flatFooted.total", "data.attributes.cmd.total", "data.attributes.cmd.flatFootedTotal"];\r\n        }\r\n        return ["data.attributes.ac.normal.total", "data.attributes.ac.touch.total", "data.attributes.ac.flatFooted.total"];\r\n      case "aac":\r\n      case "sac":\r\n      case "nac":\r\n        return ["data.attributes.ac.normal.total", "data.attributes.ac.flatFooted.total"];\r\n      case "attack":\r\n        return "data.attributes.attack.general";\r\n      case "mattack":\r\n        return "data.attributes.attack.melee";\r\n      case "rattack":\r\n        return "data.attributes.attack.ranged";\r\n      case "damage":\r\n        return "data.attributes.damage.general";\r\n      case "wdamage":\r\n        return "data.attributes.damage.weapon";\r\n      case "sdamage":\r\n        return "data.attributes.damage.spell";\r\n      case "allSavingThrows":\r\n        return ["data.attributes.savingThrows.fort.total", "data.attributes.savingThrows.ref.total", "data.attributes.savingThrows.will.total"];\r\n      case "fort":\r\n        return "data.attributes.savingThrows.fort.total";\r\n      case "ref":\r\n        return "data.attributes.savingThrows.ref.total";\r\n      case "will":\r\n        return "data.attributes.savingThrows.will.total";\r\n      case "skills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let b of Object.keys(skl.subSkills)) {\r\n              result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "strSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "str") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "str") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "dexSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "dex") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "dex") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "conSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "con") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "con") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "intSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "int") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "int") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "wisSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "wis") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "wis") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "chaSkills":\r\n        for (let [a, skl] of Object.entries(curData.skills)) {\r\n          if (skl == null) continue;\r\n          if (skl.ability === "cha") result.push(`data.skills.${a}.changeBonus`);\r\n\r\n          if (skl.subSkills != null) {\r\n            for (let [b, subSkl] of Object.entries(skl.subSkills)) {\r\n              if (subSkl != null && subSkl.ability === "cha") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);\r\n            }\r\n          }\r\n        }\r\n        return result;\r\n      case "allChecks":\r\n        return ["data.abilities.str.checkMod", "data.abilities.dex.checkMod", "data.abilities.con.checkMod",\r\n          "data.abilities.int.checkMod", "data.abilities.wis.checkMod", "data.abilities.cha.checkMod"];\r\n      case "strChecks":\r\n        return "data.abilities.str.checkMod";\r\n      case "dexChecks":\r\n        return "data.abilities.dex.checkMod";\r\n      case "conChecks":\r\n        return "data.abilities.con.checkMod";\r\n      case "intChecks":\r\n        return "data.abilities.int.checkMod";\r\n      case "wisChecks":\r\n        return "data.abilities.wis.checkMod";\r\n      case "chaChecks":\r\n        return "data.abilities.cha.checkMod";\r\n      case "allSpeeds":\r\n        for (let speedKey of Object.keys(curData.attributes.speed)) {\r\n          if (getProperty(curData, `attributes.speed.${speedKey}.base`)) result.push(`data.attributes.speed.${speedKey}.total`);\r\n        }\r\n        return result;\r\n      case "landSpeed":\r\n        return "data.attributes.speed.land.total";\r\n      case "climbSpeed":\r\n        return "data.attributes.speed.climb.total";\r\n      case "swimSpeed":\r\n        return "data.attributes.speed.swim.total";\r\n      case "burrowSpeed":\r\n        return "data.attributes.speed.burrow.total";\r\n      case "flySpeed":\r\n        return "data.attributes.speed.fly.total";\r\n      case "cmb":\r\n        return "data.attributes.cmb.total";\r\n      case "cmd":\r\n        return ["data.attributes.cmd.total", "data.attributes.cmd.flatFootedTotal"];\r\n      case "init":\r\n        return "data.attributes.init.total";\r\n    }\r\n\r\n    if (changeTarget.match(/^skill\\.([a-zA-Z0-9]+)$/)) {\r\n      const sklKey = RegExp.$1;\r\n      if (curData.skills[sklKey] != null) {\r\n        return `data.skills.${sklKey}.changeBonus`;\r\n      }\r\n    }\r\n    else if (changeTarget.match(/^skill\\.([a-zA-Z0-9]+)\\.subSkills\\.([a-zA-Z0-9]+)$/)) {\r\n      const sklKey = RegExp.$1;\r\n      const subSklKey = RegExp.$2;\r\n      if (curData.skills[sklKey] != null && curData.skills[sklKey].subSkills[subSklKey] != null) {\r\n        return `data.skills.${sklKey}.subSkills.${subSklKey}.changeBonus`;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _dataIsPC(data) {\r\n    if (data.permission != null) {\r\n      const nonGM = game.users.entities.filter(u => !u.isGM);\r\n      return nonGM.some(u => {\r\n        if (data.permission["default"] >= CONST.ENTITY_PERMISSIONS["OWNER"]) return true;\r\n        return data.permission[u._id] >= CONST.ENTITY_PERMISSIONS["OWNER"];\r\n      });\r\n    }\r\n    return this.isPC;\r\n  }\r\n\r\n  _addDefaultChanges(data, changes, flags, sourceInfo) {\r\n    // Class hit points\r\n    const classes = data.items.filter(o => o.type === "class" && getProperty(o.data, "classType") !== "racial").sort((a, b) => {\r\n      return a.sort - b.sort;\r\n    });\r\n    const racialHD = data.items.filter(o => o.type === "class" && getProperty(o.data, "classType") === "racial").sort((a, b) => {\r\n      return a.sort - b.sort;\r\n    });\r\n\r\n    const healthConfig = game.settings.get("pf1", "healthConfig");\r\n    const cls_options  = this.data.type === "character" ? healthConfig.hitdice.PC : healthConfig.hitdice.NPC;\r\n    const race_options = healthConfig.hitdice.Racial;\r\n    const round = {up: Math.ceil, nearest: Math.round, down: Math.floor}[healthConfig.rounding];\r\n    const continuous = {discrete: false, continuous: true}[healthConfig.continuity];\r\n\r\n    const push_health = (value, source) => {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: value.toString(), target: "misc", subTarget: "mhp", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: source.name, subtype: source.name.toString()}\r\n      });\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: value.toString(), target: "misc", subTarget: "vigor", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: source.name, subtype: source.name.toString()}\r\n      });\r\n    }\r\n    const manual_health = (health_source) => {\r\n      let health = health_source.data.hp + (health_source.data.classType === "base") * health_source.data.fc.hp.value;\r\n      if (!continuous) health = round(health);\r\n      push_health(health, health_source);\r\n    }\r\n    const auto_health = (health_source, options, maximized=0) => {\r\n      let die_health = 1 + (health_source.data.hd-1) * options.rate;\r\n      if (!continuous) die_health = round(die_health);\r\n\r\n      const maxed_health = Math.min(health_source.data.level, maximized) * health_source.data.hd;\r\n      const level_health = Math.max(0, health_source.data.level - maximized) * die_health;\r\n      const favor_health = (health_source.data.classType === "base") * health_source.data.fc.hp.value;\r\n      let   health = maxed_health + level_health + favor_health;\r\n\r\n      push_health(health, health_source);\r\n    }\r\n    const compute_health = (health_sources, options) => {\r\n      // Compute and push health, tracking the remaining maximized levels.\r\n      if (options.auto) {\r\n        let maximized = options.maximized;\r\n        for (const hd of health_sources) {\r\n          auto_health(hd, options, maximized);\r\n          maximized = Math.max(0, maximized - hd.data.level);\r\n        }\r\n      } else health_sources.forEach(race => manual_health(race));\r\n    }\r\n\r\n    compute_health(racialHD, race_options);\r\n    compute_health(classes, cls_options);\r\n\r\n    // Add Constitution to HP\r\n    let hpAbility = getProperty(data, "data.attributes.hpAbility");\r\n    if (hpAbility == null) hpAbility = "con";\r\n    if (hpAbility !== "") {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: `@abilities.${hpAbility}.mod * @attributes.hd.total`, target: "misc", subTarget: "mhp", modifier: "base" }, {inplace: false}),\r\n        source: {name: "Constitution"}\r\n      });\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: `2 * (@abilities.${hpAbility}.total + @abilities.${hpAbility}.drain)`, target: "misc", subTarget: "wounds", modifier: "base" }, {inplace: false}),\r\n        source: {name: "Constitution"}\r\n      });\r\n    }\r\n\r\n    // Add variables to CMD and CMD\r\n    {\r\n      // BAB to CMB\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@attributes.bab.total", target: "misc", subTarget: "cmb", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: game.i18n.localize("PF1.BAB")},\r\n      });\r\n      // Strength to CMB\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@abilities.str.mod", target: "misc", subTarget: "cmb", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities["str"]},\r\n      });\r\n      // Energy Drain to CMB\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-@attributes.energyDrain", target: "misc", subTarget: "cmb", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: game.i18n.localize("PF1.CondTypeEnergyDrain")},\r\n      });\r\n\r\n      // BAB to CMD\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@attributes.bab.total", target: "misc", subTarget: "cmd", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: game.i18n.localize("PF1.BAB")},\r\n      });\r\n      // Strength to CMD\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@abilities.str.mod", target: "misc", subTarget: "cmd", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities["str"]},\r\n      });\r\n      // Energy Drain to CMD\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-@attributes.energyDrain", target: "misc", subTarget: "cmd", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: game.i18n.localize("PF1.CondTypeEnergyDrain")},\r\n      });\r\n    }\r\n    \r\n    // Add Dexterity Modifier to Initiative\r\n    {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@abilities.dex.mod", target: "misc", subTarget: "init", modifier: "untyped", priority: -100 }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities["dex"]},\r\n      });\r\n    }\r\n\r\n    // Add Ability modifiers and Energy Drain to saving throws\r\n    {\r\n      let abl;\r\n      // Ability Mod to Fortitude\r\n      abl = getProperty(data, "data.attributes.savingThrows.fort.ability");\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: `@abilities.${abl}.mod`, target: "savingThrows", subTarget: "fort", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities[abl]},\r\n      });\r\n      // Ability Mod to Reflex\r\n      abl = getProperty(data, "data.attributes.savingThrows.ref.ability");\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: `@abilities.${abl}.mod`, target: "savingThrows", subTarget: "ref", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities[abl]},\r\n      });\r\n      // Ability Mod to Will\r\n      abl = getProperty(data, "data.attributes.savingThrows.will.ability");\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: `@abilities.${abl}.mod`, target: "savingThrows", subTarget: "will", modifier: "untyped" }, {inplace: false}),\r\n        source: {name: CONFIG.PF1.abilities[abl]},\r\n      });\r\n      // Energy Drain\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-@attributes.energyDrain", target: "savingThrows", subTarget: "allSavingThrows", modifier: "penalty" }, {inplace: false}),\r\n        source: {name: game.i18n.localize("PF1.CondTypeEnergyDrain")},\r\n      });\r\n    }\r\n    // Natural armor\r\n    {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "@attributes.naturalAC", target: "ac", subTarget: "nac", modifier: "base" }, {inplace: false}),\r\n        source: {\r\n          name: game.i18n.localize("PF1.BuffTarACNatural"),\r\n        }\r\n      });\r\n    }\r\n    // Add armor bonuses from equipment\r\n    data.items.filter(obj => { return obj.type === "equipment" && obj.data.equipped; }).forEach(item => {\r\n      let armorTarget = "aac";\r\n      if (item.data.equipmentType === "shield") armorTarget = "sac";\r\n      // Push base armor\r\n      if (item.data.armor.value) {\r\n        changes.push({\r\n          raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: item.data.armor.value.toString(), target: "ac", subTarget: armorTarget, modifier: "base" }, {inplace: false}),\r\n          source: {\r\n            type: item.type,\r\n            name: item.name\r\n          }\r\n        });\r\n      }\r\n      // Push enhancement bonus to armor\r\n      if (item.data.armor.enh) {\r\n        changes.push({\r\n          raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: item.data.armor.enh.toString(), target: "ac", subTarget: armorTarget, modifier: "enh" }, {inplace: false}),\r\n          source: {\r\n            type: item.type,\r\n            name: item.name\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    // Add fly bonuses or penalties based on maneuverability\r\n    const flyKey = getProperty(data, "data.attributes.speed.fly.maneuverability");\r\n    let flyValue = 0;\r\n    if (flyKey != null) flyValue = CONFIG.PF1.flyManeuverabilityValues[flyKey];\r\n    if (flyValue !== 0) {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: flyValue.toString(), target: "skill", subTarget: "skill.fly", modifier: "untyped" }, {inplace: false}),\r\n        source: {\r\n          name: game.i18n.localize("PF1.FlyManeuverability"),\r\n        },\r\n      });\r\n    }\r\n    // Add swim and climb skill bonuses based on having speeds for them\r\n    {\r\n      const climbSpeed = getProperty(data, "data.attributes.speed.climb.total") || 0;\r\n      const swimSpeed = getProperty(data, "data.attributes.speed.swim.total") || 0;\r\n      if (climbSpeed > 0) {\r\n        changes.push({\r\n          raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "8", target: "skill", subTarget: "skill.clm", modifier: "racial" }, {inplace: false}),\r\n          source: {\r\n            name: game.i18n.localize("PF1.SpeedClimb"),\r\n          },\r\n        });\r\n      }\r\n      if (swimSpeed > 0) {\r\n        changes.push({\r\n          raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "8", target: "skill", subTarget: "skill.swm", modifier: "racial" }, {inplace: false}),\r\n          source: {\r\n            name: game.i18n.localize("PF1.SpeedSwim"),\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    // Add size bonuses to various attributes\r\n    const sizeKey = data.data.traits.size;\r\n    if (sizeKey !== "med") {\r\n      // AC\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: CONFIG.PF1.sizeMods[sizeKey].toString(), target: "ac", subTarget: "ac", modifier: "size" }, {inplace: false}),\r\n        source: {\r\n          type: "size"\r\n        }\r\n      });\r\n      // Stealth skill\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: CONFIG.PF1.sizeStealthMods[sizeKey].toString(), target: "skill", subTarget: "skill.ste", modifier: "size" }, {inplace: false}),\r\n        source: {\r\n          type: "size"\r\n        }\r\n      });\r\n      // Fly skill\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: CONFIG.PF1.sizeFlyMods[sizeKey].toString(), target: "skill", subTarget: "skill.fly", modifier: "size" }, {inplace: false}),\r\n        source: {\r\n          type: "size"\r\n        }\r\n      });\r\n      // CMB\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: CONFIG.PF1.sizeSpecialMods[sizeKey].toString(), target: "misc", subTarget: "cmb", modifier: "size" }, {inplace: false}),\r\n        source: {\r\n          type: "size"\r\n        }\r\n      });\r\n      // CMD\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: CONFIG.PF1.sizeSpecialMods[sizeKey].toString(), target: "misc", subTarget: "cmd", modifier: "size" }, {inplace: false}),\r\n        source: {\r\n          type: "size"\r\n        }\r\n      });\r\n    }\r\n\r\n    // Add conditions\r\n    for (let [con, v] of Object.entries(data.data.attributes.conditions || {})) {\r\n      if (!v) continue;\r\n\r\n      switch (con) {\r\n        case "blind":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "ac", subTarget: "ac", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondBlind") }\r\n          });\r\n          flags["loseDexToAC"] = true;\r\n          sourceInfo["data.attributes.ac.normal.total"] = sourceInfo["data.attributes.ac.normal.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.touch.total"] = sourceInfo["data.attributes.ac.touch.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.cmd.total"] = sourceInfo["data.attributes.cmd.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.cmd.flatFootedTotal"] = sourceInfo["data.attributes.cmd.flatFootedTotal"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.normal.total"].negative.push({ name: game.i18n.localize("PF1.CondBlind"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          sourceInfo["data.attributes.ac.touch.total"].negative.push({ name: game.i18n.localize("PF1.CondBlind"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          sourceInfo["data.attributes.cmd.total"].negative.push({ name: game.i18n.localize("PF1.CondBlind"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          sourceInfo["data.attributes.cmd.flatFootedTotal"].negative.push({ name: game.i18n.localize("PF1.CondBlind"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          break;\r\n        case "dazzled":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-1", target: "attack", subTarget: "attack", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondDazzled") }\r\n          });\r\n          break;\r\n        case "deaf":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-4", target: "misc", subTarget: "init", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondDeaf") }\r\n          });\r\n          break;\r\n        case "entangled":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-4", target: "ability", subTarget: "dex", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondEntangled") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "attack", subTarget: "attack", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondEntangled") }\r\n          });\r\n          break;\r\n        case "grappled":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-4", target: "ability", subTarget: "dex", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondGrappled") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "attack", subTarget: "attack", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondGrappled") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "misc", subTarget: "cmb", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondGrappled") }\r\n          });\r\n          break;\r\n        case "helpless":\r\n          flags["noDex"] = true;\r\n          sourceInfo["data.abilities.dex.total"] = sourceInfo["data.abilities.dex.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.abilities.dex.total"].negative.push({ name: game.i18n.localize("PF1.CondHelpless"), value: game.i18n.localize("PF1.ChangeFlagNoDex") });\r\n          break;\r\n        case "paralyzed":\r\n          flags["noDex"] = true;\r\n          flags["noStr"] = true;\r\n          sourceInfo["data.abilities.dex.total"] = sourceInfo["data.abilities.dex.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.abilities.dex.total"].negative.push({ name: game.i18n.localize("PF1.CondParalyzed"), value: game.i18n.localize("PF1.ChangeFlagNoDex") });\r\n          sourceInfo["data.abilities.str.total"] = sourceInfo["data.abilities.str.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.abilities.str.total"].negative.push({ name: game.i18n.localize("PF1.CondParalyzed"), value: game.i18n.localize("PF1.ChangeFlagNoStr") });\r\n          break;\r\n        case "pinned":\r\n          flags["loseDexToAC"] = true;\r\n          sourceInfo["data.attributes.ac.normal.total"] = sourceInfo["data.attributes.ac.normal.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.touch.total"] = sourceInfo["data.attributes.ac.touch.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.cmd.total"] = sourceInfo["data.attributes.cmd.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.normal.total"].negative.push({ name: game.i18n.localize("PF1.CondPinned"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          sourceInfo["data.attributes.ac.touch.total"].negative.push({ name: game.i18n.localize("PF1.CondPinned"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          sourceInfo["data.attributes.cmd.total"].negative.push({ name: game.i18n.localize("PF1.CondPinned"), value: game.i18n.localize("PF1.ChangeFlagLoseDexToAC") });\r\n          break;\r\n        case "fear":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "attack", subTarget: "attack", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondFear") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "savingThrows", subTarget: "allSavingThrows", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondFear") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "skills", subTarget: "skills", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondFear") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "abilityChecks", subTarget: "allChecks", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondFear") }\r\n          });\r\n          break;\r\n        case "sickened":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "attack", subTarget: "attack", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondSickened") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "damage", subTarget: "wdamage", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondSickened") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "savingThrows", subTarget: "allSavingThrows", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondSickened") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "skills", subTarget: "skills", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondSickened") }\r\n          });\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "abilityChecks", subTarget: "allChecks", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondSickened") }\r\n          });\r\n          break;\r\n        case "stunned":\r\n          changes.push({\r\n            raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "ac", subTarget: "ac", modifier: "penalty" }, {inplace: false}),\r\n            source: { name: game.i18n.localize("PF1.CondStunned") }\r\n          });\r\n          flags["loseDexToAC"] = true;\r\n          sourceInfo["data.attributes.ac.normal.total"] = sourceInfo["data.attributes.ac.normal.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.touch.total"] = sourceInfo["data.attributes.ac.touch.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.cmd.total"] = sourceInfo["data.attributes.cmd.total"] || { positive: [], negative: [] };\r\n          sourceInfo["data.attributes.ac.normal.total"].negative.push({ name: "Stunned", value: "Lose Dex to AC" });\r\n          sourceInfo["data.attributes.ac.touch.total"].negative.push({ name: "Stunned", value: "Lose Dex to AC" });\r\n          sourceInfo["data.attributes.cmd.total"].negative.push({ name: "Stunned", value: "Lose Dex to AC" });\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Handle fatigue and exhaustion so that they don\'t stack\r\n    if (data.data.attributes.conditions.exhausted) {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-6", target: "ability", subTarget: "str", modifier: "penalty" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondExhausted") }\r\n      });\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-6", target: "ability", subTarget: "dex", modifier: "penalty" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondExhausted") }\r\n      });\r\n    }\r\n    else if (data.data.attributes.conditions.fatigued) {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "ability", subTarget: "str", modifier: "penalty" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondFatigued") }\r\n      });\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-2", target: "ability", subTarget: "dex", modifier: "penalty" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondFatigued") }\r\n      });\r\n    }\r\n\r\n    // Apply level drain to hit points\r\n    if (!Number.isNaN(data.data.attributes.energyDrain) && data.data.attributes.energyDrain > 0) {\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-(@attributes.energyDrain * 5)", target: "misc", subTarget: "mhp", modifier: "untyped" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondTypeEnergyDrain") }\r\n      });\r\n      changes.push({\r\n        raw: mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].defaultChange, { formula: "-(@attributes.energyDrain * 5)", target: "misc", subTarget: "vigor", modifier: "untyped" }, {inplace: false}),\r\n        source: { name: game.i18n.localize("PF1.CondTypeEnergyDrain") }\r\n      });\r\n    }\r\n  }\r\n\r\n  async _updateChanges({data=null}={}) {\r\n    let updateData = {};\r\n    let srcData1 = mergeObject(this.data, expandObject(data || {}), { inplace: false });\r\n    srcData1.items = this.items.reduce((cur, i) => {\r\n      const otherItem = srcData1.items.filter(o => o._id === i._id)[0];\r\n      if (otherItem) cur.push(mergeObject(i.data, otherItem, { inplace: false }));\r\n      else cur.push(i.data);\r\n      return cur;\r\n    }, []);\r\n    const changeObjects = srcData1.items.filter(obj => { return obj.data.changes != null; }).filter(obj => {\r\n      if (obj.type === "buff") return obj.data.active;\r\n      if (obj.type === "equipment" || obj.type === "weapon") return obj.data.equipped;\r\n      return true;\r\n    });\r\n\r\n    // Track previous values\r\n    const prevValues = {\r\n      mhp: this.data.data.attributes.hp.max,\r\n      wounds: getProperty(this.data, "data.attributes.wounds.max") || 0,\r\n      vigor: getProperty(this.data, "data.attributes.vigor.max") || 0,\r\n    };\r\n\r\n    // Gather change types\r\n    const changeData = {};\r\n    const changeDataTemplate = {\r\n      positive: {\r\n        value: 0,\r\n        sources: []\r\n      },\r\n      negative: {\r\n        value: 0,\r\n        sources: []\r\n      }\r\n    };\r\n    for (let [key, buffTarget] of Object.entries(CONFIG.PF1.buffTargets)) {\r\n      if (typeof buffTarget === "object") {\r\n        // Add specific skills as targets\r\n        if (key === "skill") {\r\n          for (let [s, skl] of Object.entries(this.data.data.skills)) {\r\n            if (skl == null) continue;\r\n            if (!skl.subSkills) {\r\n              changeData[`skill.${s}`] = {};\r\n              Object.keys(CONFIG.PF1.bonusModifiers).forEach(b => {\r\n                changeData[`skill.${s}`][b] = duplicate(changeDataTemplate);\r\n              });\r\n            }\r\n            else {\r\n              for (let s2 of Object.keys(skl.subSkills)) {\r\n                changeData[`skill.${s}.subSkills.${s2}`] = {};\r\n                Object.keys(CONFIG.PF1.bonusModifiers).forEach(b => {\r\n                  changeData[`skill.${s}.subSkills.${s2}`][b] = duplicate(changeDataTemplate);\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Add static targets\r\n        else {\r\n          for (let subKey of Object.keys(buffTarget)) {\r\n            if (subKey.startsWith("_")) continue;\r\n            changeData[subKey] = {};\r\n            Object.keys(CONFIG.PF1.bonusModifiers).forEach(b => {\r\n              changeData[subKey][b] = duplicate(changeDataTemplate);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    // Create an array of changes\r\n    let allChanges = [];\r\n    changeObjects.forEach(item => {\r\n      item.data.changes.forEach(change => {\r\n        allChanges.push({\r\n          raw: change,\r\n          source: {\r\n            value: 0,\r\n            type: item.type,\r\n            subtype: this.constructor._getChangeItemSubtype(item),\r\n            name: item.name,\r\n            item: item\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    // Initialize data\r\n    let flags = {},\r\n      sourceInfo = {};\r\n    this._resetData(updateData, srcData1, flags, sourceInfo);\r\n    this._addDefaultChanges(srcData1, allChanges, flags, sourceInfo);\r\n\r\n    // Check flags\r\n    for (let obj of changeObjects) {\r\n      if (!obj.data.changeFlags) continue;\r\n      for (let [flagKey, flagValue] of Object.entries(obj.data.changeFlags)) {\r\n        if (flagValue === true) {\r\n          flags[flagKey] = true;\r\n\r\n          let targets = [];\r\n          let value = "";\r\n\r\n          switch (flagKey) {\r\n            case "loseDexToAC":\r\n              sourceInfo["data.attributes.ac.normal.total"] = sourceInfo["data.attributes.ac.normal.total"] || { positive: [], negative: [] };\r\n              sourceInfo["data.attributes.ac.touch.total"] = sourceInfo["data.attributes.ac.touch.total"] || { positive: [], negative: [] };\r\n              sourceInfo["data.attributes.cmd.total"] = sourceInfo["data.attributes.cmd.total"] || { positive: [], negative: [] };\r\n              targets = [\r\n                sourceInfo["data.attributes.ac.normal.total"].negative,\r\n                sourceInfo["data.attributes.ac.touch.total"].negative,\r\n                sourceInfo["data.attributes.cmd.total"].negative\r\n              ];\r\n              value = "Lose Dex to AC";\r\n              break;\r\n            case "noDex":\r\n              sourceInfo["data.abilities.dex.total"] = sourceInfo["data.abilities.dex.total"] || { positive: [], negative: [] };\r\n              targets = [sourceInfo["data.abilities.dex.total"].negative];\r\n              value = "0 Dex";\r\n              break;\r\n            case "noStr":\r\n              sourceInfo["data.abilities.str.total"] = sourceInfo["data.abilities.str.total"] || { positive: [], negative: [] };\r\n              targets = [sourceInfo["data.abilities.str.total"].negative];\r\n              value = "0 Str";\r\n              break;\r\n            case "oneInt":\r\n              sourceInfo["data.abilities.int.total"] = sourceInfo["data.abilities.int.total"] || { positive: [], negative: [] };\r\n              targets = [sourceInfo["data.abilities.int.total"].negative];\r\n              value = "1 Int";\r\n              break;\r\n            case "oneWis":\r\n              sourceInfo["data.abilities.wis.total"] = sourceInfo["data.abilities.wis.total"] || { positive: [], negative: [] };\r\n              targets = [sourceInfo["data.abilities.wis.total"].negative];\r\n              value = "1 Wis";\r\n              break;\r\n            case "oneCha":\r\n              sourceInfo["data.abilities.cha.total"] = sourceInfo["data.abilities.cha.total"] || { positive: [], negative: [] };\r\n              targets = [sourceInfo["data.abilities.cha.total"].negative];\r\n              value = "1 Cha";\r\n              break;\r\n          }\r\n\r\n          for (let t of Object.values(targets)) {\r\n            t.push({ type: obj.type, subtype: this.constructor._getChangeItemSubtype(obj), value: value });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    for (let flagKey of Object.keys(flags)) {\r\n      if (!flags[flagKey]) continue;\r\n\r\n      switch (flagKey) {\r\n        case "noDex":\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.dex.total", 0);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.dex.mod", -5);\r\n          break;\r\n        case "noStr":\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.str.total", 0);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.str.mod", -5);\r\n          break;\r\n        case "oneInt":\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.int.total", 1);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.int.mod", -5);\r\n          break;\r\n        case "oneWis":\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.wis.total", 1);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.wis.mod", -5);\r\n          break;\r\n        case "oneCha":\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.cha.total", 1);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.abilities.cha.mod", -5);\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Sort changes\r\n    allChanges.sort(this._sortChanges.bind(this));\r\n\r\n    // Parse changes\r\n    let temp = [];\r\n    const origData = mergeObject(this.data, data != null ? expandObject(data) : {}, { inplace: false });\r\n    updateData = flattenObject({ data: mergeObject(origData.data, expandObject(updateData).data, { inplace: false }) });\r\n    this._addDynamicData({ updateData: updateData, data: srcData1, forceModUpdate: true, flags: flags });\r\n    allChanges.forEach((change, a) => {\r\n      const formula = change.raw.formula || "";\r\n      if (formula === "") return;\r\n      const changeTarget = change.raw.subTarget;\r\n      if (changeData[changeTarget] == null) return;\r\n      const rollData = this.getRollData(srcData1.data);\r\n\r\n      rollData.item = {};\r\n      if (change.source.item != null) {\r\n        rollData.item = change.source.item.data;\r\n      }\r\n\r\n      const roll = new Roll(formula, rollData);\r\n\r\n      try {\r\n        change.raw.value = roll.roll().total;\r\n      }\r\n      catch (e) {\r\n        ui.notifications.error(game.i18n.localize("PF1.ErrorItemFormula").format(change.source.item.name, this.name));\r\n      }\r\n      this._parseChange(change, changeData[changeTarget], flags);\r\n      temp.push(changeData[changeTarget]);\r\n\r\n      if (allChanges.length <= a+1 || allChanges[a+1].raw.subTarget !== changeTarget) {\r\n        const newData = this._applyChanges(changeTarget, temp, srcData1);\r\n        this._addDynamicData({ updateData: updateData, data: srcData1, changes: newData, flags: flags });\r\n        temp = [];\r\n      }\r\n    });\r\n\r\n    // Update encumbrance\r\n    this._computeEncumbrance(updateData, srcData1);\r\n    switch (srcData1.data.attributes.encumbrance.level) {\r\n      case 0:\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.acp.encumbrance", 0);\r\n        break;\r\n      case 1:\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.acp.encumbrance", 3);\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.maxDexBonus", Math.min(updateData["data.attributes.maxDexBonus"] || Number.POSITIVE_INFINITY, 3));\r\n        break;\r\n      case 2:\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.acp.encumbrance", 6);\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.maxDexBonus", Math.min(updateData["data.attributes.maxDexBonus"] || Number.POSITIVE_INFINITY, 1));\r\n        break;\r\n    }\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.acp.total", Math.max(updateData["data.attributes.acp.gear"], updateData["data.attributes.acp.encumbrance"]));\r\n\r\n    // Update skills and AC and CMD from Dexterity\r\n    {\r\n      this._updateSkills(updateData, srcData1);\r\n      const dex = srcData1.data.abilities.dex.mod;\r\n      const maxDex = srcData1.data.attributes.maxDexBonus;\r\n      const ac = {\r\n        normal: srcData1.data.attributes.ac.normal.total,\r\n        touch: srcData1.data.attributes.ac.touch.total,\r\n        ff: srcData1.data.attributes.ac.flatFooted.total,\r\n      };\r\n      const cmd = {\r\n        normal: srcData1.data.attributes.cmd.total,\r\n        ff: srcData1.data.attributes.cmd.flatFootedTotal,\r\n      };\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.ac.normal.total", ac.normal + (maxDex != null ? Math.min(maxDex, dex) : dex));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.ac.touch.total", ac.touch + (maxDex != null ? Math.min(maxDex, dex) : dex));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.ac.flatFooted.total", ac.ff + Math.min(0, dex));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.cmd.total", cmd.normal + (maxDex != null ? Math.min(maxDex, dex) : dex));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.cmd.flatFootedTotal", cmd.ff + Math.min(0, dex));\r\n    }\r\n\r\n    // Reduce final speed under certain circumstances\r\n    let armorItems = srcData1.items.filter(o => o.type === "equipment");\r\n    if ((updateData["data.attributes.encumbrance.level"] >= 1 && !flags.noEncumbrance) ||\r\n    (armorItems.filter(o => getProperty(o.data, "equipmentSubtype") === "mediumArmor" && o.data.equipped).length && !flags.mediumArmorFullSpeed) ||\r\n    (armorItems.filter(o => getProperty(o.data, "equipmentSubtype") === "heavyArmor" && o.data.equipped).length && !flags.heavyArmorFullSpeed)) {\r\n      for (let speedKey of Object.keys(srcData1.data.attributes.speed)) {\r\n        let value = updateData[`data.attributes.speed.${speedKey}.total`];\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, `data.attributes.speed.${speedKey}.total`, ActorPF.getReducedMovementSpeed(value));\r\n      }\r\n    }\r\n    // Reset spell slots\r\n    for (let spellbookKey of Object.keys(getProperty(srcData1, "data.attributes.spells.spellbooks"))) {\r\n      const spellbookAbilityKey = getProperty(srcData1, `data.attributes.spells.spellbooks.${spellbookKey}.ability`);\r\n      const spellbookAbilityMod = getProperty(srcData1, `data.abilities.${spellbookAbilityKey}.mod`);\r\n\r\n      for (let a = 0; a < 10; a++) {\r\n        let base = parseInt(getProperty(srcData1, `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.base`));\r\n        if (Number.isNaN(base)) {\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.base`, null);\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.max`, 0);\r\n        }\r\n        else {\r\n          const value = (typeof spellbookAbilityMod === "number") ? (base + ActorPF.getSpellSlotIncrease(spellbookAbilityMod, a)) : base;\r\n          if (getProperty(srcData1, `data.attributes.spells.spellbooks.${spellbookKey}.autoSpellLevels`)) {\r\n            Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.max`, value);\r\n          }\r\n          else {\r\n            Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.max`, base);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add current hit points\r\n    if (updateData["data.attributes.hp.max"]) {\r\n      const hpDiff = updateData["data.attributes.hp.max"] - prevValues.mhp;\r\n      if (hpDiff !== 0) {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.hp.value", Math.min(updateData["data.attributes.hp.max"], srcData1.data.attributes.hp.value + hpDiff));\r\n      }\r\n    }\r\n    if (updateData["data.attributes.wounds.max"]) {\r\n      const wDiff = updateData["data.attributes.wounds.max"] - prevValues.wounds;\r\n      if (wDiff !== 0) {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.wounds.value", Math.min(updateData["data.attributes.wounds.max"], srcData1.data.attributes.wounds.value + wDiff));\r\n      }\r\n    }\r\n    if (updateData["data.attributes.vigor.max"]) {\r\n      const vDiff = updateData["data.attributes.vigor.max"] - prevValues.vigor;\r\n      if (vDiff !== 0) {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData1, updateData, "data.attributes.vigor.value", Math.min(updateData["data.attributes.vigor.max"], srcData1.data.attributes.vigor.value + vDiff));\r\n      }\r\n    }\r\n\r\n\r\n    // Refresh source info\r\n    for (let [bt, change] of Object.entries(changeData)) {\r\n      for (let [ct, values] of Object.entries(change)) {\r\n        let customBuffTargets = this._getChangeFlat(bt, ct, srcData1.data);\r\n        if (!(customBuffTargets instanceof Array)) customBuffTargets = [customBuffTargets];\r\n\r\n        // Replace certain targets\r\n        // Replace ability penalties\r\n        customBuffTargets = customBuffTargets.filter(t => { return t != null; }).map(t => {\r\n          return t.replace(/^data\\.abilities\\.([a-zA-Z0-9]+)\\.penalty$/, "data.abilities.$1.total");\r\n        });\r\n\r\n        // Add sources\r\n        for (let ebt of Object.values(customBuffTargets)) {\r\n            sourceInfo[ebt] = sourceInfo[ebt] || { positive: [], negative: [] };\r\n            if (values.positive.value > 0) sourceInfo[ebt].positive.push(...values.positive.sources);\r\n            if (values.negative.value < 0) sourceInfo[ebt].negative.push(...values.negative.sources);\r\n        }\r\n      }\r\n    }\r\n\r\n    this._setSourceDetails(mergeObject(this.data, srcData1, { inplace: false }), sourceInfo, flags);\r\n\r\n    const diffData = diffObject(this.data, srcData1);\r\n\r\n    // Apply changes\r\n    if (this.collection != null && Object.keys(diffData).length > 0) {\r\n      let newData = {};\r\n      if (data != null) newData = flattenObject(mergeObject(data, flattenObject(diffData), { inplace: false }));\r\n      return { data: newData, diff: diffData };\r\n    }\r\n    return { data: {}, diff: {} };\r\n  }\r\n\r\n  _applyChanges(buffTarget, changeData, rollData) {\r\n    let consolidatedChanges = {};\r\n    let changes = {};\r\n    for (let change of changeData) {\r\n      for (let b of Object.keys(change)) {\r\n        changes[b] = { positive: 0, negative: 0 };\r\n      }\r\n      for (let [changeType, data] of Object.entries(change)) {\r\n        // Add positive value\r\n        if (data.positive.value !== 0) {\r\n          changes[changeType].positive += data.positive.value;\r\n        }\r\n        // Add negative value\r\n        if (data.negative.value !== 0) {\r\n            changes[changeType].negative += data.negative.value;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let [changeTarget, value] of Object.entries(changes)) {\r\n      if (value.positive !== 0 || value.negative !== 0) {\r\n        let flatTargets = this._getChangeFlat(buffTarget, changeTarget, rollData.data);\r\n        if (flatTargets == null) continue;\r\n\r\n        if (!(flatTargets instanceof Array)) flatTargets = [flatTargets];\r\n        for (let target of flatTargets) {\r\n          consolidatedChanges[target] = (consolidatedChanges[target] || 0) + value.positive + value.negative;\r\n\r\n           // Apply final rounding of health, if required.\r\n          if (["data.attributes.hp.max", "data.attributes.wounds.max", "data.attributes.vigor.max"].includes(target)) {\r\n            const healthConfig = game.settings.get("pf1", "healthConfig")\r\n            const continuous = {discrete: false, continuous: true}[healthConfig.continuity]\r\n            if (continuous) {\r\n              const round = {up: Math.ceil, nearest: Math.round, down: Math.floor}[healthConfig.rounding]\r\n              consolidatedChanges[target] = round(consolidatedChanges[target])\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return consolidatedChanges;\r\n  }\r\n\r\n  _resetData(updateData, data, flags, sourceInfo) {\r\n    const data1 = data.data;\r\n    if (flags == null) flags = {};\r\n    const items = data.items;\r\n    const classes = items.filter(obj => { return obj.type === "class"; });\r\n    const useFractionalBaseBonuses = game.settings.get("pf1", "useFractionalBaseBonuses") === true;\r\n\r\n    // Reset HD\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.hd.total", data1.details.level.value);\r\n\r\n    // Reset CR\r\n    if (this.data.type === "npc") {\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.details.cr.total", this.getCR(data1));\r\n    }\r\n\r\n    // Reset abilities\r\n    for (let [a, abl] of Object.entries(data1.abilities)) {\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.penalty`, 0);\r\n      if (a === "str" && flags.noStr === true) continue;\r\n      if (a === "dex" && flags.noDex === true) continue;\r\n      if (a === "int" && flags.oneInt === true) continue;\r\n      if (a === "wis" && flags.oneWis === true) continue;\r\n      if (a === "cha" && flags.oneCha === true) continue;\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.checkMod`, 0);\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.total`, abl.value - Math.abs(abl.drain));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.mod`, Math.floor((updateData[`data.abilities.${a}.total`] - 10) / 2));\r\n    }\r\n\r\n    // Reset maximum hit points\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.hp.max", getProperty(data, "data.attributes.hp.base") || 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.wounds.max", getProperty(data, "data.attributes.wounds.base") || 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.vigor.max", getProperty(data, "data.attributes.vigor.base") || 0);\r\n\r\n    // Reset AC\r\n    for (let type of Object.keys(data1.attributes.ac)) {\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.attributes.ac.${type}.total`, 10);\r\n    }\r\n\r\n    // Reset attack and damage bonuses\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.attack.general", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.attack.melee", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.attack.ranged", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.damage.general", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.damage.weapon", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.damage.spell", 0);\r\n\r\n    // Reset saving throws\r\n    for (let a of Object.keys(data1.attributes.savingThrows)) {\r\n      {\r\n        const k = `data.attributes.savingThrows.${a}.total`;\r\n        if (useFractionalBaseBonuses) {\r\n          let highStart = false;\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, k,\r\n            Math.floor(classes.reduce((cur, obj) => {\r\n              const saveScale = getProperty(obj, `data.savingThrows.${a}.value`) || "";\r\n              if (saveScale === "high"){\r\n                const acc = highStart ? 0 : 2;\r\n                highStart = true;\r\n                return cur + obj.data.level / 2 + acc;\r\n              }\r\n              if (saveScale === "low") return cur + obj.data.level / 3;\r\n              return cur;\r\n            }, 0))\r\n          );\r\n\r\n          const v = updateData[k];\r\n          if (v !== 0) {\r\n            sourceInfo[k] = sourceInfo[k] || { positive: [], negative: [] };\r\n            sourceInfo[k].positive.push({ name: game.i18n.localize("PF1.Base"), value: updateData[k] });\r\n          }\r\n        }\r\n        else {\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, k,\r\n            classes.reduce((cur, obj) => {\r\n              const classType = getProperty(obj.data, "classType") || "base";\r\n              let formula = CONFIG.PF1.classSavingThrowFormulas[classType][obj.data.savingThrows[a].value];\r\n              if (formula == null) formula = "0";\r\n              const v = Math.floor(new Roll(formula, {level: obj.data.level}).roll().total);\r\n\r\n              if (v !== 0) {\r\n                sourceInfo[k] = sourceInfo[k] || { positive: [], negative: [] };\r\n                sourceInfo[k].positive.push({ name: getProperty(obj, "name"), value: v });\r\n              }\r\n\r\n              return cur + v;\r\n            }, 0)\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Reset ACP and Max Dex bonus\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.acp.gear", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.maxDexBonus", null);\r\n    items.filter(obj => { return obj.type === "equipment" && obj.data.equipped; }).forEach(obj => {\r\n      let itemACP = Math.abs(obj.data.armor.acp);\r\n      if (obj.data.masterwork === true && (["armor", "shield"].includes(obj.data.equipmentType))) {\r\n        itemACP = Math.max(0, itemACP - 1);\r\n      }\r\n      \r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.acp.gear", updateData["data.attributes.acp.gear"] + itemACP);\r\n      if(obj.data.armor.dex != null) {\r\n        if (updateData["data.attributes.maxDexBonus"] == null) Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.maxDexBonus", Math.abs(obj.data.armor.dex));\r\n        else {\r\n          Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.maxDexBonus", Math.min(updateData["data.attributes.maxDexBonus"], Math.abs(obj.data.armor.dex)));\r\n        }\r\n      }\r\n    });\r\n\r\n    // Reset specific skill bonuses\r\n    for (let sklKey of this._getChangeFlat("skills", "", this.data.data)) {\r\n      if (hasProperty(data, sklKey)) Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, sklKey, 0);\r\n    }\r\n\r\n    // Reset movement speed\r\n    for (let speedKey of Object.keys(this.data.data.attributes.speed)) {\r\n      const base = getProperty(data, `data.attributes.speed.${speedKey}.base`);\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.attributes.speed.${speedKey}.total`, base || 0);\r\n    }\r\n\r\n    // Reset BAB, CMB and CMD\r\n    {\r\n      const k = "data.attributes.bab.total";\r\n      if (useFractionalBaseBonuses) {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, k, Math.floor(classes.reduce((cur, obj) => {\r\n          const babScale = getProperty(obj, "data.bab") || "";\r\n          if (babScale === "high") return cur + obj.data.level;\r\n          if (babScale === "med") return cur + obj.data.level * 0.75;\r\n          if (babScale === "low") return cur + obj.data.level * 0.5;\r\n          return cur;\r\n        }, 0)));\r\n\r\n        const v = updateData[k];\r\n        if (v !== 0) {\r\n          sourceInfo[k] = sourceInfo[k] || { positive: [], negative: [] };\r\n          sourceInfo[k].positive.push({ name: game.i18n.localize("PF1.Base"), value: v });\r\n        }\r\n      }\r\n      else {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, k, classes.reduce((cur, obj) => {\r\n          const formula = CONFIG.PF1.classBABFormulas[obj.data.bab] != null ? CONFIG.PF1.classBABFormulas[obj.data.bab] : "0";\r\n          const v = new Roll(formula, {level: obj.data.level}).roll().total;\r\n\r\n          if (v !== 0) {\r\n            sourceInfo[k] = sourceInfo[k] || { positive: [], negative: [] };\r\n            sourceInfo[k].positive.push({ name: getProperty(obj, "name"), value: v });\r\n          }\r\n\r\n          return cur + v;\r\n        }, 0));\r\n      }\r\n    }\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.cmb.total", 0);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.cmd.total", 10);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.cmd.flatFootedTotal", 10);\r\n\r\n    // Reset initiative\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, "data.attributes.init.total", getProperty(data, "data.attributes.init.value") || 0);\r\n\r\n    // Reset class skills\r\n    for (let [k, s] of Object.entries(getProperty(data, "data.skills"))) {\r\n      if (!s) continue;\r\n      const isClassSkill = classes.reduce((cur, o) => {\r\n        if ((getProperty(o, "data.classSkills") || {})[k] === true) return true;\r\n        return cur;\r\n      }, false);\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.skills.${k}.cs`, isClassSkill);\r\n      for (let k2 of Object.keys(getProperty(s, "subSkills") || {})) {\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.skills.${k}.subSkills.${k2}.cs`, isClassSkill);\r\n      }\r\n    }\r\n  }\r\n\r\n  _addDynamicData({updateData={}, data={}, changes={}, flags={}, forceModUpdate=false}={}) {\r\n    const prevMods = {};\r\n    const modDiffs = {};\r\n\r\n    // Reset ability modifiers\r\n    const abilities = Object.keys(getProperty(data, "data.abilities") || {});\r\n    for (let a of abilities) {\r\n      prevMods[a] = forceModUpdate ? 0 : updateData[`data.abilities.${a}.mod`];\r\n      if (a === "str" && flags.noStr ||\r\n        a === "dex" && flags.noDex ||\r\n        a === "int" && flags.oneInt ||\r\n        a === "wis" && flags.oneWis ||\r\n        a === "cha" && flags.oneCha) {\r\n        modDiffs[a] = forceModUpdate ? -5 : 0;\r\n        if (changes[`data.abilities.${a}.total`]) delete changes[`data.abilities.${a}.total`]; // Remove used mods to prevent doubling\r\n        continue;\r\n      }\r\n      const ablPenalty = Math.abs(updateData[`data.abilities.${a}.penalty`] || 0) + (updateData[`data.abilities.${a}.userPenalty`] || 0);\r\n\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.total`, updateData[`data.abilities.${a}.total`] + (changes[`data.abilities.${a}.total`] || 0));\r\n      if (changes[`data.abilities.${a}.total`]) delete changes[`data.abilities.${a}.total`]; // Remove used mods to prevent doubling\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.mod`, Math.floor((updateData[`data.abilities.${a}.total`] - 10) / 2));\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.abilities.${a}.mod`, Math.max(-5, updateData[`data.abilities.${a}.mod`] - Math.floor(updateData[`data.abilities.${a}.damage`] / 2) - Math.floor(ablPenalty / 2)));\r\n      modDiffs[a] = updateData[`data.abilities.${a}.mod`] - prevMods[a];\r\n    }\r\n\r\n    // Apply changes\r\n    for (let [changeTarget, value] of Object.entries(changes)) {\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, changeTarget, (updateData[changeTarget] || 0) + value);\r\n    }\r\n  }\r\n\r\n  _updateSkills(updateData, data) {\r\n    const data1 = data.data;\r\n    let energyDrainPenalty = Math.abs(data1.attributes.energyDrain);\r\n    for (let [sklKey, skl] of Object.entries(data1.skills)) {\r\n      if (skl == null) continue;\r\n\r\n      let acpPenalty = (skl.acp ? data1.attributes.acp.total : 0);\r\n      let ablMod = data1.abilities[skl.ability].mod;\r\n      let specificSkillBonus = skl.changeBonus || 0;\r\n\r\n      // Parse main skills\r\n      let sklValue = skl.rank + (skl.cs && skl.rank > 0 ? 3 : 0) + ablMod + specificSkillBonus - acpPenalty - energyDrainPenalty;\r\n      Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.skills.${sklKey}.mod`, sklValue);\r\n      // Parse sub-skills\r\n      for (let [subSklKey, subSkl] of Object.entries(skl.subSkills || {})) {\r\n        if (subSkl == null) continue;\r\n        if (getProperty(data1, `skills.${sklKey}.subSkills.${subSklKey}`) == null) continue;\r\n\r\n        acpPenalty = (subSkl.acp ? data1.attributes.acp.total : 0);\r\n        ablMod = data1.abilities[subSkl.ability].mod;\r\n        specificSkillBonus = subSkl.changeBonus || 0;\r\n        sklValue = subSkl.rank + (subSkl.cs && subSkl.rank > 0 ? 3 : 0) + ablMod + specificSkillBonus - acpPenalty - energyDrainPenalty;\r\n        Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(data, updateData, `data.skills.${sklKey}.subSkills.${subSklKey}.mod`, sklValue);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Augment the basic actor data with additional dynamic data.\r\n   */\r\n  prepareData() {\r\n    super.prepareData();\r\n\r\n    const actorData = this.data;\r\n    const data = actorData.data;\r\n\r\n    // Prepare Character data\r\n    if ( actorData.type === "character" ) this._prepareCharacterData(actorData);\r\n    else if ( actorData.type === "npc" ) this._prepareNPCData(data);\r\n\r\n    // Create arbitrary skill slots\r\n    for (let skillId of CONFIG.PF1.arbitrarySkills) {\r\n      if (data.skills[skillId] == null) continue;\r\n      let skill = data.skills[skillId];\r\n      skill.subSkills = skill.subSkills || {};\r\n      for (let subSkillId of Object.keys(skill.subSkills)) {\r\n        if (skill.subSkills[subSkillId] == null) delete skill.subSkills[subSkillId];\r\n      }\r\n    }\r\n\r\n    // Delete removed skills\r\n    for (let skillId of Object.keys(data.skills)) {\r\n      let skl = data.skills[skillId];\r\n      if (skl == null) {\r\n        delete data.skills[skillId];\r\n      }\r\n    }\r\n\r\n    // Set class tags\r\n    data.classes = {};\r\n    actorData.items.filter(obj => { return obj.type === "class"; }).forEach(cls => {\r\n      let tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(cls.name);\r\n      let count = 1;\r\n      while (actorData.items.filter(obj => { return obj.type === "class" && obj.data.tag === tag && obj !== cls; }).length > 0) {\r\n        count++;\r\n        tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(cls.name) + count.toString();\r\n      }\r\n      cls.data.tag = tag;\r\n\r\n      let healthConfig = game.settings.get("pf1", "healthConfig");\r\n      healthConfig  = cls.data.classType === "racial" ? healthConfig.hitdice.Racial : this.isPC ? healthConfig.hitdice.PC : healthConfig.hitdice.NPC;\r\n      const classType = cls.data.classType || "base";\r\n      data.classes[tag] = {\r\n        level: cls.data.level,\r\n        name: cls.name,\r\n        hd: cls.data.hd,\r\n        bab: cls.data.bab,\r\n        hp: healthConfig.auto,\r\n        savingThrows: {\r\n          fort: 0,\r\n          ref: 0,\r\n          will: 0,\r\n        },\r\n        fc: {\r\n          hp: classType === "base" ? cls.data.fc.hp.value : 0,\r\n          skill: classType === "base" ? cls.data.fc.skill.value : 0,\r\n          alt: classType === "base" ? cls.data.fc.alt.value : 0,\r\n        },\r\n      };\r\n\r\n      for (let k of Object.keys(data.classes[tag].savingThrows)) {\r\n        let formula = CONFIG.PF1.classSavingThrowFormulas[classType][cls.data.savingThrows[k].value];\r\n        if (formula == null) formula =  "0";\r\n        data.classes[tag].savingThrows[k] = new Roll(formula, {level: cls.data.level}).roll().total;\r\n      }\r\n    });\r\n\r\n\r\n    // Prepare modifier containers\r\n    data.attributes.mods = data.attributes.mods || {};\r\n    data.attributes.mods.skills = data.attributes.mods.skills || {};\r\n\r\n    // Set spell resistance\r\n    if (typeof data.attributes.sr.formula === "string" && data.attributes.sr.formula.length) {\r\n      try {\r\n        let roll = new Roll(data.attributes.sr.formula, data).roll();\r\n        data.attributes.sr.total = roll.total;\r\n      }\r\n      catch (e) {\r\n        console.error(`Could not calculate SR for actor ${this.name} with the following formula: \'${data.attributes.sr.formula}\'`);\r\n        data.attributes.sr.total = 0;\r\n      }\r\n    }\r\n    else {\r\n      data.attributes.sr.total = 0;\r\n    }\r\n\r\n    // Set spellbook info\r\n    for (let spellbook of Object.values(data.attributes.spells.spellbooks)) {\r\n      // Set CL\r\n      spellbook.cl.total = 0;\r\n      if (spellbook.cl.formula.length > 0) {\r\n        let roll = new Roll(spellbook.cl.formula, data).roll();\r\n        spellbook.cl.total += roll.total;\r\n      }\r\n      if (actorData.type === "npc") spellbook.cl.total += spellbook.cl.base;\r\n      if (spellbook.class === "_hd") {\r\n        spellbook.cl.total += data.attributes.hd.total;\r\n      }\r\n      else if (spellbook.class !== "" && data.classes[spellbook.class] != null) {\r\n        spellbook.cl.total += data.classes[spellbook.class].level;\r\n      }\r\n      // Add spell slots\r\n      spellbook.spells = spellbook.spells || {};\r\n      for (let a = 0; a < 10; a++) {\r\n        spellbook.spells[`spell${a}`] = spellbook.spells[`spell${a}`] || { value: 0, max: 0, base: null };\r\n      }\r\n    }\r\n\r\n    // Set labels\r\n    this.labels = {};\r\n    this.labels.race = this.race == null ? game.i18n.localize("PF1.Race") : game.i18n.localize("PF1.RaceTitle").format(this.race.name);\r\n    this.labels.alignment = CONFIG.PF1.alignments[this.data.data.details.alignment];\r\n\r\n    // Setup links\r\n    this.prepareItemLinks();\r\n  }\r\n\r\n  prepareItemLinks() {\r\n    if (!this.items) return;\r\n\r\n    for (let a of this.items) {\r\n      if (a.data.data.links == null) continue;\r\n\r\n      for (let l of Object.keys(a.data.data.links)) {\r\n        if (_misc_links_js__WEBPACK_IMPORTED_MODULE_5__["LinkFunctions"][l] != null) {\r\n          _misc_links_js__WEBPACK_IMPORTED_MODULE_5__["LinkFunctions"][l].call(this, a, a.data.data.links[l]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _setSourceDetails(actorData, extraData, flags) {\r\n    if (flags == null) flags = {};\r\n    let sourceDetails = {};\r\n    // Get empty source arrays\r\n    for (let obj of Object.values(CONFIG.PF1.buffTargets)) {\r\n      for (let b of Object.keys(obj)) {\r\n        if (!b.startsWith("_")) {\r\n          let buffTargets = this._getChangeFlat(b, null, actorData.data);\r\n          if (!(buffTargets instanceof Array)) buffTargets = [buffTargets];\r\n          for (let bt of buffTargets) {\r\n            if (!sourceDetails[bt]) sourceDetails[bt] = [];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add additional source arrays not covered by changes\r\n    sourceDetails["data.attributes.bab.total"] = [];\r\n\r\n\r\n    // Add base values to certain bonuses\r\n    sourceDetails["data.attributes.ac.normal.total"].push({ name: game.i18n.localize("PF1.Base"), value: 10 });\r\n    sourceDetails["data.attributes.ac.touch.total"].push({ name: game.i18n.localize("PF1.Base"), value: 10 });\r\n    sourceDetails["data.attributes.ac.flatFooted.total"].push({ name: game.i18n.localize("PF1.Base"), value: 10 });\r\n    sourceDetails["data.attributes.cmd.total"].push({ name: game.i18n.localize("PF1.Base"), value: 10 });\r\n    sourceDetails["data.attributes.cmd.flatFootedTotal"].push({ name: game.i18n.localize("PF1.Base"), value: 10 });\r\n    for (let [a, abl] of Object.entries(actorData.data.abilities)) {\r\n      sourceDetails[`data.abilities.${a}.total`].push({ name: game.i18n.localize("PF1.Base"), value: abl.value });\r\n      // Add ability penalty, damage and drain\r\n      if (abl.damage != null && abl.damage !== 0) {\r\n        sourceDetails[`data.abilities.${a}.total`].push({ name: game.i18n.localize("PF1.AbilityDamage"), value: `-${Math.floor(Math.abs(abl.damage) / 2)} (Mod only)` });\r\n      }\r\n      if (abl.drain != null && abl.drain !== 0) {\r\n        sourceDetails[`data.abilities.${a}.total`].push({ name: game.i18n.localize("PF1.AbilityDrain"), value: -Math.abs(abl.drain) });\r\n      }\r\n    }\r\n\r\n    // Add AC and CMD details\r\n    {\r\n      const dex = actorData.data.abilities.dex.mod;\r\n      const maxDex = actorData.data.attributes.maxDexBonus;\r\n      const ac = {\r\n        normal: maxDex != null ? Math.min(maxDex, dex) : dex,\r\n        touch: maxDex != null ? Math.min(maxDex, dex) : dex,\r\n        ff: Math.min(0, dex),\r\n      };\r\n      const cmd = {\r\n        normal: maxDex != null ? Math.min(maxDex, dex) : dex,\r\n        ff: Math.min(0, dex),\r\n      };\r\n      if (ac.normal  !== 0) sourceDetails["data.attributes.ac.normal.total"].push({ name: game.i18n.localize("PF1.AbilityDex"), value: ac.normal });\r\n      if (ac.touch   !== 0) sourceDetails["data.attributes.ac.touch.total"].push({ name: game.i18n.localize("PF1.AbilityDex"), value: ac.touch });\r\n      if (ac.ff      !== 0) sourceDetails["data.attributes.ac.flatFooted.total"].push({ name: game.i18n.localize("PF1.AbilityDex"), value: ac.ff });\r\n      if (cmd.normal !== 0) sourceDetails["data.attributes.cmd.total"].push({ name: game.i18n.localize("PF1.AbilityDex"), value: cmd.normal });\r\n      if (cmd.ff     !== 0) sourceDetails["data.attributes.cmd.flatFootedTotal"].push({ name: game.i18n.localize("PF1.AbilityDex"), value: cmd.ff });\r\n    }\r\n\r\n    // Add extra data\r\n    for (let [changeTarget, changeGrp] of Object.entries(extraData)) {\r\n      for (let grp of Object.values(changeGrp)) {\r\n        if (grp.length > 0) {\r\n          sourceDetails[changeTarget] = sourceDetails[changeTarget] || [];\r\n          for (let src of grp) {\r\n            let srcInfo = this.constructor._translateSourceInfo(src.type, src.subtype, src.name);\r\n            // if (this.name === "Testy") console.log(changeTarget, src, srcInfo)\r\n            sourceDetails[changeTarget].push({\r\n              name: srcInfo,\r\n              value: src.value\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // if (this.name === "Testy") console.log(sourceDetails)\r\n    this.sourceDetails = sourceDetails;\r\n  }\r\n\r\n  async refresh() {\r\n    if (this.hasPerm(game.user, "OWNER")) {\r\n      return this.update({});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare Character type specific data\r\n   */\r\n  _prepareCharacterData(actorData) {\r\n    const data = actorData.data;\r\n\r\n    // Experience bar\r\n    let prior = this.getLevelExp(data.details.level.value - 1 || 0),\r\n      req = data.details.xp.max - prior;\r\n    data.details.xp.pct = Math.min(Math.round((data.details.xp.value - prior) * 100 / (req || 1)), 99.5);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare NPC type specific data\r\n   */\r\n  _prepareNPCData(data) {\r\n    // Kill Experience\r\n    try {\r\n      const crTotal = getProperty(this.data, "data.details.cr.total") || 1;\r\n      data.details.xp.value = this.getCRExp(crTotal);\r\n    }\r\n    catch (e) {\r\n      data.details.xp.value = this.getCRExp(1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return reduced movement speed.\r\n   * @param {Number} value - The non-reduced movement speed.\r\n   * @returns {Number} The reduced movement speed.\r\n   */\r\n  static getReducedMovementSpeed(value) {\r\n    const incr = game.settings.get("pf1", "units") === "metric" ? 1.5 : 5\r\n    \r\n    if (value <= 0) return value;\r\n    if (value < 2*incr) return incr;\r\n    value = Math.floor(value / incr) * incr;\r\n\r\n    let result = 0,\r\n      counter = 2;\r\n    for (let a = incr; a <= value; a += counter * incr) {\r\n      result += incr;\r\n      if (counter === 1) counter = 2;\r\n      else counter = 1;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Return increased amount of spell slots by ability score modifier.\r\n   * @param {Number} mod - The associated ability modifier.\r\n   * @param {Number} level - Spell level.\r\n   * @returns {Number} Amount of spell levels to increase.\r\n   */\r\n  static getSpellSlotIncrease(mod, level) {\r\n    if (level === 0) return 0;\r\n    if (mod <= 0) return 0;\r\n    return Math.max(0, Math.ceil(((mod + 1) - level) / 4));\r\n  }\r\n\r\n  /**\r\n   * Return the amount of experience required to gain a certain character level.\r\n   * @param level {Number}  The desired level\r\n   * @return {Number}       The XP required\r\n   */\r\n  getLevelExp(level) {\r\n    const expConfig = game.settings.get("pf1", "experienceConfig");\r\n    const expTrack = expConfig.track;\r\n    // Preset experience tracks\r\n    if (["fast", "medium", "slow"].includes(expTrack)) {\r\n      const levels = CONFIG.PF1.CHARACTER_EXP_LEVELS[expTrack];\r\n      return levels[Math.min(level, levels.length - 1)];\r\n    }\r\n    // Custom formula experience track\r\n    let totalXP = 0;\r\n    if (expConfig.custom.formula.length > 0) {\r\n      for (let a = 0; a < level; a++) {\r\n        const rollData = this.getRollData();\r\n        rollData.level = a+1;\r\n        const roll = new Roll(expConfig.custom.formula, rollData).roll();\r\n        totalXP += roll.total;\r\n      }\r\n    }\r\n    return Math.max(1, totalXP);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Return the amount of experience granted by killing a creature of a certain CR.\r\n   * @param cr {Number}     The creature\'s challenge rating\r\n   * @return {Number}       The amount of experience granted per kill\r\n   */\r\n  getCRExp(cr) {\r\n    if (cr < 1.0) return Math.max(400 * cr, 10);\r\n    return CONFIG.PF1.CR_EXP_LEVELS[cr];\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Socket Listeners and Handlers\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Extend the default update method to enhance data before submission.\r\n   * See the parent Entity.update method for full details.\r\n   *\r\n   * @param {Object} data     The data with which to update the Actor\r\n   * @param {Object} options  Additional options which customize the update workflow\r\n   * @return {Promise}        A Promise which resolves to the updated Entity\r\n   */\r\n  async update(data, options={}) {\r\n    // Fix skill ranks after TinyMCE edit\r\n    let expandedData = expandObject(data);\r\n    if (expandedData.data != null && expandedData.data.skills != null) {\r\n      for (let [s, skl] of Object.entries(expandedData.data.skills)) {\r\n        let curSkl = this.data.data.skills[s];\r\n        if (skl == null) continue;\r\n        if (typeof skl.rank !== "number") skl.rank = 0;\r\n        if (skl.subSkills != null) {\r\n          for (let skl2 of Object.values(skl.subSkills)) {\r\n            if (skl2 == null) continue;\r\n            if (typeof skl2.rank !== "number") skl2.rank = 0;\r\n          }\r\n        }\r\n\r\n        // Rename custom skills\r\n        if (curSkl != null && curSkl.custom && skl.name != null) {\r\n          let tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(skl.name || "skill");\r\n          let count = 1;\r\n          const skillData = getProperty(this.data, `data.skills.${tag}`) || {};\r\n          while (this.data.data.skills[tag] != null && this.data.data.skills[tag] != curSkl) {\r\n            count++;\r\n            tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(skillData.name || "skill") + count.toString();\r\n          }\r\n\r\n          if (s !== tag) {\r\n            expandedData.data.skills[tag] = mergeObject(curSkl, skl);\r\n            expandedData.data.skills[s] = null;\r\n          }\r\n        }\r\n      }\r\n      data = flattenObject(expandedData);\r\n    }\r\n\r\n    // Make certain variables absolute\r\n    const _absoluteKeys = Object.keys(this.data.data.abilities).reduce((arr, abl) => {\r\n      arr.push(`data.abilities.${abl}.userPenalty`, `data.abilities.${abl}.damage`, `data.abilities.${abl}.drain`);\r\n      return arr;\r\n    }, []).concat("data.attributes.energyDrain").filter(k => { return data[k] != null; });\r\n    for (const k of _absoluteKeys) {\r\n      data[k] = Math.abs(data[k]);\r\n    }\r\n\r\n    // Apply changes in Actor size to Token width/height\r\n    if ( data["data.traits.size"] && this.data.data.traits.size !== data["data.traits.size"] ) {\r\n      let size = CONFIG.PF1.tokenSizes[data["data.traits.size"]];\r\n      let tokens = this.getActiveTokens();\r\n      if (this.isToken) tokens.push(this.token);\r\n      tokens.forEach(o => { o.update({ width: size.w, height: size.h, scale: size.scale }); });\r\n      if (!this.isToken) {\r\n        data["token.width"] = size.w;\r\n        data["token.height"] = size.h;\r\n        data["token.scale"] = size.scale;\r\n      }\r\n    }\r\n\r\n    // Send resource updates to item\r\n    let updatedResources = [];\r\n    for (let key of Object.keys(data)) {\r\n      if (key.match(/^data\\.resources\\.([a-zA-Z0-9]+)/)) {\r\n        const resourceTag = RegExp.$1;\r\n        if (updatedResources.includes(resourceTag)) continue;\r\n        updatedResources.push(resourceTag);\r\n\r\n        const resource = this.data.data.resources[resourceTag];\r\n        if (resource != null) {\r\n          const itemId = resource._id;\r\n          const item = this.getOwnedItem(itemId);\r\n          if (item == null) continue;\r\n\r\n          const itemUpdateData = {};\r\n          let key = `data.resources.${resourceTag}.value`;\r\n          if (data[key] != null && data[key] !== item.data.data.uses.value) {\r\n            itemUpdateData["data.uses.value"] = data[key];\r\n          }\r\n          key = `data.resources.${resourceTag}.max`;\r\n          if (data[key] != null && data[key] !== item.data.data.uses.max) {\r\n            itemUpdateData["data.uses.max"] = data[key];\r\n          }\r\n          if (Object.keys(itemUpdateData).length > 0) item.update(itemUpdateData);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clean up old item resources\r\n    for (let [tag, res] of Object.entries(getProperty(this.data, "data.resources") || {})) {\r\n      if (!res) continue;\r\n      if (!res._id) continue;\r\n      const itemId = res._id;\r\n      const item = this.getOwnedItem(itemId);\r\n      // Remove resource from token bars\r\n      if (item == null) {\r\n        const tokens = this.getActiveTokens();\r\n        tokens.forEach(token => {\r\n          ["bar1", "bar2"].forEach(b => {\r\n            const barAttr = token.getBarAttribute(b);\r\n            if (barAttr == null) {\r\n              return;\r\n            }\r\n            if (barAttr.attribute === `resources.${tag}`) {\r\n              const tokenUpdateData = {};\r\n              tokenUpdateData[`${b}.attribute`] = null;\r\n              token.update(token.scene._id, tokenUpdateData);\r\n            }\r\n          });\r\n        });\r\n      }\r\n      // Remove resource\r\n      if (item == null || Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(item.name) !== tag) {\r\n        data[`data.resources.-=${tag}`] = null;\r\n      }\r\n    }\r\n\r\n    this._updateExp(data);\r\n\r\n    // Update changes\r\n    let diff = data;\r\n    if (options.updateChanges !== false) {\r\n      const updateObj = await this._updateChanges({ data: data });\r\n      if (updateObj.diff.items) delete updateObj.diff.items;\r\n      diff = mergeObject(diff, updateObj.diff);\r\n    }\r\n    // Diff token data\r\n    if (data.token != null) {\r\n      diff.token = diffObject(this.data.token, data.token);\r\n    }\r\n\r\n    if (Object.keys(diff).length) {\r\n      return super.update(diff, options);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _onUpdate(data, options, userId, context) {\r\n    if (hasProperty(data, "data.attributes.vision.lowLight") || hasProperty(data, "data.attributes.vision.darkvision")) {\r\n      canvas.sight.initializeTokens();\r\n    }\r\n\r\n    for (let i of this.items.values()) {\r\n      let itemUpdateData = {};\r\n\r\n      i._updateMaxUses(itemUpdateData, { actorData: data });\r\n\r\n      const itemDiff = diffObject(flattenObject(i.data), itemUpdateData);\r\n      if (Object.keys(itemDiff).length > 0) i.update(itemDiff);\r\n    }\r\n\r\n    return super._onUpdate(data, options, userId, context);\r\n  }\r\n\r\n  /**\r\n   * Makes sure experience values are correct in update data.\r\n   * @param {Object} data - The update data, as per ActorPF.update()\r\n   * @returns {Boolean} Whether to force an update or not.\r\n   */\r\n  _updateExp(data) {\r\n    const classes = this.items.filter(o => o.type === "class");\r\n    const level = classes.reduce((cur, o) => {\r\n      return cur + o.data.data.level;\r\n    }, 0);\r\n    if (getProperty(this.data, "data.details.level.value") !== level) {\r\n      data["data.details.level.value"] = level;\r\n    }\r\n\r\n    // The following is not for NPCs\r\n    if (this.data.type !== "character") return;\r\n\r\n    // Translate update exp value to number\r\n    let newExp = data["data.details.xp.value"],\r\n      resetExp = false;\r\n    if (typeof newExp === "string") {\r\n      if (newExp.match(/^\\+([0-9]+)$/)) {\r\n        newExp = this.data.data.details.xp.value + parseInt(RegExp.$1);\r\n      }\r\n      else if (newExp.match(/^-([0-9]+)$/)) {\r\n        newExp = this.data.data.details.xp.value - parseInt(RegExp.$1);\r\n      }\r\n      else if (newExp === "") {\r\n        resetExp = true;\r\n      }\r\n      else {\r\n        newExp = parseInt(newExp);\r\n        if (Number.isNaN(newExp)) newExp = this.data.data.details.xp.value;\r\n      }\r\n\r\n      if (typeof newExp === "number" && newExp !== getProperty(this.data, "data.details.xp.value")) {\r\n        data["data.details.xp.value"] = newExp;\r\n      }\r\n    }\r\n    const maxExp = this.getLevelExp(level);\r\n    if (maxExp !== getProperty(this.data, "data.details.xp.max")) {\r\n      data["data.details.xp.max"] = maxExp;\r\n    }\r\n\r\n    const minExp = level > 0 ? this.getLevelExp(level - 1) : 0;\r\n    if (resetExp) data["data.details.xp.value"] = minExp;\r\n  }\r\n\r\n  async _onCreate(data, options, userId, context) {\r\n    if (userId === game.user._id) {\r\n      await this._updateChanges();\r\n    }\r\n\r\n    super._onCreate(data, options, userId, context);\r\n  }\r\n\r\n  updateItemResources(item) {\r\n    if (!(item instanceof Item)) return;\r\n    if (!this.hasPerm(game.user, "OWNER")) return;\r\n\r\n    if (item.data.data.uses != null && item.data.data.activation != null && item.data.data.activation.type !== "") {\r\n      const itemTag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["createTag"])(item.data.name);\r\n      let curUses = item.data.data.uses;\r\n\r\n      if (this.data.data.resources == null) this.data.data.resources = {};\r\n      if (this.data.data.resources[itemTag] == null) this.data.data.resources[itemTag] = { value: 0, max: 1, _id: "" };\r\n\r\n      const updateData = {};\r\n      if (this.data.data.resources[itemTag].value !== curUses.value) {\r\n        updateData[`data.resources.${itemTag}.value`] = curUses.value;\r\n      }\r\n      if (this.data.data.resources[itemTag].max !== curUses.max) {\r\n        updateData[`data.resources.${itemTag}.max`] = curUses.max;\r\n      }\r\n      if (this.data.data.resources[itemTag]._id !== item._id ) {\r\n        updateData[`data.resources.${itemTag}._id`] = item._id;\r\n      }\r\n      if (Object.keys(updateData).length > 0) this.update(updateData);\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * See the base Actor class for API documentation of this method\r\n   */\r\n  async createOwnedItem(itemData, options) {\r\n    let t = itemData.type;\r\n    let initial = {};\r\n    // Assume NPCs are always proficient with weapons and always have spells prepared\r\n    if ( !this.isPC ) {\r\n      if ( t === "weapon" ) initial["data.proficient"] = true;\r\n      if ( ["weapon", "equipment"].includes(t) ) initial["data.equipped"] = true;\r\n    }\r\n    if ( t === "spell" ) {\r\n      if (this.sheet != null && this.sheet._spellbookTab != null) {\r\n        initial["data.spellbook"] = this.sheet._spellbookTab;\r\n      }\r\n    }\r\n\r\n    mergeObject(itemData, initial);\r\n    return super.createOwnedItem(itemData, options);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Rolls                                       */\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Cast a Spell, consuming a spell slot of a certain level\r\n   * @param {ItemPF} item   The spell being cast by the actor\r\n   * @param {MouseEvent} ev The click event\r\n   */\r\n  async useSpell(item, ev, {skipDialog=false}={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n    if ( item.data.type !== "spell" ) throw new Error("Wrong Item type");\r\n\r\n    if (getProperty(item.data, "data.preparation.mode") !== "atwill" && item.getSpellUses() <= 0) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoSpellsLeft"));\r\n\r\n    // Invoke the Item roll\r\n    if (item.hasAction) return item.useAttack({ev: ev, skipDialog: skipDialog});\r\n    item.addSpellUses(-1);\r\n    return item.roll();\r\n  }\r\n\r\n  async createAttackFromWeapon(item) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    if (item.data.type !== "weapon") throw new Error("Wrong Item type");\r\n\r\n    // Get attack template\r\n    let attackData = { data: {} };\r\n    for (const template of game.data.system.template.Item.attack.templates) {\r\n      mergeObject(attackData.data, game.data.system.template.Item.templates[template]);\r\n    }\r\n    mergeObject(attackData.data, duplicate(game.data.system.template.Item.attack));\r\n    attackData = flattenObject(attackData);\r\n\r\n    // Add ability modifiers\r\n    const isMelee = getProperty(item.data, "data.weaponSubtype") !== "ranged" && !getProperty(item.data, "data.properties.thr");\r\n    if (isMelee) attackData["data.ability.attack"] = "str";\r\n    else attackData["data.ability.attack"] = "dex";\r\n    if (isMelee || item.data.data.properties["thr"] === true) {\r\n      attackData["data.ability.damage"] = "str";\r\n      if (item.data.data.weaponSubtype === "2h" && isMelee) attackData["data.ability.damageMult"] = 1.5;\r\n    }\r\n\r\n    // Add misc things\r\n    attackData["type"] = "attack";\r\n    attackData["name"] = item.data.name;\r\n    attackData["data.masterwork"] = item.data.data.masterwork;\r\n    attackData["data.attackType"] = "weapon";\r\n    attackData["data.enh"] = item.data.data.enh;\r\n    attackData["data.ability.critRange"] = item.data.data.weaponData.critRange || 20;\r\n    attackData["data.ability.critMult"] = item.data.data.weaponData.critMult || 2;\r\n    attackData["data.actionType"] = isMelee ? "mwak" : "rwak";\r\n    attackData["data.activation.type"] = "attack";\r\n    attackData["data.duration.units"] = "inst";\r\n    attackData["img"] = item.data.img;\r\n\r\n    // Add additional attacks\r\n    let extraAttacks = [];\r\n    for (let a = 5; a < this.data.data.attributes.bab.total; a += 5) {\r\n      extraAttacks = extraAttacks.concat([[`-${a}`, `${game.i18n.localize("PF1.Attack")} ${Math.floor((a+5) / 5)}`]]);\r\n    }\r\n    if (extraAttacks.length > 0) attackData["data.attackParts"] = extraAttacks;\r\n\r\n    // Add damage formula\r\n    if (item.data.data.weaponData.damageRoll) {\r\n      const die = item.data.data.weaponData.damageRoll || "1d4";\r\n      let part = die;\r\n      let dieCount = 1,\r\n        dieSides = 4;\r\n      if (die.match(/^([0-9]+)d([0-9]+)$/)) {\r\n        dieCount = parseInt(RegExp.$1);\r\n        dieSides = parseInt(RegExp.$2);\r\n        // const weaponSize = Object.keys(CONFIG.PF1.sizeChart).indexOf(item.data.data.weaponData.size) - 4;\r\n        part = `sizeRoll(${dieCount}, ${dieSides}, @size, @critMult)`;\r\n      }\r\n      const bonusFormula = getProperty(item.data, "data.weaponData.damageFormula");\r\n      if (bonusFormula != null && bonusFormula.length) part = `${part} + ${bonusFormula}`;\r\n      attackData["data.damage.parts"] = [[part, item.data.data.weaponData.damageType || ""]];\r\n    }\r\n\r\n    // Add attack bonus formula\r\n    {\r\n      const bonusFormula = getProperty(item.data, "data.weaponData.attackFormula");\r\n      if (bonusFormula != null && bonusFormula.length) attackData["data.attackBonus"] = bonusFormula;\r\n    }\r\n\r\n    // Add range\r\n    if (!isMelee && getProperty(item.data, "data.weaponData.range") != null) {\r\n      attackData["data.range.units"] = "ft";\r\n      attackData["data.range.value"] = getProperty(item.data, "data.weaponData.range").toString();\r\n    }\r\n\r\n    // Create attack\r\n    if (hasProperty(attackData, "data.templates")) delete attackData["data.templates"];\r\n    const itemData = await this.createOwnedItem(expandObject(attackData));\r\n\r\n    // Create link\r\n    const link = {\r\n      id: itemData._id,\r\n      dataType: "data",\r\n    };\r\n    const links = [...(getProperty(item.data, "data.links.children") || []), link];\r\n    await item.update({"data.links.children": links});\r\n\r\n    ui.notifications.info(game.i18n.localize("PF1.NotificationCreatedAttack").format(item.data.name));\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Roll a Skill Check\r\n   * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus\r\n   * @param {string} skillId      The skill id (e.g. "ins")\r\n   * @param {Object} options      Options which configure how the skill check is rolled\r\n   */\r\n  rollSkill(skillId, options={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    let skl, sklName;\r\n    const skillParts = skillId.split("."),\r\n      isSubSkill = skillParts[1] === "subSkills" && skillParts.length === 3;\r\n    if (isSubSkill) {\r\n      skillId = skillParts[0];\r\n      skl = this.data.data.skills[skillId].subSkills[skillParts[2]];\r\n      sklName = `${CONFIG.PF1.skills[skillId]} (${skl.name})`;\r\n    }\r\n    else {\r\n      skl = this.data.data.skills[skillId];\r\n      if (skl.name != null) sklName = skl.name;\r\n      else sklName = CONFIG.PF1.skills[skillId];\r\n    }\r\n\r\n    // Add contextual attack string\r\n    let notes = [];\r\n    const rollData = duplicate(this.data.data);\r\n    const noteObjects = this.getContextNotes(`skill.${isSubSkill ? skillParts[2] : skillId}`);\r\n    for (let noteObj of noteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        notes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n    // Add untrained note\r\n    if (skl.rt && skl.rank === 0) {\r\n      notes.push(game.i18n.localize("PF1.Untrained"));\r\n    }\r\n\r\n    let props = [];\r\n    if (notes.length > 0) props.push({ header: "Notes", value: notes });\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].d20Roll({\r\n      event: options.event,\r\n      fastForward: options.skipDialog === true,\r\n      staticRoll: options.staticRoll,\r\n      parts: ["@mod"],\r\n      data: {mod: skl.mod},\r\n      title: game.i18n.localize("PF1.SkillCheck").format(sklName),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Roll a generic ability test or saving throw.\r\n   * Prompt the user for input on which variety of roll they want to do.\r\n   * @param {String} abilityId     The ability id (e.g. "str")\r\n   * @param {Object} options      Options which configure how ability tests or saving throws are rolled\r\n   */\r\n  rollAbility(abilityId, options={}) {\r\n    this.rollAbilityTest(abilityId, options);\r\n  }\r\n\r\n  rollBAB(options={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].d20Roll({\r\n      event: options.event,\r\n      parts: ["@mod"],\r\n      data: {mod: this.data.data.attributes.bab.total},\r\n      title: game.i18n.localize("PF1.BAB"),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      takeTwenty: false\r\n    });\r\n  }\r\n\r\n  rollCMB(options={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    // Add contextual notes\r\n    let notes = [];\r\n    const rollData = duplicate(this.data.data);\r\n    const noteObjects = this.getContextNotes("misc.cmb");\r\n    for (let noteObj of noteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) notes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else notes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n    // Add grapple note\r\n    if (this.data.data.attributes.conditions.grappled) {\r\n      notes.push("+2 to Grapple");\r\n    }\r\n\r\n    let props = [];\r\n    if (notes.length > 0) props.push({ header: game.i18n.localize("PF1.Notes"), value: notes });\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].d20Roll({\r\n      event: options.event,\r\n      parts: ["@mod"],\r\n      data: {mod: this.data.data.attributes.cmb.total},\r\n      title: game.i18n.localize("PF1.CMB"),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      takeTwenty: false,\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  }\r\n\r\n  getDefenseHeaders() {\r\n    const data = this.data.data;\r\n    const headers = [];\r\n\r\n    const reSplit = CONFIG.PF1.re.traitSeparator;\r\n    let misc = [];\r\n\r\n    // Damage reduction\r\n    if (data.traits.dr.length) {\r\n      headers.push({ header: game.i18n.localize("PF1.DamRed"), value: data.traits.dr.split(reSplit) });\r\n    }\r\n    // Energy resistance\r\n    if (data.traits.eres.length) {\r\n      headers.push({ header: game.i18n.localize("PF1.EnRes"), value: data.traits.eres.split(reSplit) });\r\n    }\r\n    // Damage vulnerabilities\r\n    if (data.traits.dv.value.length || data.traits.dv.custom.length) {\r\n      const value = [].concat(\r\n        data.traits.dv.value.map(obj => { return CONFIG.PF1.damageTypes[obj]; }),\r\n        data.traits.dv.custom.length > 0 ? data.traits.dv.custom.split(";") : [],\r\n      );\r\n      headers.push({ header: game.i18n.localize("PF1.DamVuln"), value: value });\r\n    }\r\n    // Condition resistance\r\n    if (data.traits.cres.length) {\r\n      headers.push({ header: game.i18n.localize("PF1.ConRes"), value: data.traits.cres.split(reSplit) });\r\n    }\r\n    // Immunities\r\n    if (data.traits.di.value.length || data.traits.di.custom.length ||\r\n      data.traits.ci.value.length || data.traits.ci.custom.length) {\r\n      const value = [].concat(\r\n        data.traits.di.value.map(obj => { return CONFIG.PF1.damageTypes[obj]; }),\r\n        data.traits.di.custom.length > 0 ? data.traits.di.custom.split(";") : [],\r\n        data.traits.ci.value.map(obj => { return CONFIG.PF1.conditionTypes[obj]; }),\r\n        data.traits.ci.custom.length > 0 ? data.traits.ci.custom.split(";") : [],\r\n      );\r\n      headers.push({ header: game.i18n.localize("PF1.ImmunityPlural"), value: value });\r\n    }\r\n    // Spell Resistance\r\n    if (data.attributes.sr.total > 0) {\r\n      misc.push(game.i18n.localize("PF1.SpellResistanceNote").format(data.attributes.sr.total));\r\n    }\r\n\r\n    if (misc.length > 0) {\r\n      headers.push({ header: game.i18n.localize("PF1.MiscShort"), value: misc });\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  async rollInitiative() {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    let formula = Object(_combat_js__WEBPACK_IMPORTED_MODULE_4__["_getInitiativeFormula"])(this);\r\n    let overrideRollMode = null,\r\n      bonus = "",\r\n      stop = false;\r\n    if (keyboard.isDown("Shift")) {\r\n      const dialogData = await Combat.showInitiativeDialog(formula);\r\n      overrideRollMode = dialogData.rollMode;\r\n      bonus = dialogData.bonus || "";\r\n      stop = dialogData.stop || false;\r\n    }\r\n\r\n    if (stop) return;\r\n\r\n    const actorData = this.getRollData();\r\n    // Add bonus\r\n    actorData.bonus = bonus;\r\n    if (bonus.length > 0) formula += " + @bonus";\r\n\r\n    // Roll initiative\r\n    const rollMode = overrideRollMode;\r\n    const roll = new Roll(formula, actorData).roll();\r\n\r\n    // Construct chat message data\r\n    let messageData = {\r\n      speaker: {\r\n        scene: canvas.scene._id,\r\n        actor: this._id,\r\n        token: this.token ? this.token._id : null,\r\n        alias: this.token ? this.token.name : null,\r\n      },\r\n      flavor: game.i18n.localize("PF1.RollsForInitiative").format(this.token ? this.token.name : this.name),\r\n    };\r\n    roll.toMessage(messageData, {rollMode});\r\n  }\r\n\r\n  rollSavingThrow(savingThrowId, options={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    // Add contextual notes\r\n    let notes = [];\r\n    const rollData = duplicate(this.data.data);\r\n    const noteObjects = this.getContextNotes(`savingThrow.${savingThrowId}`);\r\n    for (let noteObj of noteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) notes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else notes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n\r\n    // Roll saving throw\r\n    let props = this.getDefenseHeaders();\r\n    if (notes.length > 0) props.push({ header: game.i18n.localize("PF1.Notes"), value: notes });\r\n    const label = CONFIG.PF1.savingThrows[savingThrowId];\r\n    const savingThrow = this.data.data.attributes.savingThrows[savingThrowId];\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].d20Roll({\r\n      event: options.event,\r\n      parts: ["@mod"],\r\n      situational: true,\r\n      data: { mod: savingThrow.total },\r\n      title: game.i18n.localize("PF1.SavingThrowRoll").format(label),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      takeTwenty: false,\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  };\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Roll an Ability Test\r\n   * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus\r\n   * @param {String} abilityId    The ability ID (e.g. "str")\r\n   * @param {Object} options      Options which configure how ability tests are rolled\r\n   */\r\n  rollAbilityTest(abilityId, options={}) {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    // Add contextual notes\r\n    let notes = [];\r\n    const rollData = duplicate(this.data.data);\r\n    const noteObjects = this.getContextNotes(`abilityChecks.${abilityId}`);\r\n    for (let noteObj of noteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) notes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else notes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n\r\n    let props = this.getDefenseHeaders();\r\n    if (notes.length > 0) props.push({ header: "Notes", value: notes });\r\n    const label = CONFIG.PF1.abilities[abilityId];\r\n    const abl = this.data.data.abilities[abilityId];\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].d20Roll({\r\n      event: options.event,\r\n      parts: ["@mod + @checkMod - @energyDrain"],\r\n      data: {mod: abl.mod, checkMod: abl.checkMod, energyDrain: this.data.data.attributes.energyDrain},\r\n      title: game.i18n.localize("PF1.AbilityTest").format(label),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show defenses in chat\r\n   */\r\n  rollDefenses() {\r\n    if (!this.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n    const rollData = duplicate(this.data.data);\r\n\r\n    // Add contextual AC notes\r\n    let acNotes = [];\r\n    if (this.data.data.attributes.acNotes.length > 0) acNotes = this.data.data.attributes.acNotes.split(/[\\n\\r]+/);\r\n    const acNoteObjects = this.getContextNotes("misc.ac");\r\n    for (let noteObj of acNoteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) acNotes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else acNotes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n\r\n    // Add contextual CMD notes\r\n    let cmdNotes = [];\r\n    if (this.data.data.attributes.cmdNotes.length > 0) cmdNotes = this.data.data.attributes.cmdNotes.split(/[\\n\\r]+/);\r\n    const cmdNoteObjects = this.getContextNotes("misc.cmd");\r\n    for (let noteObj of cmdNoteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) cmdDotes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else cmdNotes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n\r\n    // Add contextual SR notes\r\n    let srNotes = [];\r\n    if (this.data.data.attributes.srNotes.length > 0) srNotes = this.data.data.attributes.srNotes.split(/[\\n\\r]+/);\r\n    const srNoteObjects = this.getContextNotes("misc.sr");\r\n    for (let noteObj of srNoteObjects) {\r\n      rollData.item = {};\r\n      if (noteObj.item != null) rollData.item = duplicate(noteObj.item.data.data);\r\n\r\n      for (let note of noteObj.notes) {\r\n        if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["isMinimumCoreVersion"])("0.5.2")) {\r\n          let noteStr = "";\r\n          if (note.length > 0) {\r\n            noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n              data: rollData,\r\n              msgStr: note\r\n            });\r\n          }\r\n          if (noteStr.length > 0) srNotes.push(...noteStr.split(/[\\n\\r]+/));\r\n        }\r\n        else srNotes.push(...note.split(/[\\n\\r]+/).map(o => TextEditor.enrichHTML(o, {rollData: rollData})));\r\n      }\r\n    }\r\n\r\n    // Add misc data\r\n    const reSplit = CONFIG.PF1.re.traitSeparator;\r\n    // Damage Reduction\r\n    let drNotes = [];\r\n    if (this.data.data.traits.dr.length) {\r\n      drNotes = this.data.data.traits.dr.split(reSplit);\r\n    }\r\n    // Energy Resistance\r\n    let energyResistance = [];\r\n    if (this.data.data.traits.eres.length) {\r\n      energyResistance.push(...this.data.data.traits.eres.split(reSplit));\r\n    }\r\n    // Damage Immunity\r\n    if (this.data.data.traits.di.value.length || this.data.data.traits.di.custom.length) {\r\n      const values = [\r\n        ...this.data.data.traits.di.value.map(obj => { return CONFIG.PF1.damageTypes[obj]; }),\r\n        ...this.data.data.traits.di.custom.length > 0 ? this.data.data.traits.di.custom.split(reSplit) : [],\r\n      ];\r\n      energyResistance.push(...values.map(o => game.i18n.localize("PF1.ImmuneTo").format(o)));\r\n    }\r\n    // Damage Vulnerability\r\n    if (this.data.data.traits.dv.value.length || this.data.data.traits.dv.custom.length) {\r\n      const values = [\r\n        ...this.data.data.traits.dv.value.map(obj => { return CONFIG.PF1.damageTypes[obj]; }),\r\n        ...this.data.data.traits.dv.custom.length > 0 ? this.data.data.traits.dv.custom.split(reSplit) : [],\r\n      ];\r\n      energyResistance.push(...values.map(o => game.i18n.localize("PF1.VulnerableTo").format(o)));\r\n    }\r\n\r\n    // Create message\r\n    const d = this.data.data;\r\n    const data = {\r\n      actor: this,\r\n      name: this.name,\r\n      tokenId: this.token ? `${this.token.scene._id}.${this.token.id}` : null,\r\n      ac: {\r\n        normal: d.attributes.ac.normal.total,\r\n        touch: d.attributes.ac.touch.total,\r\n        flatFooted: d.attributes.ac.flatFooted.total,\r\n        notes: acNotes,\r\n      },\r\n      cmd: {\r\n        normal: d.attributes.cmd.total,\r\n        flatFooted: d.attributes.cmd.flatFootedTotal,\r\n        notes: cmdNotes,\r\n      },\r\n      misc: {\r\n        sr: d.attributes.sr.total,\r\n        srNotes: srNotes,\r\n        drNotes: drNotes,\r\n        energyResistance: energyResistance,\r\n      },\r\n    };\r\n    // Add regeneration and fast healing\r\n    if ((getProperty(d, "traits.fastHealing") || "").length || (getProperty(d, "traits.regen") || "").length) {\r\n      data.regen = {\r\n        regen: d.traits.regen,\r\n        fastHealing: d.traits.fastHealing,\r\n      };\r\n    }\r\n    Object(_chat_js__WEBPACK_IMPORTED_MODULE_3__["createCustomChatMessage"])("systems/pf1/templates/chat/defenses.html", data, {\r\n      speaker: ChatMessage.getSpeaker({ actor: this.actor }),\r\n    });\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Apply rolled dice damage to the token or tokens which are currently controlled.\r\n   * This allows for damage to be scaled by a multiplier to account for healing, critical hits, or resistance\r\n   *\r\n   * @param {Number} value   The amount of damage to deal.\r\n   * @return {Promise}\r\n   */\r\n  static async applyDamage(value) {\r\n    const promises = [];\r\n    for (let t of canvas.tokens.controlled) {\r\n      let a = t.actor,\r\n          hp = a.data.data.attributes.hp,\r\n          tmp = parseInt(hp.temp) || 0,\r\n          dt = value > 0 ? Math.min(tmp, value) : 0;\r\n      if (!a.hasPerm(game.user, "OWNER")) {\r\n        ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n        continue;\r\n      }\r\n      promises.push(t.actor.update({\r\n        "data.attributes.hp.temp": tmp - dt,\r\n        "data.attributes.hp.value": Math.clamped(hp.value - (value - dt), -100, hp.max)\r\n      }));\r\n    }\r\n    return Promise.all(promises);\r\n  }\r\n\r\n  getSkill(key) {\r\n    for (let [k, s] of Object.entries(this.data.data.skills)) {\r\n      if (k === key) return s;\r\n      if (s.subSkills != null) {\r\n        for (let [k2, s2] of Object.entries(s.subSkills)) {\r\n          if (k2 === key) return s2;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  get allNotes() {\r\n    let result = [];\r\n\r\n    const noteItems = this.items.filter(o => { return o.data.data.contextNotes != null; });\r\n\r\n    for (let o of noteItems) {\r\n      if (o.type === "buff" && !o.data.data.active) continue;\r\n      if ((o.type === "equipment" || o.type === "weapon") && !o.data.data.equipped) continue;\r\n      if (!o.data.data.contextNotes || o.data.data.contextNotes.length === 0) continue;\r\n      result.push({ notes: o.data.data.contextNotes, item: o });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates an array with all the active context-sensitive notes for the given context on this actor.\r\n   * @param {String} context - The context to draw from.\r\n   */\r\n  getContextNotes(context) {\r\n    let result = this.allNotes;\r\n\r\n    // Attacks\r\n    if (context.match(/^attacks\\.(.+)/)) {\r\n      const key = RegExp.$1;\r\n      for (let note of result) {\r\n        note.notes = note.notes.filter(o => {\r\n          return (o.target === "attacks" && o.subTarget === key);\r\n        }).map(o => { return o.text; });\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    // Skill\r\n    if (context.match(/^skill\\.(.+)/)) {\r\n      const skillKey = RegExp.$1;\r\n      const skill = this.getSkill(skillKey);\r\n      const ability = skill.ability;\r\n      for (let note of result) {\r\n        note.notes = note.notes.filter(o => {\r\n          return (o.target === "skill" && o.subTarget === context) || (o.target === "skills" && (o.subTarget === `${ability}Skills` || o.subTarget === "skills"));\r\n        }).map(o => { return o.text; });\r\n      }\r\n\r\n      if (skill.notes != null && skill.notes !== "") {\r\n        result.push({ notes: [skill.notes], item: null });\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    // Saving throws\r\n    if (context.match(/^savingThrow\\.(.+)/)) {\r\n      const saveKey = RegExp.$1;\r\n      for (let note of result) {\r\n        note.notes = note.notes.filter(o => {\r\n          return o.target === "savingThrows" && (o.subTarget === saveKey || o.subTarget === "allSavingThrows");\r\n        }).map(o => { return o.text; });\r\n      }\r\n\r\n      if (this.data.data.attributes.saveNotes != null && this.data.data.attributes.saveNotes !== "") {\r\n        result.push({ notes: [this.data.data.attributes.saveNotes], item: null });\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    // Ability checks\r\n    if (context.match(/^abilityChecks\\.(.+)/)) {\r\n      const ablKey = RegExp.$1;\r\n      for (let note of result) {\r\n        note.notes = note.notes.filter(o => {\r\n          return o.target === "abilityChecks" && (o.subTarget === `${ablKey}Checks` || o.subTarget === "allChecks");\r\n        }).map(o => { return o.text; });\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    // Misc\r\n    if (context.match(/^misc\\.(.+)/)) {\r\n      const miscKey = RegExp.$1;\r\n      for (let note of result) {\r\n        note.notes = note.notes.filter(o => {\r\n          return o.target === "misc" && o.subTarget === miscKey;\r\n        }).map(o => { return o.text; });\r\n      }\r\n\r\n      if (miscKey === "cmb" && this.data.data.attributes.cmbNotes != null && this.data.data.attributes.cmbNotes !== "") {\r\n        result.push({ notes: [this.data.data.attributes.cmbNotes], item: null });\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  async createEmbeddedEntity(embeddedName, createData, options={}) {\r\n    let noArray = false;\r\n    if (!(createData instanceof Array)) {\r\n      createData = [createData];\r\n      noArray = true;\r\n    }\r\n\r\n    for (let obj of createData) {\r\n      // Don\'t auto-equip transferred items\r\n      if (obj._id != null && ["weapon", "equipment"].includes(obj.type)) {\r\n        obj.data.equipped = false;\r\n      }\r\n    }\r\n\r\n    return super.createEmbeddedEntity(embeddedName, (noArray ? createData[0] : createData), options);\r\n  }\r\n\r\n  _computeEncumbrance(updateData, srcData) {\r\n    const carry = this.getCarryCapacity(srcData);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.levels.light", carry.light);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.levels.medium", carry.medium);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.levels.heavy", carry.heavy);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.levels.carry", carry.heavy * 2);\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.levels.drag", carry.heavy * 5);\r\n\r\n    const carriedWeight = Math.max(0, this.getCarriedWeight(srcData));\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.carriedWeight", Math.round(carriedWeight * 10) / 10);\r\n\r\n    // Determine load level\r\n    let encLevel = 0;\r\n    if (carriedWeight > 0) {\r\n      if (carriedWeight >= srcData.data.attributes.encumbrance.levels.light) encLevel++;\r\n      if (carriedWeight >= srcData.data.attributes.encumbrance.levels.medium) encLevel++;\r\n    }\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.attributes.encumbrance.level", encLevel);\r\n  }\r\n\r\n  _calculateCoinWeight(data) {\r\n    return Object.values(data.data.currency).reduce((cur, amount) => {\r\n      return cur + amount;\r\n    }, 0) / 50;\r\n  }\r\n\r\n  getCarryCapacity(srcData) {\r\n    // Determine carrying capacity\r\n    const carryStr = srcData.data.abilities.str.total + srcData.data.abilities.str.carryBonus;\r\n    let carryMultiplier = srcData.data.abilities.str.carryMultiplier;\r\n    const size = srcData.data.traits.size;\r\n    if (srcData.data.attributes.quadruped) carryMultiplier *= CONFIG.PF1.encumbranceMultipliers.quadruped[size];\r\n    else carryMultiplier *= CONFIG.PF1.encumbranceMultipliers.normal[size];\r\n    const table = CONFIG.PF1.encumbranceLoads;\r\n\r\n    let heavy = Math.floor(table[carryStr] * carryMultiplier);\r\n    if (carryStr >= table.length) {\r\n      heavy = Math.floor(table[table.length-1] * (1 + (0.3 * (carryStr - (table.length-1)))));\r\n    }\r\n    // 1 Kg = 0.5 Kg\r\n    if(game.settings.get("pf1", "units") === "metric") {\r\n      heavy = heavy / 2\r\n    }\r\n      \r\n    return {\r\n      light: Math.floor(heavy / 3),\r\n      medium: Math.floor(heavy / 3 * 2),\r\n      heavy: heavy,\r\n    };\r\n  }\r\n\r\n  getCarriedWeight(srcData) {\r\n    // Determine carried weight\r\n    const physicalItems = srcData.items.filter(o => { return o.data.weight != null; });\r\n    return physicalItems.reduce((cur, o) => {\r\n      if (!o.data.carried) return cur;\r\n      return cur + (o.data.weight * o.data.quantity);\r\n    }, this._calculateCoinWeight(srcData));\r\n  }\r\n\r\n  /**\r\n   * @returns {number} The total amount of currency this actor has, in gold pieces\r\n   */\r\n  mergeCurrency() {\r\n    const carried = getProperty(this.data.data, "currency");\r\n    const alt = getProperty(this.data.data, "altCurrency");\r\n    return (carried ? carried.pp * 10 + carried.gp + carried.sp / 10 + carried.cp / 100 : 0) +\r\n      (alt ? alt.pp * 10 + alt.gp + alt.sp / 10 + alt.cp / 100 : 0);\r\n  }\r\n\r\n  /**\r\n   * Import a new owned Item from a compendium collection\r\n   * The imported Item is then added to the Actor as an owned item.\r\n   *\r\n   * @param collection {String}     The name of the pack from which to import\r\n   * @param entryId {String}        The ID of the compendium entry to import\r\n   */\r\n  importItemFromCollection(collection, entryId) {\r\n    const pack = game.packs.find(p => p.collection === collection);\r\n    if (pack.metadata.entity !== "Item") return;\r\n\r\n    return pack.getEntity(entryId).then(ent => {\r\n      console.log(`${vtt} | Importing Item ${ent.name} from ${collection}`);\r\n\r\n      let data = duplicate(ent.data);\r\n      if (this.sheet != null && this.sheet.rendered) {\r\n        data = mergeObject(data, this.sheet.getDropData(data));\r\n      }\r\n      delete data._id;\r\n      return this.createOwnedItem(data);\r\n    });\r\n  }\r\n\r\n  _createConsumableSpellDialog(itemData) {\r\n    new Dialog({\r\n      title: game.i18n.localize("PF1.CreateItemForSpell").format(itemData.name),\r\n      content: game.i18n.localize("PF1.CreateItemForSpell").format(itemData.name),\r\n      buttons: {\r\n        potion: {\r\n          icon: \'<i class="fas fa-prescription-bottle"></i>\',\r\n          label: "Potion",\r\n          callback: () => this.createConsumableSpell(itemData, "potion"),\r\n        },\r\n        scroll: {\r\n          icon: \'<i class="fas fa-scroll"></i>\',\r\n          label: "Scroll",\r\n          callback: () => this.createConsumableSpell(itemData, "scroll"),\r\n        },\r\n        wand: {\r\n          icon: \'<i class="fas fa-magic"></i>\',\r\n          label: "Wand",\r\n          callback: () => this.createConsumableSpell(itemData, "wand"),\r\n        },\r\n      },\r\n      default: "potion",\r\n    }).render(true);\r\n  }\r\n\r\n  async createConsumableSpell(itemData, type) {\r\n    let data = await _item_entity_js__WEBPACK_IMPORTED_MODULE_1__["ItemPF"].toConsumable(itemData, type);\r\n\r\n    if (data._id) delete data._id;\r\n    this.createEmbeddedEntity("OwnedItem", data);\r\n  }\r\n\r\n  getRollData(data=null) {\r\n    if (data == null) data = this.data.data;\r\n    const result = mergeObject(data, {\r\n      size: Object.keys(CONFIG.PF1.sizeChart).indexOf(getProperty(data, "traits.size")) - 4,\r\n    }, { inplace: false });\r\n\r\n    return result;\r\n  }\r\n\r\n  getCR(data=null) {\r\n    if (this.data.type !== "npc") return 0;\r\n    if (data == null) data = this.data.data;\r\n\r\n    const base = data.details.cr.base;\r\n    if (this.items == null) return base;\r\n\r\n    // Gather CR from templates\r\n    const templates = this.items.filter(o => o.type === "feat" && o.data.data.featType === "template");\r\n    return templates.reduce((cur, o) => {\r\n      const crOffset = o.data.data.crOffset;\r\n      if (typeof crOffset === "string" && crOffset.length) cur += new Roll(crOffset, this.getRollData(data)).roll().total;\r\n      return cur;\r\n    }, base);\r\n  }\r\n\r\n  async deleteEmbeddedEntity(embeddedName, data, options={}) {\r\n    if (embeddedName === "OwnedItem") {\r\n      if (!(data instanceof Array)) data = [data];\r\n\r\n      // Add children to list of items to be deleted\r\n      const _addChildren = async function(id) {\r\n        const item = this.items.find(o => o._id === id);\r\n        const children = await item.getLinkedItems("children");\r\n        for (let child of children) {\r\n          if (!data.includes(child._id)) {\r\n            data.push(child._id);\r\n            await _addChildren.call(this, child._id);\r\n          }\r\n        }\r\n      }\r\n      for (let id of data) {\r\n        await _addChildren.call(this, id);\r\n      }\r\n    }\r\n\r\n    super.deleteEmbeddedEntity(embeddedName, data, options);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/actor/entity.js?')},"./module/actor/sheets/base.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPF", function() { return ActorSheetPF; });\n/* harmony import */ var _apps_trait_selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../apps/trait-selector.js */ "./module/apps/trait-selector.js");\n/* harmony import */ var _apps_actor_rest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../apps/actor-rest.js */ "./module/apps/actor-rest.js");\n/* harmony import */ var _apps_actor_flags_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apps/actor-flags.js */ "./module/apps/actor-flags.js");\n/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dice.js */ "./module/dice.js");\n/* harmony import */ var _token_config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../token-config.js */ "./module/token-config.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib.js */ "./module/lib.js");\n/* harmony import */ var _apps_point_buy_calculator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../apps/point-buy-calculator.js */ "./module/apps/point-buy-calculator.js");\n/* harmony import */ var _widgets_item_picker_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../widgets/item-picker.js */ "./module/widgets/item-picker.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Extend the basic ActorSheet class to do all the PF things!\r\n * This sheet is an Abstract layer which is not used.\r\n *\r\n * @type {ActorSheet}\r\n */\r\nclass ActorSheetPF extends ActorSheet {\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    this.options.submitOnClose = false;\r\n\r\n    /**\r\n     * The scroll position on the active tab\r\n     * @type {number}\r\n     */\r\n    this._scrollTab = {};\r\n    this._initialTab = {};\r\n\r\n    /**\r\n     * Track the set of item filters which are applied\r\n     * @type {Set}\r\n     */\r\n    this._filters = {\r\n      inventory: new Set(),\r\n      spellbook: new Set(),\r\n      features: new Set(),\r\n      buffs: new Set()\r\n    };\r\n\r\n    /**\r\n     * Track item updates from the actor sheet.\r\n     * @type {Object[]}\r\n     */\r\n    this._itemUpdates = [];\r\n  }\r\n\r\n  get currentPrimaryTab() {\r\n    const primaryElem = this.element.find(\'nav[data-group="primary"] .item.active\');\r\n    if (primaryElem.length !== 1 || primaryElem.attr("data-tab") !== "inventory") return null;\r\n    return primaryElem.attr("data-tab");\r\n  }\r\n\r\n  get currentSpellbookKey() {\r\n    const elems = this.element.find("nav.spellbooks .item.active");\r\n    if (elems.length !== 1) return Object.keys(getProperty(this.data, "data.attributes.spells.spellbook") || { "primary": null })[0];\r\n    return elems.attr("data-tab");\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.\r\n   */\r\n  getData() {\r\n    // Basic data\r\n    let isOwner = this.entity.owner;\r\n    const data = {\r\n      owner: isOwner,\r\n      limited: this.entity.limited,\r\n      options: this.options,\r\n      editable: this.isEditable,\r\n      cssClass: isOwner ? "editable" : "locked",\r\n      isCharacter: this.entity.data.type === "character",\r\n      hasRace: false,\r\n      config: CONFIG.PF1,\r\n      useBGSkills: this.entity.data.type === "character" && game.settings.get("pf1", "allowBackgroundSkills"),\r\n      spellFailure: this.entity.spellFailure,\r\n      isGM: game.user.isGM,\r\n      race: this.actor.race != null ? duplicate(this.actor.race.data) : null,\r\n    };\r\n\r\n    // The Actor and its Items\r\n    data.actor = duplicate(this.actor.data);\r\n    data.items = this.actor.items.map(i => {\r\n      i.data.labels = i.labels;\r\n      i.data.hasAttack = i.hasAttack;\r\n      i.data.hasMultiAttack = i.hasMultiAttack;\r\n      i.data.hasDamage = i.hasDamage;\r\n      i.data.hasEffect = i.hasEffect;\r\n      i.data.hasAction = i.hasAction || i.isCharged;\r\n      i.data.showUnidentifiedData = i.showUnidentifiedData;\r\n      if (i.showUnidentifiedData) i.data.name = getProperty(i.data, "data.unidentified.name") || getProperty(i.data, "data.identifiedName") || i.data.name;\r\n      else i.data.name = getProperty(i.data, "data.identifiedName") || i.data.name;\r\n      return i.data;\r\n    });\r\n    data.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));\r\n    data.data = data.actor.data;\r\n    data.labels = this.actor.labels || {};\r\n    data.filters = this._filters;\r\n\r\n    // Hit point sources\r\n    if (this.actor.sourceDetails != null) data.sourceDetails = expandObject(this.actor.sourceDetails);\r\n    else data.sourceDetails = null;\r\n\r\n    // Ability Scores\r\n    for ( let [a, abl] of Object.entries(data.actor.data.abilities)) {\r\n      abl.label = CONFIG.PF1.abilities[a];\r\n      abl.sourceDetails = data.sourceDetails != null ? data.sourceDetails.data.abilities[a].total : [];\r\n    }\r\n\r\n    // Armor Class\r\n    for (let [a, ac] of Object.entries(data.actor.data.attributes.ac)) {\r\n      ac.label = CONFIG.PF1.ac[a];\r\n      ac.valueLabel = CONFIG.PF1.acValueLabels[a];\r\n      ac.sourceDetails = data.sourceDetails != null ? data.sourceDetails.data.attributes.ac[a].total : [];\r\n    }\r\n\r\n    // Saving Throws\r\n    for (let [a, savingThrow] of Object.entries(data.actor.data.attributes.savingThrows)) {\r\n      savingThrow.label = CONFIG.PF1.savingThrows[a];\r\n      savingThrow.sourceDetails = data.sourceDetails != null ? data.sourceDetails.data.attributes.savingThrows[a].total : [];\r\n    }\r\n\r\n    // Update skill labels\r\n    for ( let [s, skl] of Object.entries(data.actor.data.skills)) {\r\n      skl.label = CONFIG.PF1.skills[s];\r\n      skl.arbitrary = CONFIG.PF1.arbitrarySkills.includes(s);\r\n      skl.sourceDetails = (data.sourceDetails != null && data.sourceDetails.data.skills[s] != null) ? data.sourceDetails.data.skills[s].changeBonus : [];\r\n      if (skl.subSkills != null) {\r\n        for (let [s2, skl2] of Object.entries(skl.subSkills)) {\r\n          if (data.sourceDetails == null) continue;\r\n          if (data.sourceDetails.data.skills[s] == null) continue;\r\n          if (data.sourceDetails.data.skills[s].subSkills == null) continue;\r\n          skl2.sourceDetails = data.sourceDetails.data.skills[s].subSkills[s2] != null ? data.sourceDetails.data.skills[s].subSkills[s2].changeBonus : [];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update spellbook info\r\n    for (let spellbook of Object.values(data.actor.data.attributes.spells.spellbooks)) {\r\n      const cl = spellbook.cl.total;\r\n      spellbook.range = {\r\n        close: 25 + 5 * Math.floor(cl / 2),\r\n        medium: 100 + 10 * cl,\r\n        long: 400 + 40 * cl\r\n      };\r\n    }\r\n\r\n    // Control items\r\n    data.items.filter(obj => { return obj.type === "spell"; })\r\n    .forEach(obj => {\r\n      obj.isPrepared = obj.data.preparation.mode === "prepared";\r\n    });\r\n\r\n    // Update traits\r\n    this._prepareTraits(data.actor.data.traits);\r\n\r\n    // Prepare owned items\r\n    this._prepareItems(data);\r\n\r\n    // Compute encumbrance\r\n    data.encumbrance = this._computeEncumbrance(data);\r\n\r\n    // Prepare skillsets\r\n    data.skillsets = this._prepareSkillsets(data.actor.data.skills);\r\n\r\n    // Skill rank counting\r\n    const skillRanks = { allowed: 0, used: 0, bgAllowed: 0, bgUsed: 0, sentToBG: 0 };\r\n    // Count used skill ranks\r\n    for (let skl of Object.values(this.actor.data.data.skills)) {\r\n      if (skl.subSkills != null) {\r\n        for (let subSkl of Object.values(skl.subSkills)) {\r\n          if (data.useBGSkills && skl.background) {\r\n            skillRanks.bgUsed += subSkl.rank;\r\n          }\r\n          else {\r\n            skillRanks.used += subSkl.rank;\r\n          }\r\n        }\r\n      }\r\n      else if (data.useBGSkills && skl.background) {\r\n        skillRanks.bgUsed += skl.rank;\r\n      }\r\n      else {\r\n        skillRanks.used += skl.rank;\r\n      }\r\n    }\r\n    // Count allowed skill ranks\r\n    this.actor.data.items.filter(obj => { return obj.type === "class"; }).forEach(cls => {\r\n      const clsLevel = cls.data.level;\r\n      const clsSkillsPerLevel = cls.data.skillsPerLevel;\r\n      const fcSkills = cls.data.fc.skill.value;\r\n      skillRanks.allowed += (Math.max(1, clsSkillsPerLevel + this.actor.data.data.abilities.int.mod) * clsLevel) + fcSkills;\r\n      if (data.useBGSkills) skillRanks.bgAllowed = this.actor.data.data.details.level.value * 2;\r\n    });\r\n    if (this.actor.data.data.details.bonusSkillRankFormula !== "") {\r\n      let roll = new Roll(\r\n        this.actor.data.data.details.bonusSkillRankFormula,\r\n        duplicate(this.actor.data.data)\r\n      ).roll();\r\n      skillRanks.allowed += roll.total;\r\n    }\r\n    // Calculate used background skills\r\n    if (data.useBGSkills) {\r\n      if (skillRanks.bgUsed > skillRanks.bgAllowed) {\r\n        skillRanks.sentToBG = (skillRanks.bgUsed - skillRanks.bgAllowed);\r\n        skillRanks.allowed -= skillRanks.sentToBG;\r\n        skillRanks.bgAllowed += skillRanks.sentToBG;\r\n      }\r\n    }\r\n    data.skillRanks = skillRanks;\r\n\r\n    // Fetch the game settings relevant to sheet rendering.\r\n    data.healthConfig =  game.settings.get("pf1", "healthConfig");\r\n\r\n    // Return data to the sheet\r\n    return data\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  _prepareTraits(traits) {\r\n    const map = {\r\n      // "dr": CONFIG.PF1.damageTypes,\r\n      "di": CONFIG.PF1.damageTypes,\r\n      "dv": CONFIG.PF1.damageTypes,\r\n      "ci": CONFIG.PF1.conditionTypes,\r\n      "languages": CONFIG.PF1.languages,\r\n      "armorProf": CONFIG.PF1.armorProficiencies,\r\n      "weaponProf": CONFIG.PF1.weaponProficiencies\r\n    };\r\n    for ( let [t, choices] of Object.entries(map) ) {\r\n      const trait = traits[t];\r\n      if ( !trait ) continue;\r\n      let values = [];\r\n      if ( trait.value ) {\r\n        values = trait.value instanceof Array ? trait.value : [trait.value];\r\n      }\r\n      trait.selected = values.reduce((obj, t) => {\r\n        obj[t] = choices[t];\r\n        return obj;\r\n      }, {});\r\n\r\n      // Add custom entry\r\n      if ( trait.custom ) {\r\n        trait.custom.split(CONFIG.PF1.re.traitSeparator).forEach((c, i) => trait.selected[`custom${i+1}`] = c.trim());\r\n      }\r\n      trait.cssClass = !isObjectEmpty(trait.selected) ? "" : "inactive";\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Insert a spell into the spellbook object when rendering the character sheet\r\n   * @param {Object} data     The Actor data being prepared\r\n   * @param {Array} spells    The spell data being prepared\r\n   * @param {String} bookKey  The key of the spellbook being prepared\r\n   * @private\r\n   */\r\n  _prepareSpellbook(data, spells, bookKey) {\r\n    const owner = this.actor.owner;\r\n    const book = this.actor.data.data.attributes.spells.spellbooks[bookKey];\r\n\r\n    // Reduce spells to the nested spellbook structure\r\n    let spellbook = {};\r\n    for (let a = 0; a < 10; a++) {\r\n      spellbook[a] = {\r\n        level: a,\r\n        usesSlots: true,\r\n        spontaneous: book.spontaneous,\r\n        canCreate: owner === true,\r\n        canPrepare: (data.actor.type === "character"),\r\n        label: CONFIG.PF1.spellLevels[a],\r\n        spells: [],\r\n        uses: book.spells["spell"+a].value || 0,\r\n        baseSlots: book.spells["spell"+a].base,\r\n        slots: book.spells["spell"+a].max || 0,\r\n        dataset: { type: "spell", level: a, spellbook: bookKey },\r\n      };\r\n    }\r\n    spells.forEach(spell => {\r\n      const lvl = spell.data.level || 0;\r\n      spellbook[lvl].spells.push(spell);\r\n    });\r\n\r\n    // Sort the spellbook by section order\r\n    spellbook = Object.values(spellbook);\r\n    spellbook.sort((a, b) => a.level - b.level);\r\n    return spellbook;\r\n  }\r\n\r\n  _prepareSkillsets(skillset) {\r\n    let result = {\r\n      all: { skills: {} },\r\n      adventure: { skills: {} },\r\n      background: { skills: {} }\r\n    };\r\n\r\n    // sort skills by label\r\n    let keys = Object.keys(skillset).sort(function(a,b) {\r\n      if (skillset[a].custom && !skillset[b].custom) return 1;\r\n      if (!skillset[a].custom && skillset[b].custom) return -1;\r\n      return (\'\' + skillset[a].label).localeCompare(skillset[b].label)\r\n    });\r\n\r\n    keys.forEach( a => {\r\n      let skl = skillset[a]\r\n      result.all.skills[a] = skl;\r\n      if (skl.background) result.background.skills[a] = skl;\r\n      else result.adventure.skills[a] = skl;\r\n    })\r\n\r\n    return result;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Determine whether an Owned Item will be shown based on the current set of filters\r\n   * @return {boolean}\r\n   * @private\r\n   */\r\n  _filterItems(items, filters) {\r\n    return items.filter(item => {\r\n      const data = item.data;\r\n\r\n      // Action usage\r\n      for ( let f of ["action", "bonus", "reaction"] ) {\r\n        if ( filters.has(f) ) {\r\n          if ((data.activation && (data.activation.type !== f))) return false;\r\n        }\r\n      }\r\n\r\n      if ( filters.has("prepared") ) {\r\n        if ( data.level === 0 || ["pact", "innate"].includes(data.preparation.mode) ) return true;\r\n        if ( this.actor.data.type === "npc" ) return true;\r\n        return data.preparation.prepared;\r\n      }\r\n\r\n      // Equipment-specific filters\r\n      if ( filters.has("equipped") ) {\r\n        if (data.equipped && data.equipped !== true) return false;\r\n      }\r\n\r\n      // Whether active\r\n      if (filters.has("active")) {\r\n        if (!data.active) return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Get the font-awesome icon used to display a certain level of skill proficiency\r\n   * @private\r\n   */\r\n  _getProficiencyIcon(level) {\r\n    const icons = {\r\n      0: \'<i class="far fa-circle"></i>\',\r\n      0.5: \'<i class="fas fa-adjust"></i>\',\r\n      1: \'<i class="fas fa-check"></i>\',\r\n      2: \'<i class="fas fa-check-double"></i>\'\r\n    };\r\n    return icons[level];\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Compute the level and percentage of encumbrance for an Actor.\r\n   *\r\n   * @param {Object} actorData      The data object for the Actor being rendered\r\n   * @return {Object}               An object describing the character\'s encumbrance level\r\n   * @private\r\n   */\r\n  _computeEncumbrance(actorData) {\r\n    const carriedWeight = actorData.data.attributes.encumbrance.carriedWeight;\r\n    const load = {\r\n      light: actorData.data.attributes.encumbrance.levels.light,\r\n      medium: actorData.data.attributes.encumbrance.levels.medium,\r\n      heavy: actorData.data.attributes.encumbrance.levels.heavy\r\n    };\r\n    const carryLabel = game.settings.get("pf1", "units") === "metric" ? game.i18n.localize("PF1.CarryLabelKg").format(carriedWeight) : game.i18n.localize("PF1.CarryLabel").format(carriedWeight);\r\n    const enc = {\r\n      pct: {\r\n        light: Math.max(0, Math.min(carriedWeight * 100 / load.light, 99.5)),\r\n        medium: Math.max(0, Math.min((carriedWeight - load.light) * 100 / (load.medium - load.light), 99.5)),\r\n        heavy: Math.max(0, Math.min((carriedWeight - load.medium) * 100 / (load.heavy - load.medium), 99.5)),\r\n      },\r\n      encumbered: {\r\n        light: actorData.data.attributes.encumbrance.level >= 1,\r\n        medium: actorData.data.attributes.encumbrance.level >= 2,\r\n        heavy: actorData.data.attributes.encumbrance.carriedWeight >= actorData.data.attributes.encumbrance.levels.heavy,\r\n      },\r\n      light: actorData.data.attributes.encumbrance.levels.light,\r\n      medium: actorData.data.attributes.encumbrance.levels.medium,\r\n      heavy: actorData.data.attributes.encumbrance.levels.heavy,\r\n      value: actorData.data.attributes.encumbrance.carriedWeight,\r\n      carryLabel: carryLabel,\r\n    };\r\n\r\n    return enc;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Event Listeners and Handlers\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Activate event listeners using the prepared sheet HTML\r\n   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM\r\n   */\r\n  activateListeners(html) {\r\n    super.activateListeners(html);\r\n\r\n    this.createTabs(html);\r\n\r\n    // Tooltips\r\n    html.mousemove(ev => this._moveTooltips(ev));\r\n\r\n    // Activate Item Filters\r\n    const filterLists = html.find(".filter-list");\r\n    filterLists.each(this._initializeFilterItemList.bind(this));\r\n    filterLists.on("click", ".filter-item", this._onToggleFilter.bind(this));\r\n\r\n    // Item summaries\r\n    html.find(\'.item .item-name h4\').click(event => this._onItemSummary(event));\r\n\r\n    // Item Dragging\r\n    let handler = ev => this._onDragItemStart(ev);\r\n    html.find(\'li.item\').each((i, li) => {\r\n      if ( li.classList.contains("inventory-header") ) return;\r\n      li.setAttribute("draggable", true);\r\n      li.addEventListener("dragstart", handler, false);\r\n    });\r\n\r\n    // Everything below here is only needed if the sheet is editable\r\n    if (!this.options.editable) return;\r\n\r\n    // Trigger form submission from textarea elements.\r\n    html.find("textarea").change(this._onSubmit.bind(this));\r\n\r\n    // Show configureable fields\r\n    html.find(".config .config-control").click(this._onConfigControl.bind(this));\r\n\r\n    /* -------------------------------------------- */\r\n    /*  Abilities, Skills, Defenses and Traits\r\n    /* -------------------------------------------- */\r\n\r\n    // Ability Checks\r\n    html.find(\'.ability-name\').click(this._onRollAbilityTest.bind(this));\r\n\r\n    // BAB Check\r\n    html.find(".attribute.bab .attribute-name").click(this._onRollBAB.bind(this));\r\n\r\n    // CMB Check\r\n    html.find(".attribute.cmb .attribute-name").click(this._onRollCMB.bind(this));\r\n\r\n    // Initiative Check\r\n    html.find(".attribute.initiative .attribute-name").click(this._onRollInitiative.bind(this));\r\n\r\n    // Saving Throw\r\n    html.find(".defenses .saving-throw .attribute-name").click(this._onRollSavingThrow.bind(this));\r\n\r\n    // Add arbitrary skill\r\n    html.find(".skill.arbitrary .skill-create").click(ev => this._onArbitrarySkillCreate(ev));\r\n\r\n    // Delete arbitrary skill\r\n    html.find(".sub-skill > .skill-controls > .skill-delete").click(ev => this._onArbitrarySkillDelete(ev));\r\n\r\n    // Add custom skill\r\n    html.find(".skill-controls.skills .skill-create").click(ev => this._onSkillCreate(ev));\r\n\r\n    // Delete custom skill\r\n    html.find(".skill > .skill-controls > .skill-delete").click(ev => this._onSkillDelete(ev));\r\n\r\n    // Quick Item Action control\r\n    html.find(".item-actions a").mouseup(ev => this._quickItemActionControl(ev));\r\n\r\n    // Roll Skill Checks\r\n    html.find(".skill > .skill-name > .rollable").click(this._onRollSkillCheck.bind(this));\r\n    html.find(".sub-skill > .skill-name > .rollable").click(this._onRollSubSkillCheck.bind(this));\r\n\r\n    // Trait Selector\r\n    html.find(\'.trait-selector\').click(this._onTraitSelector.bind(this));\r\n\r\n    // Configure Special Flags\r\n    html.find(\'.configure-flags\').click(this._onConfigureFlags.bind(this));\r\n\r\n    // Roll defenses\r\n    html.find(".defense-rolls .generic-defenses .rollable").click(ev => { this.actor.rollDefenses(); });\r\n\r\n    // Rest\r\n    html.find(".rest").click(this._onRest.bind(this));\r\n\r\n    // Race controls\r\n    html.find(".race-container .item-control").click(this._onRaceControl.bind(this));\r\n\r\n    // Point Buy Calculator\r\n    html.find("button.pointbuy-calculator").click(this._onPointBuyCalculator.bind(this));\r\n\r\n    // Alignment\r\n    html.find(".control.alignment").click(this._onControlAlignment.bind(this));\r\n\r\n    /* -------------------------------------------- */\r\n    /*  Inventory\r\n    /* -------------------------------------------- */\r\n\r\n    // Owned Item management\r\n    html.find(\'.item-create\').click(ev => this._onItemCreate(ev));\r\n    html.find(\'.item-edit\').click(this._onItemEdit.bind(this));\r\n    html.find(\'.item-delete\').click(this._onItemDelete.bind(this));\r\n\r\n    // Item Rolling\r\n    html.find(\'.item .item-image\').click(event => this._onItemRoll(event));\r\n\r\n    // Quick add item quantity\r\n    html.find("a.item-control.item-quantity-add").click(ev => { this._quickChangeItemQuantity(ev, 1); });\r\n    // Quick subtract item quantity\r\n    html.find("a.item-control.item-quantity-subtract").click(ev => { this._quickChangeItemQuantity(ev, -1); });\r\n\r\n    // Quick (un)equip item\r\n    html.find("a.item-control.item-equip").click(ev => { this._quickEquipItem(ev); });\r\n\r\n    // Quick carry item\r\n    html.find("a.item-control.item-carry").click(ev => { this._quickCarryItem(ev); });\r\n\r\n    // Quick (un)identify item\r\n    html.find("a.item-control.item-identify").click(ev => { this._quickIdentifyItem(ev); });\r\n\r\n    // Quick toggle item property\r\n    html.find("a.item-control.item-toggle-data").click(this._itemToggleData.bind(this));\r\n\r\n    // Duplicate item\r\n    html.find("a.item-control.item-duplicate").click(this._duplicateItem.bind(this));\r\n\r\n    /* -------------------------------------------- */\r\n    /*  Feats\r\n    /* -------------------------------------------- */\r\n\r\n    html.find(".item-detail.item-uses input[type=\'text\']:not(:disabled)").off("change").change(this._setFeatUses.bind(this));\r\n\r\n    /* -------------------------------------------- */\r\n    /*  Spells\r\n    /* -------------------------------------------- */\r\n\r\n    html.find(".item-list .spell-uses input[type=\'number\'][data-type=\'amount\']").off("change").change(this._setSpellUses.bind(this));\r\n    html.find(".item-list .spell-uses input[type=\'number\'][data-type=\'max\']").off("change").change(this._setMaxSpellUses.bind(this));\r\n\r\n    html.find(".spellcasting-concentration .rollable").click(this._onRollConcentration.bind(this));\r\n\r\n    html.find(".spellcasting-cl .rollable").click(this._onRollCL.bind(this));\r\n\r\n    /* -------------------------------------------- */\r\n    /*  Buffs\r\n    /* -------------------------------------------- */\r\n\r\n    html.find(".item-detail.item-active input[type=\'checkbox\']").off("change").change(this._setItemActive.bind(this));\r\n\r\n    html.find(".item-detail.item-level input[type=\'text\']").off("change").change(this._setBuffLevel.bind(this));\r\n  }\r\n\r\n  createTabs(html) {\r\n    const tabGroups = {\r\n      "primary": {\r\n        "inventory": {},\r\n        "feats": {},\r\n        "skillset": {},\r\n        "buffs": {},\r\n        "attacks": {},\r\n        "spellbooks": {},\r\n      },\r\n    };\r\n    // Add spellbooks to tabGroups\r\n    for (let a of Object.keys(this.actor.data.data.attributes.spells.spellbooks)) {\r\n      tabGroups["primary"]["spellbooks"][`spells_${a}`] = {};\r\n    }\r\n    _lib_js__WEBPACK_IMPORTED_MODULE_5__["createTabs"].call(this, html, tabGroups);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  _moveTooltips(event) {\r\n    $(event.currentTarget).find(".tooltip:hover .tooltipcontent").css("left", `${event.clientX}px`).css("top", `${event.clientY + 24}px`);\r\n  }\r\n\r\n  /**\r\n   * Initialize Item list filters by activating the set of filters which are currently applied\r\n   * @private\r\n   */\r\n  _initializeFilterItemList(i, ul) {\r\n    const set = this._filters[ul.dataset.filter];\r\n    const filters = ul.querySelectorAll(".filter-item");\r\n    for ( let li of filters ) {\r\n      if ( set.has(li.dataset.filter) ) li.classList.add("active");\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Event Listeners and Handlers                */\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle click events for the Traits tab button to configure special Character Flags\r\n   */\r\n  _onConfigureFlags(event) {\r\n    event.preventDefault();\r\n    new _apps_actor_flags_js__WEBPACK_IMPORTED_MODULE_2__["ActorSheetFlags"](this.actor).render(true);\r\n  }\r\n\r\n  _onRest(event) {\r\n    event.preventDefault();\r\n    new _apps_actor_rest_js__WEBPACK_IMPORTED_MODULE_1__["ActorRestDialog"](this.actor).render(true);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it\'s roll method\r\n   * @private\r\n   */\r\n  _onItemRoll(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    if (item == null) return;\r\n    return item.roll();\r\n  }\r\n\r\n  _setFeatUses(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const value = Number(event.currentTarget.value);\r\n    const updateData = {};\r\n    this.setItemUpdate(item._id, "data.uses.value", value);\r\n  }\r\n\r\n  _setSpellUses(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const value = Number(event.currentTarget.value);\r\n    this.setItemUpdate(item._id, "data.preparation.preparedAmount", value);\r\n  }\r\n  _setMaxSpellUses(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const value = Number(event.currentTarget.value);\r\n    this.setItemUpdate(item._id, "data.preparation.maxAmount", value);\r\n  }\r\n\r\n  _setBuffLevel(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const value = Number(event.currentTarget.value);\r\n    this.setItemUpdate(item._id, "data.level", value);\r\n  }\r\n\r\n  _onRollConcentration(event) {\r\n    event.preventDefault();\r\n\r\n    const spellbookKey = $(event.currentTarget).closest(".spellbook-group").data("tab");\r\n    const spellbook = this.actor.data.data.attributes.spells.spellbooks[spellbookKey];\r\n    const rollData = duplicate(this.actor.data.data);\r\n    rollData.cl = spellbook.cl.total;\r\n\r\n    // Add contextual concentration string\r\n    let notes = [];\r\n    if (spellbook.concentrationNotes.length > 0) {\r\n      if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_5__["isMinimumCoreVersion"])("0.5.2")) {\r\n        let noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_3__["DicePF"].messageRoll({\r\n          data: rollData,\r\n          msgStr: spellbook.concentrationNotes\r\n        });\r\n        notes.push(...noteStr.split(/[\\n\\r]+/));\r\n      }\r\n      else notes.push(...spellbook.concentrationNotes.split(/[\\n\\r]+/));\r\n    }\r\n\r\n    let props = [];\r\n    if (notes.length > 0) props.push({ header: game.i18n.localize("PF1.Notes"), value: notes });\r\n    let formulaRoll = 0;\r\n    if (spellbook.concentrationFormula.length) formulaRoll = new Roll(spellbook.concentrationFormula, rollData).roll().total;\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_3__["DicePF"].d20Roll({\r\n      event: event,\r\n      parts: ["@cl + @mod + @concentrationBonus + @formulaBonus"],\r\n      data: {\r\n        cl: spellbook.cl.total,\r\n        mod: this.actor.data.data.abilities[spellbook.ability].mod,\r\n        concentrationBonus: spellbook.concentration,\r\n        formulaBonus: formulaRoll,\r\n      },\r\n      title: game.i18n.localize("PF1.ConcentrationCheck"),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      takeTwenty: false,\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  }\r\n\r\n  _onRollCL(event) {\r\n    event.preventDefault();\r\n\r\n    const spellbookKey = $(event.currentTarget).closest(".spellbook-group").data("tab");\r\n    const spellbook = this.actor.data.data.attributes.spells.spellbooks[spellbookKey];\r\n    const rollData = duplicate(this.actor.data.data);\r\n\r\n    // Add contextual caster level string\r\n    let notes = [];\r\n    if (spellbook.clNotes.length > 0) {\r\n      if (!Object(_lib_js__WEBPACK_IMPORTED_MODULE_5__["isMinimumCoreVersion"])("0.5.2")) {\r\n        let noteStr = _dice_js__WEBPACK_IMPORTED_MODULE_3__["DicePF"].messageRoll({\r\n          data: rollData,\r\n          msgStr: spellbook.clNotes\r\n        });\r\n        notes.push(...noteStr.split(/[\\n\\r]+/));\r\n      }\r\n      else notes.push(...spellbook.clNotes.split(/[\\n\\r]+/));\r\n    }\r\n\r\n    let props = [];\r\n    if (notes.length > 0) props.push({ header: game.i18n.localize("PF1.Notes"), value: notes });\r\n    return _dice_js__WEBPACK_IMPORTED_MODULE_3__["DicePF"].d20Roll({\r\n      event: event,\r\n      parts: [`@cl`],\r\n      data: { cl: spellbook.cl.total },\r\n      title: game.i18n.localize("PF1.CasterLevelCheck"),\r\n      speaker: ChatMessage.getSpeaker({actor: this}),\r\n      takeTwenty: false,\r\n      chatTemplate: "systems/pf1/templates/chat/roll-ext.html",\r\n      chatTemplateData: { hasProperties: props.length > 0, properties: props }\r\n    });\r\n  }\r\n\r\n  _setItemActive(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const value = $(event.currentTarget).prop("checked");\r\n    const updateData = {};\r\n    updateData["data.active"] = value;\r\n    if (item.hasPerm(game.user, "OWNER")) item.update(updateData);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle attempting to recharge an item usage by rolling a recharge check\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  _onItemRecharge(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n    return item.rollRecharge();\r\n  };\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it\'s roll method\r\n   * @private\r\n   */\r\n  _onItemSummary(event) {\r\n    event.preventDefault();\r\n    let li = $(event.currentTarget).parents(".item"),\r\n        item = this.actor.getOwnedItem(li.attr("data-item-id")),\r\n        chatData = item.getChatData({secrets: this.actor.owner});\r\n\r\n    // Toggle summary\r\n    if ( li.hasClass("expanded") ) {\r\n      let summary = li.children(".item-summary");\r\n      summary.slideUp(200, () => summary.remove());\r\n    } else {\r\n      let div = $(`<div class="item-summary">${chatData.description.value}</div>`);\r\n      let props = $(`<div class="item-properties"></div>`);\r\n      chatData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));\r\n      div.append(props);\r\n      li.append(div.hide());\r\n      div.slideDown(200);\r\n    }\r\n    li.toggleClass("expanded");\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  _onArbitrarySkillCreate(event) {\r\n    event.preventDefault();\r\n    const skillId = $(event.currentTarget).parents(".skill").attr("data-skill");\r\n    const mainSkillData = this.actor.data.data.skills[skillId];\r\n    const skillData = {\r\n      name: "",\r\n      ability: mainSkillData.ability,\r\n      rank: 0,\r\n      notes: "",\r\n      mod: 0,\r\n      rt: mainSkillData.rt,\r\n      cs: mainSkillData.cs,\r\n      acp: mainSkillData.acp,\r\n    };\r\n\r\n    // Get tag\r\n    let count = 1;\r\n    let tag = `${skillId}${count}`;\r\n    while (mainSkillData.subSkills[tag] != null) {\r\n      count++;\r\n      tag = `${skillId}${count}`;\r\n    }\r\n\r\n    const updateData = {};\r\n    updateData[`data.skills.${skillId}.subSkills.${tag}`] = skillData;\r\n    if (this.actor.hasPerm(game.user, "OWNER")) this.actor.update(updateData);\r\n  }\r\n\r\n  _onSkillCreate(event) {\r\n    event.preventDefault();\r\n    const isBackground = $(event.currentTarget).parents(".skills-list").attr("data-background") === "true";\r\n    const skillData = {\r\n      name: "",\r\n      ability: "int",\r\n      rank: 0,\r\n      notes: "",\r\n      mod: 0,\r\n      rt: false,\r\n      cs: false,\r\n      acp: false,\r\n      background: isBackground,\r\n      custom: true\r\n    };\r\n\r\n    let tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_5__["createTag"])(skillData.name || "skill");\r\n    let count = 1;\r\n    while (this.actor.data.data.skills[tag] != null) {\r\n      count++;\r\n      tag = Object(_lib_js__WEBPACK_IMPORTED_MODULE_5__["createTag"])(skillData.name || "skill") + count.toString();\r\n    }\r\n\r\n    const updateData = {};\r\n    updateData[`data.skills.${tag}`] = skillData;\r\n    if (this.actor.hasPerm(game.user, "OWNER")) this.actor.update(updateData);\r\n  }\r\n\r\n  _onArbitrarySkillDelete(event) {\r\n    event.preventDefault();\r\n    const mainSkillId = $(event.currentTarget).parents(".sub-skill").attr("data-main-skill");\r\n    const subSkillId = $(event.currentTarget).parents(".sub-skill").attr("data-skill");\r\n\r\n    const updateData = {};\r\n    updateData[`data.skills.${mainSkillId}.subSkills.-=${subSkillId}`] = null;\r\n    if (this.actor.hasPerm(game.user, "OWNER")) this.actor.update(updateData);\r\n  }\r\n\r\n  _onSkillDelete(event) {\r\n    event.preventDefault();\r\n    const skillId = $(event.currentTarget).parents(".skill").attr("data-skill");\r\n\r\n    const updateData = {};\r\n    updateData[`data.skills.-=${skillId}`] = null;\r\n    if (this.actor.hasPerm(game.user, "OWNER")) this.actor.update(updateData);\r\n  }\r\n\r\n  async _onRaceControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add race\r\n    if (a.classList.contains("add")) {\r\n      const itemData = {\r\n        name: "New Race",\r\n        type: "race",\r\n      };\r\n      this.actor.createOwnedItem(itemData);\r\n    }\r\n    // Edit race\r\n    else if (a.classList.contains("edit")) {\r\n      this._onItemEdit(event);\r\n    }\r\n    // Delete race\r\n    else if (a.classList.contains("delete")) {\r\n      this._onItemDelete(event);\r\n    }\r\n  }\r\n\r\n  async _onPointBuyCalculator(event) {\r\n    event.preventDefault();\r\n\r\n    new _apps_point_buy_calculator_js__WEBPACK_IMPORTED_MODULE_6__["PointBuyCalculator"](this).render(true);\r\n  }\r\n\r\n  async _onControlAlignment(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    const items = Object.entries(CONFIG.PF1.alignmentsShort).reduce((cur, o) => {\r\n      cur.push({ value: o[0], label: o[1] });\r\n      return cur;\r\n    }, []);\r\n    const w = new _widgets_item_picker_js__WEBPACK_IMPORTED_MODULE_7__["Widget_ItemPicker"](alignment => {\r\n      this.actor.update({"data.details.alignment": alignment});\r\n    }, {items: items, columns: 3});\r\n    w.render($(a));\r\n  }\r\n\r\n  async _quickItemActionControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    // Quick Attack\r\n    if (a.classList.contains("item-attack")) {\r\n      await item.use({ev: event, skipDialog: event.shiftKey});\r\n    }\r\n  }\r\n\r\n  async _quickChangeItemQuantity(event, add=1) {\r\n    event.preventDefault();\r\n    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    const curQuantity = getProperty(item.data, "data.quantity") || 0;\r\n    const newQuantity = Math.max(0, curQuantity + add);\r\n    item.update({ "data.quantity": newQuantity });\r\n  }\r\n\r\n  async _quickEquipItem(event) {\r\n    event.preventDefault();\r\n    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    if (hasProperty(item.data, "data.equipped")) {\r\n      item.update({ "data.equipped": !item.data.data.equipped });\r\n    }\r\n  }\r\n\r\n  async _quickCarryItem(event) {\r\n    event.preventDefault();\r\n    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    if (hasProperty(item.data, "data.carried")) {\r\n      item.update({ "data.carried": !item.data.data.carried });\r\n    }\r\n  }\r\n\r\n  async _quickIdentifyItem(event) {\r\n    event.preventDefault();\r\n    if (!game.user.isGM) {\r\n      ui.notifications.error("You are not allowed to identify items");\r\n      return;\r\n    }\r\n    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n\r\n    if (hasProperty(item.data, "data.identified")) {\r\n      item.update({ "data.identified": !item.data.data.identified });\r\n    }\r\n  }\r\n\r\n  async _itemToggleData(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    const itemId = $(a).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n    const property = $(a).attr("name");\r\n\r\n    const updateData = {};\r\n    updateData[property] = !getProperty(item.data, property);\r\n    item.update(updateData);\r\n  }\r\n\r\n  async _duplicateItem(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    const itemId = $(a).parents(".item").attr("data-item-id");\r\n    const item = this.actor.getOwnedItem(itemId);\r\n    const data = duplicate(item.data);\r\n\r\n    delete data._id;\r\n    data.name = `${data.name} (Copy)`;\r\n    if (data.links) data.links = {};\r\n\r\n    this.actor.createOwnedItem(data);\r\n  }\r\n\r\n  /**\r\n   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset\r\n   * @private\r\n   */\r\n  _onItemCreate(event) {\r\n    event.preventDefault();\r\n    const header = event.currentTarget;\r\n    const type = header.dataset.type;\r\n    const typeName = header.dataset.typeName || header.dataset.type;\r\n    const itemData = {\r\n      name: `New ${typeName.capitalize()}`,\r\n      type: type,\r\n      data: duplicate(header.dataset)\r\n    };\r\n    delete itemData.data["type"];\r\n    return this.actor.createOwnedItem(itemData);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle editing an existing Owned Item for the Actor\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  _onItemEdit(event) {\r\n    event.preventDefault();\r\n    const li = event.currentTarget.closest(".item");\r\n    const item = this.actor.getOwnedItem(li.dataset.itemId);\r\n    item.sheet.render(true);\r\n  }\r\n\r\n  /**\r\n   * Handle deleting an existing Owned Item for the Actor\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  _onItemDelete(event) {\r\n    event.preventDefault();\r\n\r\n    const button = event.currentTarget;\r\n    if (button.disabled) return;\r\n\r\n    const li = event.currentTarget.closest(".item");\r\n    if (keyboard.isDown("Shift")) {\r\n      this.actor.deleteOwnedItem(li.dataset.itemId);\r\n    }\r\n    else {\r\n      button.disabled = true;\r\n\r\n      const msg = `<p>${game.i18n.localize("PF1.DeleteItemConfirmation")}</p>`;\r\n      Dialog.confirm({\r\n        title: game.i18n.localize("PF1.DeleteItem"),\r\n        content: msg,\r\n        yes: () => {\r\n          this.actor.deleteOwnedItem(li.dataset.itemId);\r\n          button.disabled = false;\r\n        },\r\n        no: () => button.disabled = false\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle rolling an Ability check, either a test or a saving throw\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  _onRollAbilityTest(event) {\r\n    event.preventDefault();\r\n    let ability = event.currentTarget.parentElement.dataset.ability;\r\n    this.actor.rollAbility(ability, {event: event});\r\n  }\r\n\r\n  _onRollBAB(event) {\r\n    event.preventDefault();\r\n    this.actor.rollBAB({event: event});\r\n  }\r\n\r\n  _onRollCMB(event) {\r\n    event.preventDefault();\r\n    this.actor.rollCMB({event: event});\r\n  }\r\n\r\n  _onRollInitiative(event) {\r\n    event.preventDefault();\r\n    this.actor.rollInitiative();\r\n  }\r\n\r\n  _onRollSavingThrow(event) {\r\n    event.preventDefault();\r\n    let savingThrow = event.currentTarget.parentElement.dataset.savingthrow;\r\n    this.actor.rollSavingThrow(savingThrow, {event: event});\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Organize and classify Owned Items\r\n   * @private\r\n   */\r\n  _prepareItems(data) {\r\n    // Set item tags\r\n    for (let [key, res] of Object.entries(getProperty(this.actor.data, "data.resources"))) {\r\n      if (!res) continue;\r\n      const id = res._id;\r\n      if (!id) continue;\r\n      const item = this.actor.items.find(o => o._id === id);\r\n      if (!item) continue;\r\n      item.data.tag = key;\r\n    }\r\n\r\n    // Categorize items as inventory, spellbook, features, and classes\r\n    const inventory = {\r\n      weapon: { label: game.i18n.localize("PF1.InventoryWeapons"), canCreate: true, hasActions: false, items: [], canEquip: true, dataset: { type: "weapon" } },\r\n      equipment: { label: game.i18n.localize("PF1.InventoryArmorEquipment"), canCreate: true, hasActions: false, items: [], canEquip: true, dataset: { type: "equipment" }, hasSlots: true },\r\n      consumable: { label: game.i18n.localize("PF1.InventoryConsumables"), canCreate: true, hasActions: true, items: [], canEquip: false, dataset: { type: "consumable" } },\r\n      gear: { label: CONFIG.PF1.lootTypes["gear"], canCreate: true, hasActions: false, items: [], canEquip: false, dataset: { type: "loot", "type-name": game.i18n.localize("PF1.LootTypeGearSingle"), "sub-type": "gear" } },\r\n      ammo: { label: CONFIG.PF1.lootTypes["ammo"], canCreate: true, hasActions: false, items: [], canEquip: false, dataset: { type: "loot", "type-name": game.i18n.localize("PF1.LootTypeAmmoSingle"), "sub-type": "ammo" } },\r\n      misc: { label: CONFIG.PF1.lootTypes["misc"], canCreate: true, hasActions: false, items: [], canEquip: false, dataset: { type: "loot", "type-name": game.i18n.localize("PF1.Misc"), "sub-type": "misc" } },\r\n      tradeGoods: { label: CONFIG.PF1.lootTypes["tradeGoods"], canCreate: true, hasActions: false, items: [], canEquip: false, dataset: { type: "loot", "type-name": game.i18n.localize("PF1.LootTypeTradeGoodsSingle"), "sub-type": "tradeGoods" } },\r\n      all: { label: game.i18n.localize("PF1.All"), canCreate: false, hasActions: true, items: [], canEquip: true, dataset: {} },\r\n    };\r\n\r\n    // Partition items by category\r\n    let [items, spells, feats, classes, attacks] = data.items.reduce((arr, item) => {\r\n      item.img = item.img || DEFAULT_TOKEN;\r\n      item.isStack = item.data.quantity ? item.data.quantity > 1 : false;\r\n      item.hasUses = item.data.uses && (item.data.uses.max > 0);\r\n      item.isCharged = ["day", "week", "charges"].includes(getProperty(item, "data.uses.per"));\r\n\r\n      const itemQuantity = getProperty(item, "data.quantity") != null ? getProperty(item, "data.quantity") : 1;\r\n      const itemCharges = getProperty(item, "data.uses.value") != null ? getProperty(item, "data.uses.value") : 1;\r\n      item.empty = itemQuantity <= 0 || (item.isCharged && itemCharges <= 0);\r\n      if ( item.type === "spell" ) arr[1].push(item);\r\n      else if ( item.type === "feat" ) arr[2].push(item);\r\n      else if ( item.type === "class" ) arr[3].push(item);\r\n      else if (item.type === "attack") arr[4].push(item);\r\n      else if (["weapon", "equipment", "consumable", "loot"].includes(item.type)) arr[0].push(item);\r\n      return arr;\r\n    }, [[], [], [], [], []]);\r\n\r\n    // Apply active item filters\r\n    items = this._filterItems(items, this._filters.inventory);\r\n    spells = this._filterItems(spells, this._filters.spellbook);\r\n    feats = this._filterItems(feats, this._filters.features);\r\n\r\n    // Organize Spellbook\r\n    let spellbookData = {};\r\n    const spellbooks = data.actor.data.attributes.spells.spellbooks;\r\n    for (let [a, spellbook] of Object.entries(spellbooks)) {\r\n      const spellbookSpells = spells.filter(obj => { return obj.data.spellbook === a; });\r\n      spellbookData[a] = {\r\n        data: this._prepareSpellbook(data, spellbookSpells, a),\r\n        prepared: spellbookSpells.filter(obj => { return obj.data.preparation.mode === "prepared" && obj.data.preparation.prepared; }).length,\r\n        orig: spellbook\r\n      };\r\n    }\r\n\r\n    // Organize Inventory\r\n    for ( let i of items ) {\r\n      const subType = i.type === "loot" ? i.data.subType || "gear" : i.data.subType;\r\n      i.data.quantity = i.data.quantity || 0;\r\n      i.data.weight = i.data.weight || 0;\r\n      i.totalWeight = Math.round(i.data.quantity * i.data.weight * 10) / 10;\r\n      i.units = game.settings.get("pf1", "units") === "metric" ? game.i18n.localize("PF1.Kgs") : game.i18n.localize("PF1.Lbs")\r\n      if (inventory[i.type] != null) inventory[i.type].items.push(i);\r\n      if (subType != null && inventory[subType] != null) inventory[subType].items.push(i);\r\n      inventory.all.items.push(i);\r\n    }\r\n\r\n    // Organize Features\r\n    const features = {\r\n      classes: { label: game.i18n.localize("PF1.ClassPlural"), items: [], canCreate: true, hasActions: false, dataset: { type: "class" }, isClass: true },\r\n      template: { label: game.i18n.localize("PF1.TemplatePlural"), items: [], canCreate: true, hasActions: false, dataset: { type: "feat", "type-name": game.i18n.localize("PF1.FeatTypeTemplate"), "feat-type": "template" } },\r\n      feat: { label: game.i18n.localize("PF1.FeatPlural"), items: [], canCreate: true, hasActions: true, dataset: { type: "feat", "feat-type": "feat" } },\r\n      classFeat: { label: game.i18n.localize("PF1.ClassFeaturePlural"), items: [], canCreate: true, hasActions: true, dataset: { type: "feat", "type-name": game.i18n.localize("PF1.FeatTypeClassFeat"), "feat-type": "classFeat" } },\r\n      trait: { label: game.i18n.localize("PF1.TraitPlural"), items: [], canCreate: true, hasActions: true, dataset: { type: "feat", "type-name": game.i18n.localize("PF1.FeatTypeTraits"), "feat-type": "trait" } },\r\n      racial: { label: game.i18n.localize("PF1.RacialTraitPlural"), items: [], canCreate: true, hasActions: true, dataset: { type: "feat", "type-name": game.i18n.localize("PF1.FeatTypeRacial"), "feat-type": "racial" } },\r\n      misc: { label: game.i18n.localize("PF1.Misc"), items: [], canCreate: true, hasActions: true, dataset: { type: "feat", "type-name": game.i18n.localize("PF1.Misc"), "feat-type": "misc" } },\r\n      all: { label: game.i18n.localize("PF1.All"), items: [], canCreate: false, hasActions: true, dataset: { type: "feat" } },\r\n    };\r\n\r\n    for (let f of feats) {\r\n      let k = f.data.featType;\r\n      if (f.data.abilityType && f.data.abilityType !== "none") {\r\n        f.abilityType = CONFIG.PF1.abilityTypes[f.data.abilityType].long;\r\n        f.abilityTypeShort = CONFIG.PF1.abilityTypes[f.data.abilityType].short;\r\n      }\r\n      else {\r\n        f.abilityType = "";\r\n        f.abilityTypeShort = "";\r\n      }\r\n      features[k].items.push(f);\r\n      features.all.items.push(f);\r\n    }\r\n    classes.sort((a, b) => b.level - a.level);\r\n    features.classes.items = classes;\r\n\r\n    // Buffs\r\n    let buffs = data.items.filter(obj => { return obj.type === "buff"; });\r\n    buffs = this._filterItems(buffs, this._filters.buffs);\r\n    const buffSections = {\r\n      temp: { label: game.i18n.localize("PF1.Temporary"), items: [], hasActions: false, dataset: { type: "buff", "buff-type": "temp" } },\r\n      perm: { label: game.i18n.localize("PF1.Permanent"), items: [], hasActions: false, dataset: { type: "buff", "buff-type": "perm" } },\r\n      item: { label: game.i18n.localize("PF1.Item"), items: [], hasActions: false, dataset: { type: "buff", "buff-type": "item" } },\r\n      misc: { label: game.i18n.localize("PF1.Misc"), items: [], hasActions: false, dataset: { type: "buff", "buff-type": "misc" } },\r\n      all: { label: game.i18n.localize("PF1.All"), items: [], hasActions: false, dataset: { type: "buff" } },\r\n    };\r\n\r\n    for (let b of buffs) {\r\n      let s = b.data.buffType;\r\n      if (!buffSections[s]) continue;\r\n      buffSections[s].items.push(b);\r\n      buffSections.all.items.push(b);\r\n    }\r\n\r\n    // Attacks\r\n    const attackSections = {\r\n      weapon: { label: game.i18n.localize("PF1.AttackTypeWeaponPlural"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "weapon" } },\r\n      natural: { label: game.i18n.localize("PF1.AttackTypeNaturalPlural"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "natural" } },\r\n      ability: { label: game.i18n.localize("PF1.AttackTypeAbilityPlural"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "ability" } },\r\n      racialAbility: { label: game.i18n.localize("PF1.AttackTypeRacialPlural"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "racialAbility" } },\r\n      item: { label: game.i18n.localize("PF1.Items"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "item" } },\r\n      misc: { label: game.i18n.localize("PF1.Misc"), items: [], canCreate: true, initial: false, showTypes: false, dataset: { type: "attack", "attack-type": "misc" } },\r\n      all: { label: game.i18n.localize("PF1.All"), items: [], canCreate: false, initial: true, showTypes: true, dataset: { type: "attack" } },\r\n    };\r\n\r\n    for (let a of attacks) {\r\n      let s = a.data.attackType;\r\n      if (!attackSections[s]) continue;\r\n      attackSections[s].items.push(a);\r\n      attackSections.all.items.push(a);\r\n    }\r\n\r\n    // Assign and return\r\n    data.inventory = Object.values(inventory);\r\n    data.spellbookData = spellbookData;\r\n    data.features = Object.values(features);\r\n    data.buffs = buffSections;\r\n    data.attacks = attackSections;\r\n  }\r\n\r\n  /**\r\n   * Handle rolling a Skill check\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  _onRollSkillCheck(event) {\r\n    event.preventDefault();\r\n    const skill = event.currentTarget.parentElement.parentElement.dataset.skill;\r\n    this.actor.rollSkill(skill, {event: event});\r\n  }\r\n\r\n  _onRollSubSkillCheck(event) {\r\n    event.preventDefault();\r\n    const mainSkill = event.currentTarget.parentElement.parentElement.dataset.mainSkill;\r\n    const skill = event.currentTarget.parentElement.parentElement.dataset.skill;\r\n    this.actor.rollSkill(`${mainSkill}.subSkills.${skill}`, {event: event});\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle toggling of filters to display a different set of owned items\r\n   * @param {Event} event     The click event which triggered the toggle\r\n   * @private\r\n   */\r\n  _onToggleFilter(event) {\r\n    event.preventDefault();\r\n    const li = event.currentTarget;\r\n    const set = this._filters[li.parentElement.dataset.filter];\r\n    const filter = li.dataset.filter;\r\n    if ( set.has(filter) ) set.delete(filter);\r\n    else set.add(filter);\r\n    this.render();\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle spawning the ActorTraitSelector application which allows a checkbox of multiple trait options\r\n   * @param {Event} event   The click event which originated the selection\r\n   * @private\r\n   */\r\n  _onTraitSelector(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n    const label = a.parentElement.querySelector("label");\r\n    const options = {\r\n      name: label.getAttribute("for"),\r\n      title: label.innerText,\r\n      choices: CONFIG.PF1[a.dataset.options]\r\n    };\r\n    new _apps_trait_selector_js__WEBPACK_IMPORTED_MODULE_0__["ActorTraitSelector"](this.actor, options).render(true)\r\n  }\r\n\r\n  _onConfigureToken(event) {\r\n    event.preventDefault();\r\n\r\n    // Determine the Token for which to configure\r\n    const token = this.token || new Token(this.actor.data.token);\r\n\r\n    // Render the Token Config application\r\n    new _token_config_js__WEBPACK_IMPORTED_MODULE_4__["TokenConfigPF"](token, {\r\n      left: Math.max(this.position.left - 560 - 10, 10),\r\n      top: this.position.top,\r\n      configureDefault: !this.token\r\n    }).render(true);\r\n  }\r\n\r\n  async saveMCEContent(updateData=null) {\r\n    let manualUpdate = false;\r\n    if (updateData == null) {\r\n      manualUpdate = true;\r\n      updateData = {};\r\n    }\r\n\r\n    for (const [key, editor] of Object.entries(this.editors)) {\r\n      if (editor.mce == null) continue;\r\n\r\n      updateData[key] = editor.mce.getContent();\r\n    }\r\n\r\n    if (manualUpdate && Object.keys(updateData).length > 0) await this.actor.update(updateData);\r\n  }\r\n\r\n  setItemUpdate(id, key, value) {\r\n    let obj = this._itemUpdates.filter(o => { return o._id === id; })[0];\r\n    if (obj == null) {\r\n      obj = { _id: id };\r\n      this._itemUpdates.push(obj);\r\n    }\r\n\r\n    obj[key] = value;\r\n    this._updateItems();\r\n  }\r\n\r\n  async _render(...args) {\r\n    // Trick to avoid error on elements with changing name\r\n    let focus = this.element.find(":focus");\r\n    focus = focus.length ? focus[0] : null;\r\n    if (focus && focus.name.match(/^data\\.skills\\.(?:[a-zA-Z0-9]*)\\.name$/)) focus.blur();\r\n\r\n    return super._render(...args);\r\n  }\r\n\r\n  async _onSubmit(event, {updateData=null, preventClose=false}={}) {\r\n    event.preventDefault();\r\n    await this._updateItems();\r\n\r\n    return super._onSubmit(event, {updateData, preventClose});\r\n  }\r\n\r\n  async _updateItems() {\r\n    let promises = [];\r\n\r\n    const updates = duplicate(this._itemUpdates);\r\n    this._itemUpdates = [];\r\n\r\n    for (const data of updates) {\r\n      const item = this.actor.items.filter(o => { return o._id === data._id; })[0];\r\n      if (item == null) continue;\r\n\r\n      delete data._id;\r\n      if (item.hasPerm(game.user, "OWNER")) promises.push(item.update(data));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  async _onDrop(event) {\r\n    event.preventDefault();\r\n\r\n    // Try to extract the data\r\n    let data;\r\n    try {\r\n      data = JSON.parse(event.dataTransfer.getData(\'text/plain\'));\r\n      if (data.type !== "Item") return;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n\r\n    let itemData = {};\r\n    let dataType = "";\r\n\r\n    // Case 1 - Import from a Compendium pack\r\n    const actor = this.actor;\r\n    if (data.pack) {\r\n      dataType = "compendium";\r\n      const pack = game.packs.find(p => p.collection === data.pack);\r\n      const packItem = await pack.getEntity(data.id);\r\n      if (packItem != null) itemData = packItem.data;\r\n    }\r\n\r\n    // Case 2 - Data explicitly provided\r\n    else if (data.data) {\r\n      let sameActor = data.actorId === actor._id;\r\n      if (sameActor && actor.isToken) sameActor = data.tokenId === actor.token.id;\r\n      if (sameActor) return this._onSortItem(event, data.data); // Sort existing items\r\n\r\n      dataType = "data";\r\n      itemData = data.data;\r\n    }\r\n\r\n    // Case 3 - Import from World entity\r\n    else {\r\n      dataType = "world";\r\n      itemData = game.items.get(data.id).data;\r\n    }\r\n\r\n    return this.importItem(mergeObject(itemData, this.getDropData(itemData), { inplace: false }), dataType);\r\n  }\r\n\r\n  getDropData(origData) {\r\n    let result = {};\r\n\r\n    // Set spellbook for spell\r\n    if (getProperty(origData, "type") === "spell") setProperty(result, "data.spellbook", this.currentSpellbookKey);\r\n\r\n    return result;\r\n  }\r\n\r\n  async importItem(itemData, dataType) {\r\n    if (itemData.type === "spell" && this.currentPrimaryTab === "inventory") {\r\n      return this.actor._createConsumableSpellDialog(itemData);\r\n    }\r\n\r\n    if (itemData._id) delete itemData._id;\r\n    return this.actor.createEmbeddedEntity("OwnedItem", itemData);\r\n  }\r\n\r\n  async _onConfigControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n    const f = $(a).attr("for");\r\n    const html = this.element;\r\n\r\n    $(a).css("display", "none");\r\n\r\n    // Show CR field\r\n    if (f === "cr") {\r\n      const elem = html.find(\'input[for="data.details.cr"]\');\r\n      elem.attr("value", _lib_js__WEBPACK_IMPORTED_MODULE_5__["CR"].fromNumber(this.actor.data.data.details.cr.base));\r\n      elem.attr("name", "data.details.cr.base");\r\n      elem.prop("disabled", false);\r\n      elem.focus();\r\n      elem.select();\r\n    }\r\n\r\n    // Show base Spell Slots field\r\n    else if (f === "spellSlots") {\r\n      const elem = $(a).closest(".spell-uses").find(".base");\r\n      elem.css("display", "block");\r\n      elem.focus();\r\n      elem.select();\r\n    }\r\n  }\r\n\r\n  async _updateObject(event, formData) {\r\n    // Translate CR\r\n    const cr = formData["data.details.cr.base"];\r\n    if (typeof cr === "string") formData["data.details.cr.base"] = _lib_js__WEBPACK_IMPORTED_MODULE_5__["CR"].fromString(cr);\r\n\r\n    return super._updateObject(event, formData);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/actor/sheets/base.js?')},"./module/actor/sheets/character.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFCharacter", function() { return ActorSheetPFCharacter; });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./module/actor/sheets/base.js");\n\r\n\r\n\r\n/**\r\n * An Actor sheet for player character type actors in the PF system.\r\n * Extends the base ActorSheetPF class.\r\n * @type {ActorSheetPF}\r\n */\r\nclass ActorSheetPFCharacter extends _base_js__WEBPACK_IMPORTED_MODULE_0__["ActorSheetPF"] {\r\n\r\n  /**\r\n   * Define default rendering options for the NPC sheet\r\n   * @return {Object}\r\n   */\r\n\tstatic get defaultOptions() {\r\n\t  return mergeObject(super.defaultOptions, {\r\n      classes: ["pf1", "sheet", "actor", "character"],\r\n      width: 720,\r\n      height: 840\r\n    });\r\n  }\r\n\r\n  static get name() {\r\n    return game.i18n.localize("PF1.ActorSheetPFCharacter");\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Rendering                                   */\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Get the correct HTML template path to use for rendering this particular sheet\r\n   * @type {String}\r\n   */\r\n  get template() {\r\n    if ( !game.user.isGM && this.actor.limited ) return "systems/pf1/templates/actors/limited-sheet.html";\r\n    return "systems/pf1/templates/actors/character-sheet.html";\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.\r\n   */\r\n  getData() {\r\n    const data = super.getData();\r\n    const xpSettings = game.settings.get("pf1", "experienceConfig");\r\n\r\n    // Experience Tracking\r\n    data["disableExperience"] = xpSettings.disableExperienceTracking;\r\n\r\n    data.hasClasses = this.actor.items.filter(o => o.type === "class").length > 0;\r\n\r\n    // Return data for rendering\r\n    return data;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Event Listeners and Handlers\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Activate event listeners using the prepared sheet HTML\r\n   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM\r\n   */\r\n\tactivateListeners(html) {\r\n    super.activateListeners(html);\r\n    if ( !this.options.editable ) return;\r\n\r\n    // Inventory Functions\r\n    html.find(".currency-convert").click(this._onConvertCurrency.bind(this));\r\n\r\n    // Spell Preparation\r\n    html.find(\'.toggle-prepared\').click(this._onPrepareItem.bind(this));\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle toggling the prepared status of an Owned Item within the Actor\r\n   * @param {Event} event   The triggering click event\r\n   * @private\r\n   */\r\n  _onPrepareItem(event) {\r\n    event.preventDefault();\r\n    const itemId = event.currentTarget.closest(".item").dataset.itemId;\r\n    const item = this.actor.getOwnedItem(itemId);\r\n    return item.update({"data.preparation.prepared": !item.data.data.preparation.prepared});\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  async _onConvertCurrency(event) {\r\n    event.preventDefault();\r\n    const curr = duplicate(this.actor.data.data.currency);\r\n    const convert = {\r\n      cp: {into: "sp", each: 10},\r\n      sp: {into: "gp", each: 10 },\r\n      gp: {into: "pp", each: 10 }\r\n    };\r\n    for ( let [c, t] of Object.entries(convert) ) {\r\n      let change = Math.floor(curr[c] / t.each);\r\n      curr[c] -= (change * t.each);\r\n      curr[t.into] += change;\r\n    }\r\n    return this.actor.update({"data.currency": curr});\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/actor/sheets/character.js?')},"./module/actor/sheets/npc-lite.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPCLite", function() { return ActorSheetPFNPCLite; });\n/* harmony import */ var _npc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./npc.js */ "./module/actor/sheets/npc.js");\n\n\nclass ActorSheetPFNPCLite extends _npc_js__WEBPACK_IMPORTED_MODULE_0__["ActorSheetPFNPC"] {\n\n  /**\n   * Define default rendering options for the NPC sheet\n   * @return {Object}\n   */\n\tstatic get defaultOptions() {\n\t  return mergeObject(super.defaultOptions, {\n      classes: ["pf1", "sheet", "actor", "npc", "lite"],\n      width: 440,\n      height: 200,\n    });\n  }\n    \n  get template() {\n    if ( !game.user.isGM && this.actor.limited ) return "systems/pf1/templates/actors/limited-sheet.html";\n    return "systems/pf1/templates/actors/npc-sheet-lite.html";\n  }\n\n  static get name() {\n    return game.i18n.localize("PF1.ActorSheetPFNPCLite");\n  }\n}\n\n//# sourceURL=webpack://pf1/./module/actor/sheets/npc-lite.js?')},"./module/actor/sheets/npc-loot.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPCLoot", function() { return ActorSheetPFNPCLoot; });\n/* harmony import */ var _npc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./npc.js */ "./module/actor/sheets/npc.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib.js */ "./module/lib.js");\n\n\n\nclass ActorSheetPFNPCLoot extends _npc_js__WEBPACK_IMPORTED_MODULE_0__["ActorSheetPFNPC"] {\n\n  /**\n   * Define default rendering options for the NPC sheet\n   * @return {Object}\n   */\n\tstatic get defaultOptions() {\n\t  return mergeObject(super.defaultOptions, {\n      classes: ["pf1", "sheet", "actor", "npc", "loot"],\n      width: 560,\n      height: 420,\n    });\n  }\n    \n  get template() {\n    return "systems/pf1/templates/actors/npc-sheet-loot.html";\n  }\n\n  static get name() {\n    return game.i18n.localize("PF1.ActorSheetPFNPCLoot");\n  }\n\n  getData() {\n    const data = super.getData();\n\n    data.isLootSheet = true;\n\n    // Get total value\n    const gpValue = this.calculateTotalItemValue() + this.actor.mergeCurrency();\n    const sellValue = this.calculateSellItemValue() + this.actor.mergeCurrency();\n    data.totalValue = {\n      gp: Math.floor(gpValue),\n      sp: Math.floor(gpValue*10 - Math.floor(gpValue)*10),\n      cp: Math.floor(Math.floor(gpValue*100 - Math.floor(gpValue)*100) - (Math.floor(gpValue*10 - Math.floor(gpValue)*10)*10)),\n    };\n    data.sellValue = {\n      gp: Math.floor(sellValue),\n      sp: Math.floor(sellValue*10 - Math.floor(sellValue)*10),\n      cp: Math.floor(Math.floor(sellValue*100 - Math.floor(sellValue)*100) - (Math.floor(sellValue*10 - Math.floor(sellValue)*10)*10)),\n    };\n    \n    // Set labels\n    if (!data.labels) data.labels = {};\n    data.labels.totalValue = game.i18n.localize("PF1.ItemContainerTotalValue").format(data.totalValue.gp, data.totalValue.sp, data.totalValue.cp);\n    data.labels.sellValue = game.i18n.localize("PF1.ItemContainerSellValue").format(data.sellValue.gp, data.sellValue.sp, data.sellValue.cp);\n\n    // Alter inventory columns\n    for (let inv of data.inventory) {\n      inv.hasActions = false;\n      inv.canEquip = false;\n      inv.showValue = true;\n    }\n\n    return data;\n  }\n\n  calculateTotalItemValue() {\n    const items = this.actor.items;\n    return Math.floor(items.reduce((cur, i) => {\n      return cur + (i.data.data.price * i.data.data.quantity);\n    }, 0) * 100) / 100;\n  }\n\n  calculateSellItemValue() {\n    const items = this.actor.items;\n    return Math.floor(items.reduce((cur, i) => {\n      if (i.data.type === "loot" && i.data.data.subType === "tradeGoods") return cur + (i.data.data.price * i.data.data.quantity);\n      return cur + (i.data.data.price * i.data.data.quantity) * 0.5;\n    }, 0) * 100) / 100;\n  }\n\n  createTabs(html) {\n    const tabGroups = {\n      "inventory": {},\n    };\n    _lib_js__WEBPACK_IMPORTED_MODULE_1__["createTabs"].call(this, html, tabGroups);\n  }\n}\n\n//# sourceURL=webpack://pf1/./module/actor/sheets/npc-loot.js?')},"./module/actor/sheets/npc.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPC", function() { return ActorSheetPFNPC; });\n/* harmony import */ var _sheets_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sheets/base.js */ "./module/actor/sheets/base.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib.js */ "./module/lib.js");\n\n\n\n/**\n * An Actor sheet for NPC type characters in the D&D5E system.\n * Extends the base ActorSheetPF class.\n * @type {ActorSheetPF}\n */\nclass ActorSheetPFNPC extends _sheets_base_js__WEBPACK_IMPORTED_MODULE_0__["ActorSheetPF"] {\n\n  /**\n   * Define default rendering options for the NPC sheet\n   * @return {Object}\n   */\n\tstatic get defaultOptions() {\n\t  return mergeObject(super.defaultOptions, {\n      classes: ["pf1", "sheet", "actor", "npc"],\n      width: 720,\n      height: 800\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /**\n   * Get the correct HTML template path to use for rendering this particular sheet\n   * @type {String}\n   */\n  get template() {\n    if ( !game.user.isGM && this.actor.limited ) return "systems/pf1/templates/actors/limited-sheet.html";\n    return "systems/pf1/templates/actors/npc-sheet.html";\n  }\n\n  static get name() {\n    return game.i18n.localize("PF1.ActorSheetPFNPC");\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.\n   */\n  getData() {\n    const data = super.getData();\n\n    // Challenge Rating\n    try {\n      data.labels.cr = _lib_js__WEBPACK_IMPORTED_MODULE_1__["CR"].fromNumber(getProperty(this.actor.data, "data.details.cr.total"));\n    }\n    catch (e) {\n      try {\n        data.labels.cr = _lib_js__WEBPACK_IMPORTED_MODULE_1__["CR"].fromNumber(getProperty(this.actor.data, "data.details.cr"));\n      }\n      catch (e) {\n        data.labels.cr = _lib_js__WEBPACK_IMPORTED_MODULE_1__["CR"].fromNumber(1);\n      }\n    }\n    return data;\n  }\n\n  /* -------------------------------------------- */\n  /*  Object Updates                              */\n  /* -------------------------------------------- */\n\n  /**\n   * This method is called upon form submission after form data is validated\n   * @param event {Event}       The initial triggering submission event\n   * @param formData {Object}   The object of validated form data with which to update the object\n   * @private\n   */\n  async _updateObject(event, formData) {\n\n    // Parent ActorSheet update steps\n    super._updateObject(event, formData);\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /**\n   * Activate event listeners using the prepared sheet HTML\n   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM\n   */\n\tactivateListeners(html) {\n    super.activateListeners(html);\n\n    // Rollable Health Formula\n    html.find(".health .rollable").click(this._onRollHealthFormula.bind(this));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Handle rolling NPC health values using the provided formula\n   * @param {Event} event     The original click event\n   * @private\n   */\n  _onRollHealthFormula(event) {\n    event.preventDefault();\n    const formula = this.actor.data.data.attributes.hp.formula;\n    if ( !formula ) return;\n    const hp = new Roll(formula).roll().total;\n    AudioHelper.play({src: CONFIG.sounds.dice});\n    this.actor.update({"data.attributes.hp.value": hp, "data.attributes.hp.max": hp});\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/actor/sheets/npc.js?')},"./module/apps/actor-flags.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorSheetFlags", function() { return ActorSheetFlags; });\nclass ActorSheetFlags extends BaseEntitySheet {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    return mergeObject(options, {\n      id: "actor-flags",\n      classes: ["pf1"],\n      template: "systems/pf1/templates/apps/actor-flags.html",\n      width: 500,\n      closeOnSubmit: true\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Configure the title of the special traits selection window to include the Actor name\n   * @type {String}\n   */\n  get title() {\n    return `${game.i18n.localize(\'PF1.FlagsTitle\')}: ${this.object.name}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Prepare data used to render the special Actor traits selection UI\n   * @return {Object}\n   */\n  getData() {\n    const data = super.getData();\n    data.flags = this._getFlags();\n    return data;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Prepare an object of flags data which groups flags by section\n   * Add some additional data for rendering\n   * @return {Object}\n   */\n  _getFlags() {\n    const flags = {};\n    for ( let [k, v] of Object.entries(CONFIG.PF1.characterFlags) ) {\n      if ( !flags.hasOwnProperty(v.section) ) flags[v.section] = {};\n      let flag = duplicate(v);\n      flag.type = v.type.name;\n      flag.isCheckbox = v.type === Boolean;\n      flag.isSelect = v.hasOwnProperty(\'choices\');\n      flag.value = this.entity.getFlag("PF1", k);\n      flags[v.section][k] = flag;\n    }\n    return flags;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Update the Actor using the configured flags\n   * Remove/unset any flags which are no longer configured\n   */\n  _updateObject(event, formData) {\n    const actor = this.object;\n\n    // Iterate over the flags which may be configured\n    const updateData = {};\n    for ( let [k, v] of Object.entries(CONFIG.pf1.characterFlags) ) {\n      if ( [undefined, null, "", false].includes(formData[k]) ) updateData[`-=${k}`] = null;\n      else if ( (v.type === Number) && (formData[k] === 0) ) updateData[`-=${k}`] = null;\n      else updateData[k] = formData[k];\n    }\n\n    // Set the new flags in bulk\n    actor.update({\'flags.pf1\': updateData});\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/apps/actor-flags.js?')},"./module/apps/actor-rest.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorRestDialog", function() { return ActorRestDialog; });\nclass ActorRestDialog extends BaseEntitySheet {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    return mergeObject(options, {\n      id: "actor-flags",\n      classes: ["pf1", "actor-rest"],\n      template: "systems/pf1/templates/apps/actor-rest.html",\n      width: 500,\n      closeOnSubmit: true\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Configure the title of the special traits selection window to include the Actor name\n   * @type {String}\n   */\n  get title() {\n    return `${game.i18n.localize(\'PF1.Rest\')}: ${this.object.name}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Update the Actor using the configured options\n   * Remove/unset any flags which are no longer configured\n   */\n  _updateObject(event, formData) {\n    const actor = this.object;\n    const actorData = actor.data.data;\n\n    const updateData = {};\n    // Restore health and ability damage\n    if (formData["restoreHealth"] === true) {\n      const hd = actorData.attributes.hd.total;\n      let heal = {\n        hp: hd,\n        abl: 1,\n      };\n      if (formData["longTermCare"] === true) {\n        heal.hp *= 2;\n        heal.abl *= 2;\n      }\n\n      updateData["data.attributes.hp.value"] = Math.min(actorData.attributes.hp.value + heal.hp, actorData.attributes.hp.max);\n      for (let [key, abl] of Object.entries(actorData.abilities)) {\n        let dmg = Math.abs(abl.damage);\n        updateData[`data.abilities.${key}.damage`] = Math.max(0, dmg - heal.abl);\n      }\n    }\n\n    // Restore daily uses of spells, feats, etc.\n    if (formData["restoreDailyUses"] === true) {\n      let items = [],\n        hasItemUpdates = false;\n      for (let a = 0; a < actor.data.items.length; a++) {\n        let item = actor.data.items[a];\n        items[a] = item;\n        let itemUpdate = {};\n        const itemData = item.data;\n\n        if (itemData.uses && itemData.uses.per === "day" && itemData.uses.value !== itemData.uses.max) {\n          hasItemUpdates = true;\n          itemUpdate["data.uses.value"] = itemData.uses.max;\n        }\n        else if (item.type === "spell") {\n          const spellbook = getProperty(actorData, `attributes.spells.spellbooks.${itemData.spellbook}`),\n            isSpontaneous = spellbook.spontaneous;\n          if (!isSpontaneous && itemData.preparation.preparedAmount < itemData.preparation.maxAmount) {\n            hasItemUpdates = true;\n            itemUpdate["data.preparation.preparedAmount"] = itemData.preparation.maxAmount;\n          }\n        }\n\n        items[a] = mergeObject(item, itemUpdate, { enforceTypes: false, inplace: false });\n      }\n      if (hasItemUpdates) updateData.items = items;\n\n      // Restore spontaneous spellbooks\n      for (let [key, spellbook] of Object.entries(actorData.attributes.spells.spellbooks)) {\n        if (spellbook.spontaneous) {\n          for (let sl of Object.keys(CONFIG.PF1.spellLevels)) {\n            updateData[`data.attributes.spells.spellbooks.${key}.spells.spell${sl}.value`] = getProperty(actorData, `attributes.spells.spellbooks.${key}.spells.spell${sl}.max`);\n          }\n        }\n      }\n    }\n\n    actor.update(updateData);\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/apps/actor-rest.js?')},"./module/apps/compendium-browser.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompendiumBrowser", function() { return CompendiumBrowser; });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib.js */ "./module/lib.js");\n\r\n\r\nclass CompendiumBrowser extends Application {\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    this.items = [];\r\n\r\n    this.filters = [];\r\n\r\n    this.activeFilters = {};\r\n\r\n    this._data = {\r\n      loaded: false,\r\n      data: {},\r\n      promise: null,\r\n    };\r\n\r\n    // Preload compendiums\r\n    if (game.settings.get("pf1", "preloadCompendiums") === true) {\r\n      this.loadData();\r\n    }\r\n  }\r\n\r\n  loadData() {\r\n    return new Promise(resolve => {\r\n      let promise = this._data.promise;\r\n      if (promise == null) {\r\n        promise = this._gatherData();\r\n        this._data.promise = promise;\r\n      }\r\n\r\n      promise.then(() => {\r\n        this._data.loaded = true;\r\n        this._data.promise = null;\r\n        resolve(this._data.data);\r\n      });\r\n    });\r\n  }\r\n\r\n  async _gatherData() {\r\n    await this._fetchMetadata();\r\n\r\n    this._data.data = {\r\n      filters: this.filters,\r\n      collection: this.items,\r\n    };\r\n  }\r\n\r\n  static get defaultOptions() {\r\n    return mergeObject(super.defaultOptions, {\r\n      template: "systems/pf1/templates/apps/compendium-browser.html",\r\n      width: 720,\r\n      height: window.innerHeight - 60,\r\n      top: 30,\r\n      left: 40,\r\n    });\r\n  }\r\n\r\n  get typeName() {\r\n    switch (this.type) {\r\n      case "spells":\r\n        return game.i18n.localize("PF1.Spells");\r\n      case "items":\r\n        return game.i18n.localize("PF1.Items");\r\n      case "feats":\r\n        return game.i18n.localize("PF1.Features");\r\n      case "bestiary":\r\n        return game.i18n.localize("PF1.Creatures");\r\n      case "classes":\r\n        return game.i18n.localize("PF1.ItemTypeClass");\r\n    }\r\n    return this.type;\r\n  }\r\n\r\n  get type() {\r\n    return this.options.type;\r\n  }\r\n\r\n  get title() {\r\n    return [this.typeName, "Browser"].join(" ");\r\n  }\r\n\r\n  get entityType() {\r\n    return this.options.entityType;\r\n  }\r\n\r\n  _onProgress(progress) {\r\n    progress.loaded++;\r\n    progress.pct = Math.round(progress.loaded * 10 / progress.total) * 10;\r\n    SceneNavigation._onLoadProgress(progress.message, progress.pct);\r\n  }\r\n\r\n  async _fetchMetadata() {\r\n    this.items = [];\r\n\r\n    // Initialize progress bar\r\n    const progress = { pct: 0, message: game.i18n.localize("PF1.LoadingCompendiumBrowser"), loaded: -1, total: game.packs.size };\r\n    this._onProgress(progress);\r\n\r\n    // Load compendiums\r\n    for (let p of game.packs.values()) {\r\n      if (p.private && !game.user.isGM) {\r\n        this._onProgress(progress);\r\n        continue;\r\n      }\r\n      if (p.entity !== this.entityType) {\r\n        this._onProgress(progress);\r\n        continue;\r\n      }\r\n\r\n      const items = await p.getContent();\r\n      for (let i of items) {\r\n        if (!this._filterItems(i)) continue;\r\n        this.items.push(this._mapItem(p, i));\r\n      }\r\n      this._onProgress(progress);\r\n    }\r\n\r\n    // Sort items\r\n    this.items.sort((a, b) => {\r\n      if (a.item.name < b.item.name) return -1;\r\n      if (a.item.name > b.item.name) return 1;\r\n      return 0;\r\n    });\r\n\r\n    // Return if no appropriate items were found\r\n    if (this.items.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Gather filter data\r\n    switch (this.type) {\r\n      case "spells":\r\n        this._fetchSpellFilters();\r\n        break;\r\n      case "items":\r\n        this._fetchItemFilters();\r\n        break;\r\n      case "bestiary":\r\n        this._fetchBestiaryFilters();\r\n        break;\r\n      case "feats":\r\n        this._fetchFeatFilters();\r\n        break;\r\n      case "classes":\r\n        this._fetchClassFilters();\r\n        break;\r\n    }\r\n\r\n    this.activeFilters = this.filters.reduce((cur, f) => {\r\n      cur[f.path] = [];\r\n      return cur;\r\n    }, {});\r\n  }\r\n\r\n  _filterItems(item) {\r\n    if (this.type === "spells" && item.type !== "spell") return false;\r\n    if (this.type === "items" && !["weapon", "equipment", "loot", "consumable"].includes(item.type)) return false;\r\n    if (this.type === "feats" && item.type !== "feat") return false;\r\n    if (this.type === "classes" && item.type !== "class") return false;\r\n    return true;\r\n  }\r\n\r\n  _mapItem(pack, item) {\r\n    const result = {\r\n      collection: pack.collection,\r\n      item: {\r\n        _id: item._id,\r\n        name: item.name,\r\n        type: item.type,\r\n        img: item.img,\r\n        data: item.data.data,\r\n      },\r\n    };\r\n\r\n    // Feat-specific variables\r\n    if (this.type === "feats") {\r\n      if (!this.extraFilters) {\r\n        this.extraFilters = {\r\n          "tags": [],\r\n          "associations": {\r\n            "class": [],\r\n          },\r\n        };\r\n      }\r\n\r\n      result.item.tags = (getProperty(item.data, "data.tags") || []).reduce((cur, o) => {\r\n        if (!this.extraFilters["tags"].includes(o[0])) this.extraFilters["tags"].push(o[0]);\r\n        cur.push(o[0]);\r\n        return cur;\r\n      }, []);\r\n\r\n      result.item.assocations = {\r\n        "class": (getProperty(item.data, "data.featType") === "classFeat" ? getProperty(item.data, "data.associations.classes") || [] : []).reduce((cur, o) => {\r\n          if (!this.extraFilters.associations["class"].includes(o[0])) this.extraFilters.associations["class"].push(o[0]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n      };\r\n    }\r\n\r\n    // Item-specific variables\r\n    if (this.type === "items") {\r\n      if (!this.extraFilters) {\r\n        this.extraFilters = {};\r\n      }\r\n\r\n      result.item.weaponProps = Object.entries(getProperty(item.data, "data.properties") || []).reduce((cur, o) => {\r\n        if (o[1]) cur.push(o[0]);\r\n        return cur;\r\n      }, []);\r\n    }\r\n\r\n    // Spell-specific variables\r\n    if (this.type === "spells") {\r\n      if (!this.extraFilters) {\r\n        this.extraFilters = {\r\n          "learnedAt.class": [],\r\n          "learnedAt.domain": [],\r\n          "learnedAt.subDomain": [],\r\n          "learnedAt.elementalSchool": [],\r\n          "learnedAt.bloodline": [],\r\n          "data.subschool": [],\r\n          "spellTypes": [],\r\n        };\r\n      }\r\n\r\n      result.item.allSpellLevels = [];\r\n\r\n      // Add class/domain/etc filters\r\n      result.item.learnedAt = {\r\n        "class": (getProperty(item.data, "data.learnedAt.class") || []).reduce((cur, o) => {\r\n          if (!this.extraFilters["learnedAt.class"].includes(o[0])) this.extraFilters["learnedAt.class"].push(o[0]);\r\n          if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n        "domain": (getProperty(item.data, "data.learnedAt.domain") || []).reduce((cur, o) => {\r\n          if (!this.extraFilters["learnedAt.domain"].includes(o[0])) this.extraFilters["learnedAt.domain"].push(o[0]);\r\n          if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n        "subDomain": (getProperty(item.data, "data.learnedAt.subDomain") || []).reduce((cur, o) => {\r\n          if (!this.extraFilters["learnedAt.subDomain"].includes(o[0])) this.extraFilters["learnedAt.subDomain"].push(o[0]);\r\n          if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n        "elementalSchool": (getProperty(item.data, "data.learnedAt.elementalSchool") || []).reduce((cur, o) => {\r\n          if (!this.extraFilters["learnedAt.elementalSchool"].includes(o[0])) this.extraFilters["learnedAt.elementalSchool"].push(o[0]);\r\n          if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n        "bloodline": (getProperty(item.data, "data.learnedAt.bloodline") || []).reduce((cur, o) => {\r\n          if (!this.extraFilters["learnedAt.bloodline"].includes(o[0])) this.extraFilters["learnedAt.bloodline"].push(o[0]);\r\n          if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);\r\n          cur.push(o[0]);\r\n          return cur;\r\n        }, []),\r\n        "spellLevel": {\r\n          "class": (getProperty(item.data, "data.learnedAt.class") || []).reduce((cur, o) => {\r\n            cur[o[0]] = o[1];\r\n            return cur;\r\n          }, {}),\r\n          "domain": (getProperty(item.data, "data.learnedAt.domain") || []).reduce((cur, o) => {\r\n            cur[o[0]] = o[1];\r\n            return cur;\r\n          }, {}),\r\n          "subDomain": (getProperty(item.data, "data.learnedAt.subDomain") || []).reduce((cur, o) => {\r\n            cur[o[0]] = o[1];\r\n            return cur;\r\n          }, {}),\r\n          "elementalSchool": (getProperty(item.data, "data.learnedAt.elementalSchool") || []).reduce((cur, o) => {\r\n            cur[o[0]] = o[1];\r\n            return cur;\r\n          }, {}),\r\n          "bloodline": (getProperty(item.data, "data.learnedAt.bloodline") || []).reduce((cur, o) => {\r\n            cur[o[0]] = o[1];\r\n            return cur;\r\n          }, {}),\r\n        },\r\n      };\r\n\r\n      // Add subschools\r\n      {\r\n        const subschool = getProperty(item.data, "data.subschool");\r\n        if (subschool && !this.extraFilters["data.subschool"].includes(subschool)) this.extraFilters["data.subschool"].push(subschool);\r\n      }\r\n      // Add spell types\r\n      {\r\n        const spellTypes = getProperty(item.data, "data.types") ? getProperty(item.data, "data.types").split(CONFIG.PF1.re.traitSeparator) : []\r\n        result.item.spellTypes = spellTypes;\r\n        for (let st of spellTypes) {\r\n          if (!this.extraFilters["spellTypes"].includes(st)) this.extraFilters["spellTypes"].push(st);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Bestiary-specific variables\r\n    if (this.type === "bestiary") {\r\n      if (!this.extraFilters) {\r\n        this.extraFilters = {\r\n          "data.details.cr.total": [],\r\n          "subTypes": [],\r\n        };\r\n      }\r\n      result.item.creatureType = "";\r\n      result.item.subTypes = [];\r\n\r\n      // Add CR filters\r\n      if (item.data.type === "npc") {\r\n        const cr = getProperty(item.data, "data.details.cr.total");\r\n        if (cr && !this.extraFilters["data.details.cr.total"].includes(cr)) this.extraFilters["data.details.cr.total"].push(cr);\r\n      }\r\n      // Get creature (sub)type\r\n      const race = item.race;\r\n      if (race != null) {\r\n        result.item.creatureType = getProperty(race.data, "data.creatureType");\r\n        result.item.subTypes = getProperty(race.data, "data.subTypes").map(o => {\r\n          if (!this.extraFilters["subTypes"].includes(o[0])) this.extraFilters["subTypes"].push(o[0]);\r\n          return o[0];\r\n        });\r\n      }\r\n    }\r\n\r\n    // Class-specific filters\r\n    if (this.type === "classes") {\r\n      if (!this.extraFilters) {\r\n        this.extraFilters = {\r\n          "data.hd": [],\r\n          "data.skillsPerLevel": [],\r\n        };\r\n      }\r\n\r\n      // Add HD\r\n      {\r\n        const hd = item.data.data.hd;\r\n        if (hd && !this.extraFilters["data.hd"].includes(hd)) this.extraFilters["data.hd"].push(hd);\r\n      }\r\n      // Add skills per level\r\n      {\r\n        const s = item.data.data.skillsPerLevel;\r\n        if (s && !this.extraFilters["data.skillsPerLevel"].includes(s)) this.extraFilters["data.skillsPerLevel"].push(s);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getData() {\r\n    if (!this._data.loaded) await this.loadData();\r\n\r\n    return this._data.data;\r\n  }\r\n\r\n  async refresh() {\r\n    await this.loadData();\r\n    this.render(false);\r\n  }\r\n\r\n  _fetchSpellFilters() {\r\n    this.filters = [\r\n      {\r\n        path: "data.school",\r\n        label: game.i18n.localize("PF1.SpellSchool"),\r\n        items: Object.entries(CONFIG.PF1.spellSchools).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "data.subschool",\r\n        label: game.i18n.localize("PF1.SubSchool"),\r\n        items: this.extraFilters["data.subschool"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "spellTypes",\r\n        label: game.i18n.localize("PF1.TypePlural"),\r\n        items: this.extraFilters["spellTypes"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "learnedAt.class",\r\n        label: game.i18n.localize("PF1.ClassPlural"),\r\n        items: this.extraFilters["learnedAt.class"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "learnedAt.domain",\r\n        label: game.i18n.localize("PF1.Domain"),\r\n        items: this.extraFilters["learnedAt.domain"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "learnedAt.subDomain",\r\n        label: game.i18n.localize("PF1.SubDomain"),\r\n        items: this.extraFilters["learnedAt.subDomain"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      // {\r\n      //   path: "learnedAt.elementalSchool",\r\n      //   label: game.i18n.localize("PF1.ElementalSchool"),\r\n      //   items: this.extraFilters["learnedAt.elementalSchool"].reduce((cur, o) => {\r\n      //     cur.push({ key: o, name: o });\r\n      //     return cur;\r\n      //   }, []),\r\n      // },\r\n      {\r\n        path: "learnedAt.bloodline",\r\n        label: game.i18n.localize("PF1.Bloodline"),\r\n        items: this.extraFilters["learnedAt.bloodline"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "_spellLevel",\r\n        label: game.i18n.localize("PF1.SpellLevel"),\r\n        items: Object.entries(CONFIG.PF1.spellLevels).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n    ];\r\n  }\r\n\r\n  _fetchItemFilters() {\r\n    this.filters = [\r\n      {\r\n        path: "type",\r\n        label: game.i18n.localize("PF1.Type"),\r\n        items: [\r\n          { key: "weapon", name: game.i18n.localize("PF1.ItemTypeWeapon") },\r\n          { key: "equipment", name: game.i18n.localize("PF1.ItemTypeEquipment") },\r\n          { key: "consumable", name: game.i18n.localize("PF1.ItemTypeConsumable") },\r\n          { key: "loot", name: game.i18n.localize("PF1.Misc") },\r\n        ],\r\n      },\r\n      {\r\n        path: "data.weaponType",\r\n        label: game.i18n.localize("PF1.WeaponType"),\r\n        items: Object.entries(CONFIG.PF1.weaponTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1]._label });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.weaponSubtype",\r\n        label: game.i18n.localize("PF1.WeaponSubtype"),\r\n        items: Object.values(CONFIG.PF1.weaponTypes).reduce((cur, o) => {\r\n          cur = cur.concat((Object.entries(o).filter(i => !i[0].startsWith("_")).reduce((arr, i) => {\r\n            if (!cur.filter(a => a.key === i[0]).length) {\r\n              arr.push({ key: i[0], name: i[1] });\r\n            }\r\n            return arr;\r\n          }, [])));\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "weaponProps",\r\n        label: game.i18n.localize("PF1.WeaponProperties"),\r\n        items: Object.entries(CONFIG.PF1.weaponProperties).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.equipmentType",\r\n        label: game.i18n.localize("PF1.EquipmentType"),\r\n        items: Object.entries(CONFIG.PF1.equipmentTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1]._label });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.equipmentSubtype",\r\n        label: game.i18n.localize("PF1.EquipmentSubtype"),\r\n        items: Object.values(CONFIG.PF1.equipmentTypes).reduce((cur, o) => {\r\n          cur = cur.concat((Object.entries(o).filter(i => !i[0].startsWith("_")).reduce((arr, i) => {\r\n            if (!cur.filter(a => a.key === i[0]).length) {\r\n              arr.push({ key: i[0], name: i[1] });\r\n            }\r\n            return arr;\r\n          }, [])));\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.slot",\r\n        label: game.i18n.localize("PF1.Slot"),\r\n        items: Object.values(CONFIG.PF1.equipmentSlots).reduce((cur, o) => {\r\n          cur = cur.concat((Object.entries(o).filter(i => !i[0].startsWith("_")).reduce((arr, i) => {\r\n            if (!cur.filter(a => a.key === i[0]).length) {\r\n              arr.push({ key: i[0], name: i[1] });\r\n            }\r\n            return arr;\r\n          }, [])));\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.consumableType",\r\n        label: game.i18n.localize("PF1.ConsumableType"),\r\n        items: Object.entries(CONFIG.PF1.consumableTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.subType",\r\n        label: game.i18n.localize("PF1.Misc"),\r\n        items: Object.entries(CONFIG.PF1.lootTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n    ];\r\n  }\r\n\r\n  _fetchBestiaryFilters() {\r\n    this.filters = [\r\n      {\r\n        path: "data.details.cr.total",\r\n        label: "CR",\r\n        items: this.extraFilters["data.details.cr.total"].sort().reduce((cur, o) => {\r\n          cur.push({ key: o, name: _lib_js__WEBPACK_IMPORTED_MODULE_0__["CR"].fromNumber(o) });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "creatureType",\r\n        label: game.i18n.localize("PF1.CreatureType"),\r\n        items: Object.entries(CONFIG.PF1.creatureTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "subTypes",\r\n        label: game.i18n.localize("PF1.RaceSubtypePlural"),\r\n        items: this.extraFilters["subTypes"].sort().reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []),\r\n      },\r\n    ];\r\n  }\r\n\r\n  _fetchFeatFilters() {\r\n    this.filters = [\r\n      {\r\n        path: "data.featType",\r\n        label: game.i18n.localize("PF1.Type"),\r\n        items: Object.entries(CONFIG.PF1.featTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "tags",\r\n        label: game.i18n.localize("PF1.Tags"),\r\n        items: this.extraFilters.tags.reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n      {\r\n        path: "assocations.class",\r\n        label: game.i18n.localize("PF1.ClassPlural"),\r\n        items: this.extraFilters.associations["class"].reduce((cur, o) => {\r\n          cur.push({ key: o, name: o });\r\n          return cur;\r\n        }, []).sort((a, b) => {\r\n          if (a.name > b.name) return 1;\r\n          if (a.name < b.name) return -1;\r\n          return 0;\r\n        }),\r\n      },\r\n    ];\r\n  }\r\n\r\n  _fetchClassFilters() {\r\n    this.filters = [\r\n      {\r\n        path: "data.classType",\r\n        label: game.i18n.localize("PF1.ClassType"),\r\n        items: Object.entries(CONFIG.PF1.classTypes).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.hd",\r\n        label: game.i18n.localize("PF1.HitDie"),\r\n        items: this.extraFilters["data.hd"].reduce((cur, o) => {\r\n          cur.push({ key: o.toString(), name: o.toString() });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.bab",\r\n        label: game.i18n.localize("PF1.BAB"),\r\n        items: Object.entries(CONFIG.PF1.classBAB).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.skillsPerLevel",\r\n        label: game.i18n.localize("PF1.SkillsPerLevel"),\r\n        items: this.extraFilters["data.skillsPerLevel"].reduce((cur, o) => {\r\n          cur.push({ key: o.toString(), name: o.toString() });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.savingThrows.fort.value",\r\n        label: game.i18n.localize("PF1.SavingThrowFort"),\r\n        items: Object.entries(CONFIG.PF1.classSavingThrows).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.savingThrows.ref.value",\r\n        label: game.i18n.localize("PF1.SavingThrowRef"),\r\n        items: Object.entries(CONFIG.PF1.classSavingThrows).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n      {\r\n        path: "data.savingThrows.will.value",\r\n        label: game.i18n.localize("PF1.SavingThrowWill"),\r\n        items: Object.entries(CONFIG.PF1.classSavingThrows).reduce((cur, o) => {\r\n          cur.push({ key: o[0], name: o[1] });\r\n          return cur;\r\n        }, []),\r\n      },\r\n    ];\r\n  }\r\n\r\n  async _render(...args) {\r\n    await super._render(...args);\r\n\r\n    this.filterQuery = /.*/;\r\n    this.element.find(".filter-content").css("display", "none");\r\n  }\r\n\r\n  activateListeners(html) {\r\n    super.activateListeners(html);\r\n\r\n    // Open sheets\r\n    html.find(\'.entry-name\').click(ev => {\r\n      let li = ev.currentTarget.parentElement;\r\n      this._onEntry(li.getAttribute("data-collection"), li.getAttribute("data-entry-id"));\r\n    });\r\n\r\n    // Make compendium items draggable\r\n    html.find(\'.directory-item\').each((i, li) => {\r\n      li.setAttribute("draggable", true);\r\n      li.addEventListener(\'dragstart\', this._onDragStart, false);\r\n    });\r\n\r\n    html.find(\'input[name="search"]\').keyup(this._onFilterResults.bind(this));\r\n\r\n    html.find(\'.filter input[type="checkbox"]\').change(this._onActivateBooleanFilter.bind(this));\r\n\r\n    html.find(\'.filter h3\').click(this._toggleFilterVisibility.bind(this));\r\n\r\n    html.find("button.refresh").click(this.refresh.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Handle opening a single compendium entry by invoking the configured entity class and its sheet\r\n   * @private\r\n   */\r\n  async _onEntry(collectionKey, entryId) {\r\n    const pack = game.packs.find(o => o.collection === collectionKey);\r\n    const entity = await pack.getEntity(entryId);\r\n    entity.sheet.render(true);\r\n  }\r\n\r\n  /**\r\n   * Handle a new drag event from the compendium, create a placeholder token for dropping the item\r\n   * @private\r\n   */\r\n  _onDragStart(event) {\r\n    const li = this,\r\n          packName = li.getAttribute("data-collection"),\r\n          pack = game.packs.find(p => p.collection === packName);\r\n\r\n    // Get the pack\r\n    if (!pack) {\r\n      event.preventDefault();\r\n      return false;\r\n    }\r\n\r\n    // Set the transfer data\r\n    event.dataTransfer.setData("text/plain", JSON.stringify({\r\n      type: pack.entity,\r\n      pack: pack.collection,\r\n      id: li.getAttribute("data-entry-id")\r\n    }));\r\n  }\r\n\r\n  _toggleFilterVisibility(event) {\r\n    event.preventDefault();\r\n    const title = event.currentTarget;\r\n    const content = $(title).siblings(".filter-content")[0];\r\n\r\n    if (content.style.display === "none") content.style.display = "block";\r\n    else content.style.display = "none";\r\n  }\r\n\r\n  _onFilterResults(event) {\r\n    event.preventDefault();\r\n    let input = event.currentTarget;\r\n\r\n    // Define filtering function\r\n    let filter = query => {\r\n      this.filterQuery = query;\r\n      this._filterResults();\r\n    };\r\n\r\n    // Filter if we are done entering keys\r\n    let query = new RegExp(RegExp.escape(input.value), "i");\r\n    if (this._filterTimeout) {\r\n      clearTimeout(this._filterTimeout);\r\n      this._filterTimeout = null;\r\n    }\r\n    this._filterTimeout = setTimeout(() => filter(query), 100);\r\n  }\r\n\r\n  _onActivateBooleanFilter(event) {\r\n    event.preventDefault();\r\n    let input = event.currentTarget;\r\n    const path = input.closest(".filter").dataset.path;\r\n    const key = input.name;\r\n    const value = input.checked;\r\n\r\n    if (value) {\r\n      let index = this.activeFilters[path].indexOf(key);\r\n      if (index < 0) this.activeFilters[path].push(key);\r\n    }\r\n    else {\r\n      let index = this.activeFilters[path].indexOf(key);\r\n      if (index >= 0) this.activeFilters[path].splice(index, 1);\r\n    }\r\n\r\n    this._filterResults();\r\n  }\r\n\r\n  _filterResults() {\r\n    this.element.find("li.directory-item").each((a, li) => {\r\n      const id = li.dataset.entryId;\r\n      let item = this.items.find(i => i.item._id === id).item;\r\n      li.style.display = this._passesFilters(item) ? "flex" : "none";\r\n    });\r\n  }\r\n\r\n  _passesFilters(item) {\r\n    if (!this.filterQuery.test(item.name)) return false;\r\n\r\n    for (let [path, filter] of Object.entries(this.activeFilters)) {\r\n      if (filter.length === 0) continue;\r\n\r\n      // Handle special cases\r\n      // Handle Spell Level\r\n      {\r\n        let result = null;\r\n        if (this.type === "spells" && path === "_spellLevel") {\r\n          result = false;\r\n          let hasActiveFilter = false;\r\n          const spellLevels = this.activeFilters[path];\r\n          const checks = [\r\n            { path: "learnedAt.class", type: "class" },\r\n            { path: "learnedAt.domain", type: "domain" },\r\n            { path: "learnedAt.subDomain", type: "subDomain" },\r\n            { path: "learnedAt.elementalSchool", type: "elementalSchool" },\r\n            { path: "learnedAt.bloodline", type: "bloodline" },\r\n          ];\r\n          for (let c of checks) {\r\n            const f = this.activeFilters[c.path];\r\n            if (!f || !f.length) continue;\r\n            hasActiveFilter = true;\r\n            for (let fi of f) {\r\n              const p = getProperty(item, `learnedAt.spellLevel.${c.type}`);\r\n              for (let sl of spellLevels) {\r\n                if (p[fi] === parseInt(sl)) result = true;\r\n              }\r\n            }\r\n          }\r\n          if (!hasActiveFilter) {\r\n            for (let sl of spellLevels) {\r\n              if (item.allSpellLevels.includes(parseInt(sl))) result = true;\r\n            }\r\n          }\r\n        }\r\n        if (result === false) return false;\r\n        else if (result === true) continue;\r\n      }\r\n\r\n      // Handle the rest\r\n      const prop = getProperty(item, path);\r\n      if (prop == null) return false;\r\n      if (typeof prop === "number") {\r\n        filter = filter.map(o => parseFloat(o)).filter(o => !isNaN(o));\r\n      }\r\n      if (prop instanceof Array) {\r\n        if (!filter.every(o => prop.includes(o))) return false;\r\n        continue;\r\n      }\r\n      if (!filter.includes(prop)) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/apps/compendium-browser.js?')},"./module/apps/entry-selector.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntrySelector", function() { return EntrySelector; });\nclass EntrySelector extends FormApplication {\n  constructor(...args) {\n    super(...args);\n\n    this.entries = duplicate(getProperty(this.object.data, this.attribute) || []);\n  }\n\n  static get defaultOptions() {\n    return mergeObject(super.defaultOptions, {\n      id: "entry-selector",\n      classes: ["pf1", "entry"],\n      title: "Entry Selector",\n      template: "systems/pf1/templates/apps/entry-selector.html",\n      width: 320,\n      height: "auto",\n      closeOnSubmit: false,\n      submitOnClose: false,\n    });\n  }\n\n  get attribute() {\n    return this.options.name;\n  }\n\n  get fields() {\n    return this.options.fields.split(";");\n  }\n\n  get dtypes() {\n    return this.options.dtypes.split(";");\n  }\n\n  get dataCount() {\n    return this.fields.length;\n  }\n\n  getData() {\n    const entries = this.entries.map(o => {\n      return o.map((o2, a) => {\n        return [o2, this.dtypes[a]];\n      });\n    });\n\n    return {\n      entries: entries,\n      fields: this.fields,\n    };\n  }\n\n  activateListeners(html) {\n    html.find(".entry-control").click(this._onEntryControl.bind(this));\n\n    html.find(\'tr td input[type="text"]\').change(this._onEntryChange.bind(this));\n\n    html.find(\'button[type="submit"]\').click(this._submitAndClose.bind(this));\n  }\n\n  async _updateObject(event, formData) {\n    const updateData = {};\n    \n    updateData[this.attribute] = this.entries;\n\n    return this.object.update(updateData);\n  }\n\n  async _onEntryControl(event) {\n    event.preventDefault();\n    const a = event.currentTarget;\n\n    if (a.classList.contains("add-entry")) {\n      let obj = [];\n      for (let a = 0; a < this.dataCount; a++) {\n        let dataType = this.dtypes[a];\n        if (dataType === "Number") obj.push(0);\n        else obj.push("");\n      }\n      this.entries.push(obj);\n      this._render(false);\n    }\n\n    if (a.classList.contains("delete-entry")) {\n      const tr = a.closest("tr");\n      const index = parseInt(tr.dataset.index);\n      this.entries.splice(index, 1);\n      this._render(false);\n    }\n  }\n\n  async _onEntryChange(event) {\n    const a = event.currentTarget;\n\n    const tr = a.closest("tr.entry");\n    const index = parseInt(tr.dataset.index);\n    const index2 = parseInt(a.dataset.index);\n    const value = a.value;\n\n    if (a.dataset.dtype === "Number") {\n      let v = parseFloat(value);\n      if (isNaN(v)) v = 0;\n      this.entries[index][index2] = Math.floor(v * 100) / 100;\n    }\n    else this.entries[index][index2] = value;\n  }\n\n  async _submitAndClose(event) {\n    event.preventDefault();\n    await this._onSubmit(event);\n    this.close();\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/apps/entry-selector.js?')},"./module/apps/point-buy-calculator.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointBuyCalculator", function() { return PointBuyCalculator; });\nclass PointBuyCalculator extends FormApplication {\n\n  constructor(...args) {\n    super(...args);\n\n    this.abilities = [];\n    for (let [k, name] of Object.entries(CONFIG.PF1.abilities)) {\n      this.abilities.push({\n        key: k,\n        name: name,\n        value: 10,\n      });\n    }\n  }\n\n  static get defaultOptions() {\n    return mergeObject(super.defaultOptions, {\n      id: "pointbuy-calculator",\n      classes: ["pf1", "pointbuy-calculator"],\n      title: "Point Buy Calculator",\n      template: "systems/pf1/templates/apps/pointbuy-calculator.html",\n      width: 320,\n      height: "auto",\n      closeOnSubmit: false,\n      submitOnClose: false,\n    });\n  }\n\n  get actor() {\n    return this.object.actor;\n  }\n\n  getData() {\n    const points = this.getSpentPoints();\n\n    return {\n      abilities: this.abilities,\n      points: points,\n    };\n  }\n\n  getSpentPoints() {\n    let result = 0;\n\n    for (let a of this.abilities) {\n      result += CONFIG.PF1.abilityCost[a.value];\n    }\n    return result;\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    html.find(".ability-control").click(this._onAbilityControl.bind(this));\n  }\n\n  _onAbilityControl(event) {\n    event.preventDefault();\n    const a = event.currentTarget;\n    const ablKey = a.closest(".item").dataset.ability;\n    const abl = this.abilities.find(o => o.key === ablKey);\n\n    if (a.classList.contains("add")) {\n      abl.value = Math.min(18, abl.value + 1);\n    }\n    else if (a.classList.contains("subtract")) {\n      abl.value = Math.max(7, abl.value - 1);\n    }\n    this.render();\n  }\n\n  _updateObject() {\n    const updateData = {};\n    for (let a of this.abilities) {\n      updateData[`data.abilities.${a.key}.value`] = a.value;\n    }\n    this.actor.update(updateData);\n\n    this.close();\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/apps/point-buy-calculator.js?')},"./module/apps/trait-selector.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActorTraitSelector", function() { return ActorTraitSelector; });\n/**\n * A specialized form used to select damage or condition types which apply to an Actor\n * @type {FormApplication}\n */\nclass ActorTraitSelector extends FormApplication {\n\tstatic get defaultOptions() {\n\t  const options = super.defaultOptions;\n\t  options.id = "trait-selector";\n\t  options.classes = ["pf1"];\n\t  options.title = "Actor Trait Selection";\n\t  options.template = "systems/pf1/templates/apps/trait-selector.html";\n\t  options.width = 320;\n\t  options.height = "auto";\n\t  return options;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Return a reference to the target attribute\n   * @type {String}\n   */\n  get attribute() {\n\t  return this.options.name;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Provide data to the HTML template for rendering\n   * @type {Object}\n   */\n  getData() {\n\n    // Get current values\n    let attr = getProperty(this.object.data, this.attribute);\n\n\t  // Populate choices\n    const choices = duplicate(this.options.choices);\n    for ( let [k, v] of Object.entries(choices) ) {\n      choices[k] = {\n        label: v,\n        chosen: attr.value.includes(k)\n      }\n    }\n\n    // Return data\n\t  return {\n\t    choices: choices,\n      custom: attr.custom\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * Update the Actor object with new trait data processed from the form\n   * @private\n   */\n  _updateObject(event, formData) {\n    const choices = [];\n    for ( let [k, v] of Object.entries(formData) ) {\n      if ( (k !== "custom") && v ) choices.push(k);\n    }\n    this.object.update({\n      [`${this.attribute}.value`]: choices,\n      [`${this.attribute}.custom`]: formData.custom\n    });\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/apps/trait-selector.js?')},"./module/canvas.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureDistances", function() { return measureDistances; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureDistance", function() { return measureDistance; });\n/**\n * Measure the distance between two pixel coordinates\n * See BaseGrid.measureDistance for more details\n */\nconst measureDistances = function(segments, options={}) {\n  if ( !options.gridSpaces ) return BaseGrid.prototype.measureDistances.call(this, segments, options);\n\n  // Track the total number of diagonals\n  let nDiagonal = 0;\n  const rule = this.parent.diagonalRule;\n  const d = canvas.dimensions;\n\n  // Iterate over measured segments\n  return segments.map(s => {\n    let r = s.ray;\n\n    // Determine the total distance traveled\n    let nx = Math.abs(Math.ceil(r.dx / d.size));\n    let ny = Math.abs(Math.ceil(r.dy / d.size));\n\n    // Determine the number of straight and diagonal moves\n    let nd = Math.min(nx, ny);\n    let ns = Math.abs(ny - nx);\n    nDiagonal += nd;\n\n    // Alternative DMG Movement\n    if (rule === "5105") {\n      let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);\n      let spaces = (nd10 * 2) + (nd - nd10) + ns;\n      return spaces * canvas.dimensions.distance;\n    }\n\n    // Standard PHB Movement\n    else return (ns + nd) * canvas.scene.data.gridDistance;\n  });\n};\n\nconst measureDistance = function(p0, p1, {gridSpaces=true}={}) {\n  if ( !gridSpaces ) return BaseGrid.prototype.measureDistance.bind(this)(p0, p1, {gridSpaces});\n  let gs = canvas.dimensions.size,\n      ray = new Ray(p0, p1),\n      nx = Math.abs(Math.ceil(ray.dx / gs)),\n      ny = Math.abs(Math.ceil(ray.dy / gs));\n\n  // Get the number of straight and diagonal moves\n  let nDiagonal = Math.min(nx, ny),\n      nStraight = Math.abs(ny - nx);\n\n  // Alternative DMG Movement\n  if ( this.parent.diagonalRule === "5105" ) {\n    let nd10 = Math.floor(nDiagonal / 2);\n    let spaces = (nd10 * 2) + (nDiagonal - nd10) + nStraight;\n    return spaces * canvas.dimensions.distance;\n  }\n\n  // Standard PHB Movement\n  else return (nStraight + nDiagonal) * canvas.scene.data.gridDistance;\n};\n\n/* -------------------------------------------- */\n\n/**\n * Hijack Token health bar rendering to include temporary and temp-max health in the bar display\n * TODO: This should probably be replaced with a formal Token class extension\n */\nconst _TokenGetBarAttribute = Token.prototype.getBarAttribute;\nToken.prototype.getBarAttribute = function(barName, {alternative=null}={}) {\n  let data;\n  try {\n    data = _TokenGetBarAttribute.call(this, barName, {alternative: alternative});\n  } catch (e) {\n    data = null;\n  }\n  if (data != null && data.attribute === "attributes.hp") {\n    data.value += parseInt(data[\'temp\'] || 0);\n  }\n  return data;\n};\n\nTokenHUD.prototype._onAttributeUpdate = function(event) {\n  // Filter keydown events for Enter\n  if ( event.type === "keydown" ) {\n    if (event.keyCode === KEYS.ENTER) this.clear();\n    return;\n  }\n  event.preventDefault();\n\n  // Determine new bar value\n  let input = event.currentTarget,\n      strVal = input.value.trim(),\n      isDelta = strVal.startsWith("+") || strVal.startsWith("-"),\n      value = Number(strVal);\n  if ( !Number.isFinite(value) ) return;\n\n  // For attribute bar values, update the associated Actor\n  let bar = input.dataset.bar;\n  if ( bar ) {\n    const actor = this.object.actor;\n    const data = this.object.getBarAttribute(bar);\n    const current = getProperty(actor.data.data, data.attribute);\n    const updateData = {};\n    let dt = value;\n    if (data.attribute === "attributes.hp" && actor.data.data.attributes.hp.temp > 0 && isDelta && value < 0) {\n      dt = Math.min(0, actor.data.data.attributes.hp.temp + value);\n      updateData["data.attributes.hp.temp"] = Math.max(0, actor.data.data.attributes.hp.temp + value);\n      value = Math.min(0, value - dt);\n    }\n    if ( isDelta ) value = Math.clamped(current.min || 0, current.value + dt, current.max);\n    updateData[`data.${data.attribute}.value`] = value;\n    actor.update(updateData);\n  }\n\n  // Otherwise update the Token\n  else this.object.update({[input.name]: value});\n};\n\n\n//# sourceURL=webpack://pf1/./module/canvas.js?')},"./module/chat.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCustomChatMessage", function() { return createCustomChatMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideRollInfo", function() { return hideRollInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideGMSensitiveInfo", function() { return hideGMSensitiveInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addChatCardTitleGradient", function() { return addChatCardTitleGradient; });\n/* harmony import */ var _item_entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item/entity.js */ "./module/item/entity.js");\n/* harmony import */ var _sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sidebar/chat-message.js */ "./module/sidebar/chat-message.js");\n\r\n\r\nconst Color = __webpack_require__(/*! color */ "./node_modules/color/index.js");\r\n\r\n/* -------------------------------------------- */\r\n\r\nconst createCustomChatMessage = async function(chatTemplate, chatTemplateData={}, chatData={}, {rolls=[]}={}) {\r\n  let rollMode = game.settings.get("core", "rollMode");\r\n  chatData = mergeObject({\r\n    rollMode: rollMode,\r\n    user: game.user._id,\r\n    type: CONST.CHAT_MESSAGE_TYPES.CHAT,\r\n  }, chatData);\r\n  chatData.content = await renderTemplate(chatTemplate, chatTemplateData);\r\n  // Handle different roll modes\r\n  switch (chatData.rollMode) {\r\n    case "gmroll":\r\n      chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n      break;\r\n    case "selfroll":\r\n      chatData["whisper"] = [game.user._id];\r\n      break;\r\n    case "blindroll":\r\n      chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n      chatData["blind"] = true;\r\n      break;\r\n  }\r\n\r\n  // Dice So Nice integration\r\n  if (chatData.roll != null && rolls.length === 0) rolls = [chatData.roll];\r\n  if (game.dice3d != null && game.dice3d.isEnabled()) {\r\n    for (let roll of rolls) {\r\n      await game.dice3d.showForRoll(roll, game.user, false, chatData.whisper, chatData.blind);\r\n      chatData.sound = null;\r\n    }\r\n  }\r\n\r\n  _sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_1__["ChatMessagePF"].create(chatData);\r\n};\r\n\r\nconst hideRollInfo = function(app, html, data) {\r\n  const whisper = app.data.whisper || [];\r\n  const isBlind = whisper.length && app.data.blind;\r\n  const isVisible = whisper.length ? (whisper.includes(game.user._id) || (app.isAuthor && !isBlind)) : true;\r\n  if (!isVisible) {\r\n    html.find(".dice-formula").text("???");\r\n    html.find(".dice-total").text("?");\r\n    html.find(".dice").text("");\r\n    html.find(".success").removeClass("success");\r\n    html.find(".failure").removeClass("failure");\r\n  }\r\n};\r\n\r\nconst hideGMSensitiveInfo = function(app, html, data) {\r\n  if (game.user.isGM) return;\r\n\r\n  let speaker = app.data.speaker,\r\n    actor = speaker != null ? (speaker.token ? game.actors.tokens[speaker.token] : game.actors.get(speaker.actor)) : null;\r\n  if (!actor || (actor && actor.hasPerm(game.user, "LIMITED"))) return;\r\n\r\n  // Hide info\r\n  html.find(".gm-sensitive").remove();\r\n};\r\n\r\nconst addChatCardTitleGradient = function(app, html, data) {\r\n  const card = html.find(".chat-card")[0];\r\n  if (!card) return;\r\n  const actor = _item_entity_js__WEBPACK_IMPORTED_MODULE_0__["ItemPF"]._getChatCardActor(card);\r\n  if (!actor) return;\r\n  const item = actor.getOwnedItem(card.dataset.itemId);\r\n  if (!item) return;\r\n  const title = $(card).find(".card-header");\r\n  if (!title.length) return;\r\n\r\n  title.css("background-image", `linear-gradient(to right, ${item.typeColor}, ${item.typeColor2})`);\r\n\r\n  const titleText = title.find("h2, h3");\r\n  if (Color(item.typeColor).isLight()) titleText.css("color", "black");\r\n  else titleText.css("color", "white");\r\n};\r\n\n\n//# sourceURL=webpack://pf1/./module/chat.js?')},"./module/combat.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getInitiativeFormula", function() { return _getInitiativeFormula; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_rollInitiative", function() { return _rollInitiative; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addChatMessageContextOptions", function() { return addChatMessageContextOptions; });\n/* harmony import */ var _actor_entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor/entity.js */ "./module/actor/entity.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib.js */ "./module/lib.js");\n\n\n\n/* -------------------------------------------- */\n\n/**\n * Override the default Initiative formula to customize special behaviors of the D&D5e system.\n * Apply advantage, proficiency, or bonuses where appropriate\n * Apply the dexterity score as a decimal tiebreaker if requested\n * See Combat._getInitiativeFormula for more detail.\n */\nconst _getInitiativeFormula = function(actor) {\n  if (!actor) return "1d20";\n  const parts = ["1d20", "@attributes.init.total", "@attributes.init.total / 100"];\n  return parts.filter(p => p !== null).join(" + ");\n};\n\nCombat.showInitiativeDialog = function(formula=null) {\n  return new Promise(resolve => {\n    let template = "systems/pf1/templates/chat/roll-dialog.html";\n    let rollMode = game.settings.get("core", "rollMode");\n    let dialogData = {\n      formula: formula ? formula : "",\n      rollMode: rollMode,\n      rollModes: CONFIG.Dice.rollModes\n    };\n    // Create buttons object\n    let buttons = {\n      normal: {\n        label: "Roll",\n        callback: html => {\n          rollMode = html.find(\'[name="rollMode"]\').val();\n          const bonus = html.find(\'[name="bonus"]\').val();\n          resolve({ rollMode: rollMode, bonus: bonus });\n        },\n      }\n    };\n    // Show dialog\n    renderTemplate(template, dialogData).then(dlg => {\n      new Dialog({\n        title: game.i18n.localize("PF1.InitiativeBonus"),\n        content: dlg,\n        buttons: buttons,\n        default: "normal",\n        close: html => {\n          resolve({ stop: true });\n        }\n      }, {}).render(true);\n    });\n  });\n};\n\nconst _rollInitiative = async function(ids, formula=null, messageOptions={}) {\n\n  // Structure input data\n  ids = typeof ids === "string" ? [ids] : ids;\n  const currentId = this.combatant._id;\n  if (!formula) formula = _getInitiativeFormula(this.combatant.actor);\n\n  let overrideRollMode = null,\n    bonus = "",\n    stop = false;\n  if (keyboard.isDown("Shift")) {\n    const dialogData = await Combat.showInitiativeDialog(formula);\n    overrideRollMode = dialogData.rollMode;\n    bonus = dialogData.bonus || "";\n    stop = dialogData.stop || false;\n  }\n\n  if (stop) return this;\n\n  // Iterate over Combatants, performing an initiative roll for each\n  const [updates, messages] = ids.reduce((results, id, i) => {\n    let [updates, messages] = results;\n\n    // Get Combatant data\n    const c = this.getCombatant(id);\n    if ( !c ) return results;\n    const actorData = c.actor ? c.actor.data.data : {};\n    formula = formula || this._getInitiativeFormula(c.actor ? c.actor : null);\n\n    actorData.bonus = bonus;\n    // Add bonus\n    if (bonus.length > 0 && i === 0) {\n      formula += " + @bonus";\n    }\n\n    // Roll initiative\n    const rollMode = overrideRollMode != null ? overrideRollMode : messageOptions.rollMode || (c.token.hidden || c.hidden) ? "gmroll" : "roll";\n    const roll = new Roll(formula, actorData).roll();\n    updates.push({_id: id, initiative: roll.total});\n\n    // Construct chat message data\n    let messageData = mergeObject({\n      speaker: {\n        scene: canvas.scene._id,\n        actor: c.actor ? c.actor._id : null,\n        token: c.token._id,\n        alias: c.token.name\n      },\n      flavor: game.i18n.localize("PF1.RollsForInitiative").format(c.token.name)\n    }, messageOptions);\n    const chatData = roll.toMessage(messageData, {rollMode, create:false});\n    if ( i > 0 ) chatData.sound = null;   // Only play 1 sound for the whole set\n    messages.push(chatData);\n\n    // Return the Roll and the chat data\n    return results;\n  }, [[], []]);\n  if ( !updates.length ) return this;\n\n  // Update multiple combatants\n  await this.updateEmbeddedEntity("Combatant", updates);\n\n  // Ensure the turn order remains with the same combatant\n  await this.update({turn: this.turns.findIndex(t => t._id === currentId)});\n\n  // Create multiple chat messages\n  await ChatMessage.create(messages);\n\n  // Return the updated Combat\n  return this;\n};\n\n/* -------------------------------------------- */\n\n/**\n * This function is used to hook into the Chat Log context menu to add additional options to each message\n * These options make it easy to conveniently apply damage to controlled tokens based on the value of a Roll\n *\n * @param {HTMLElement} html    The Chat Message being rendered\n * @param {Array} options       The Array of Context Menu options\n *\n * @return {Array}              The extended options Array including new context choices\n */\nconst addChatMessageContextOptions = function(html, options) {\n  let canApply = li => canvas.tokens.controlled.length && li.find(".damage-roll .dice-total").length;\n  let canApplyCritical = li => canvas.tokens.controlled.length && li.find(".crit-damage-roll .dice-total").length;\n  options.push(\n    {\n      name: game.i18n.localize("PF1.ApplyDamage"),\n      icon: \'<i class="fas fa-user-minus"></i>\',\n      condition: canApply,\n      callback: li => _actor_entity_js__WEBPACK_IMPORTED_MODULE_0__["ActorPF"].applyDamage(li, 1)\n    },\n    {\n      name: game.i18n.localize("PF1.ApplyHealing"),\n      icon: \'<i class="fas fa-user-plus"></i>\',\n      condition: canApply,\n      callback: li => _actor_entity_js__WEBPACK_IMPORTED_MODULE_0__["ActorPF"].applyDamage(li, -1)\n    },\n    {\n      name: game.i18n.localize("PF1.ApplyCriticalDamage"),\n      icon: \'<i class="fas fa-user-minus"></i>\',\n      condition: canApplyCritical,\n      callback: li => _actor_entity_js__WEBPACK_IMPORTED_MODULE_0__["ActorPF"].applyDamage(li, 1, true)\n    },\n    {\n      name: game.i18n.localize("PF1.ApplyCriticalHealing"),\n      icon: \'<i class="fas fa-user-minus"></i>\',\n      condition: canApplyCritical,\n      callback: li => _actor_entity_js__WEBPACK_IMPORTED_MODULE_0__["ActorPF"].applyDamage(li, -1, true)\n    },\n  );\n  return options;\n};\n\n\n//# sourceURL=webpack://pf1/./module/combat.js?')},"./module/config.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PF1", function() { return PF1; });\n// Namespace D&D5e Configuration Values\r\nconst PF1 = {};\r\n\r\nPF1.re = {\r\n  "traitSeparator": /\\s*[,;]\\s*/g,\r\n};\r\n\r\n\r\n/**\r\n * The set of Ability Scores used within the system\r\n * @type {Object}\r\n */\r\nPF1.abilities = {\r\n  "str": "PF1.AbilityStr",\r\n  "dex": "PF1.AbilityDex",\r\n  "con": "PF1.AbilityCon",\r\n  "int": "PF1.AbilityInt",\r\n  "wis": "PF1.AbilityWis",\r\n  "cha": "PF1.AbilityCha"\r\n};\r\n\r\nPF1.abilitiesShort = {\r\n  "str": "PF1.AbilityShortStr",\r\n  "dex": "PF1.AbilityShortDex",\r\n  "con": "PF1.AbilityShortCon",\r\n  "int": "PF1.AbilityShortInt",\r\n  "wis": "PF1.AbilityShortWis",\r\n  "cha": "PF1.AbilityShortCha"\r\n};\r\n\r\nPF1.abilityCost = {\r\n  "7": -4,\r\n  "8": -2,\r\n  "9": -1,\r\n  "10": 0,\r\n  "11": 1,\r\n  "12": 2,\r\n  "13": 3,\r\n  "14": 5,\r\n  "15": 7,\r\n  "16": 10,\r\n  "17": 13,\r\n  "18": 17,\r\n};\r\n\r\n/**\r\n * The set of Saving Throws\r\n * @type {Object}\r\n */\r\nPF1.savingThrows = {\r\n  "fort": "PF1.SavingThrowFort",\r\n  "ref": "PF1.SavingThrowRef",\r\n  "will": "PF1.SavingThrowWill"\r\n};\r\n\r\nPF1.classTypes = {\r\n  "base": "PF1.ClassTypeBase",\r\n  "prestige": "PF1.ClassTypePrestige",\r\n  "racial": "PF1.ClassTypeRacial",\r\n};\r\n\r\nPF1.classBAB = {\r\n  "low": "PF1.Low",\r\n  "med": "PF1.Medium",\r\n  "high": "PF1.High",\r\n};\r\n\r\nPF1.classSavingThrows = {\r\n  "low": "PF1.Poor",\r\n  "high": "PF1.Good",\r\n};\r\n\r\nPF1.classBABFormulas = {\r\n  "low": "floor(@level * 0.5)",\r\n  "med": "floor(@level * 0.75)",\r\n  "high": "@level",\r\n};\r\n\r\nPF1.classSavingThrowFormulas = {\r\n  "base": {\r\n    "low": "floor(@level / 3)",\r\n    "high": "2 + floor(@level / 2)",\r\n  },\r\n  "prestige": {\r\n    "low": "floor((1 + @level) / 3)",\r\n    "high": "floor((1 + @level) / 2)",\r\n  },\r\n  "racial": {\r\n    "low": "floor(@level / 3)",\r\n    "high": "2 + floor(@level / 2)",\r\n  },\r\n};\r\n\r\nPF1.favouredClassBonuses = {\r\n  "hp": "PF1.FavouredClassHP",\r\n  "skill": "PF1.FavouredClassSkill",\r\n  "alt": "PF1.FavouredClassAlt",\r\n};\r\n\r\n/**\r\n * The set of Armor Classes\r\n * @type {Object}\r\n */\r\nPF1.ac = {\r\n  "normal": "PF1.ACNormal",\r\n  "touch": "PF1.ACTouch",\r\n  "flatFooted": "PF1.ACFlatFooted"\r\n};\r\n\r\n/**\r\n * The set of Armor Class modifier types\r\n * @type {Object}\r\n */\r\nPF1.acValueLabels = {\r\n  "normal": "PF1.ACTypeNormal",\r\n  "touch": "PF1.ACTypeTouch",\r\n  "flatFooted": "PF1.ACTypeFlatFooted"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Character alignment options\r\n * @type {Object}\r\n */\r\nPF1.alignments = {\r\n  \'lg\': "PF1.AlignmentLG",\r\n  \'ng\': "PF1.AlignmentNG",\r\n  \'cg\': "PF1.AlignmentCG",\r\n  \'ln\': "PF1.AlignmentLN",\r\n  \'tn\': "PF1.AlignmentTN",\r\n  \'cn\': "PF1.AlignmentCN",\r\n  \'le\': "PF1.AlignmentLE",\r\n  \'ne\': "PF1.AlignmentNE",\r\n  \'ce\': "PF1.AlignmentCE"\r\n};\r\n\r\nPF1.alignmentsShort = {\r\n  \'lg\': "LG",\r\n  \'ng\': "NG",\r\n  \'cg\': "CG",\r\n  \'ln\': "LN",\r\n  \'tn\': "N",\r\n  \'cn\': "CN",\r\n  \'le\': "LE",\r\n  \'ne\': "NE",\r\n  \'ce\': "CE"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * The set of Armor Proficiencies which a character may have\r\n * @type {Object}\r\n */\r\nPF1.armorProficiencies = {\r\n  "lgt": "PF1.ArmorProfLight",\r\n  "med": "PF1.ArmorProfMedium",\r\n  "hvy": "PF1.ArmorProfHeavy",\r\n  "shl": "PF1.ArmorProfShield",\r\n  "twr": "PF1.ArmorProfTowerShield",\r\n};\r\n\r\nPF1.weaponProficiencies = {\r\n  "sim": "PF1.WeaponProfSimple",\r\n  "mar": "PF1.WeaponProfMartial",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * This describes the ways that an ability can be activated\r\n * @type {Object}\r\n */\r\nPF1.abilityActivationTypes = {\r\n  "passive": "PF1.ActivationTypePassive",\r\n  "free": "PF1.ActivationTypeFree",\r\n  "swift": "PF1.ActivationTypeSwift",\r\n  "immediate": "PF1.ActivationTypeImmediate",\r\n  "move": "PF1.ActivationTypeMove",\r\n  "standard": "PF1.ActivationTypeStandard",\r\n  "full": "PF1.ActivationTypeFullround",\r\n  "attack": "PF1.ActivationTypeAttack",\r\n  "round": "PF1.ActivationTypeRound",\r\n  "minute": "PF1.ActivationTypeMinute",\r\n  "hour": "PF1.ActivationTypeHour",\r\n  "special": "PF1.ActivationTypeSpecial",\r\n};\r\n\r\n/**\r\n * This describes plurals for activation types.\r\n */\r\nPF1.abilityActivationTypesPlurals = {\r\n  "free": "PF1.ActivationTypeFreePlural",\r\n  "swift": "PF1.ActivationTypeSwiftPlural",\r\n  "immediate": "PF1.ActivationTypeImmediatePlural",\r\n  "move": "PF1.ActivationTypeMovePlural",\r\n  "standard": "PF1.ActivationTypeStandardPlural",\r\n  "full": "PF1.ActivationTypeFullroundPlural",\r\n  "attack": "PF1.ActivationTypeAttackPlural",\r\n  "round": "PF1.ActivationTypeRoundPlural",\r\n  "minute": "PF1.ActivationTypeMinutePlural",\r\n  "hour": "PF1.ActivationTypeHourPlural",\r\n};\r\n\r\nPF1.divineFocus = {\r\n  "0": "",\r\n  "1": "PF1.SpellComponentDivineFocusAlone",\r\n  "2": "PF1.SpellComponentDivineFocusMaterial",\r\n  "3": "PF1.SpellComponentDivineFocusFocus",\r\n};\r\n\r\nPF1.measureTemplateTypes = {\r\n  "cone": "PF1.MeasureTemplateCone",\r\n  "circle": "PF1.MeasureTemplateCircle",\r\n  "ray": "PF1.MeasureTemplateRay",\r\n  // "rect": "PF1.MeasureTemplateRectangle",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n// Creature Sizes\r\nPF1.actorSizes = {\r\n  "fine": "PF1.ActorSizeFine",\r\n  "dim": "PF1.ActorSizeDiminutive",\r\n  "tiny": "PF1.ActorSizeTiny",\r\n  "sm": "PF1.ActorSizeSmall",\r\n  "med": "PF1.ActorSizeMedium",\r\n  "lg": "PF1.ActorSizeLarge",\r\n  "huge": "PF1.ActorSizeHuge",\r\n  "grg": "PF1.ActorSizeGargantuan",\r\n  "col": "PF1.ActorSizeColossal",\r\n};\r\n\r\nPF1.sizeChart = {\r\n  "fine": "F",\r\n  "dim":  "D",\r\n  "tiny": "T",\r\n  "sm":   "S",\r\n  "med":  "M",\r\n  "lg":   "L",\r\n  "huge": "H",\r\n  "grg":  "G",\r\n  "col":  "C",\r\n};\r\n\r\nPF1.tokenSizes = {\r\n  "fine": { w: 1, h: 1, scale: 0.2 },\r\n  "dim": { w: 1, h: 1, scale: 0.4 },\r\n  "tiny": { w: 1, h: 1, scale: 0.6 },\r\n  "sm": { w: 1, h: 1, scale: 0.8 },\r\n  "med": { w: 1, h: 1, scale: 1 },\r\n  "lg": { w: 2, h: 2, scale: 1 },\r\n  "huge": { w: 3, h: 3, scale: 1 },\r\n  "grg": { w: 4, h: 4, scale: 1 },\r\n  "col": { w: 6, h: 6, scale: 1 },\r\n};\r\n\r\nPF1.sizeMods = {\r\n  "fine": 8,\r\n  "dim": 4,\r\n  "tiny": 2,\r\n  "sm": 1,\r\n  "med": 0,\r\n  "lg": -1,\r\n  "huge": -2,\r\n  "grg": -4,\r\n  "col": -8\r\n};\r\n\r\nPF1.sizeSpecialMods = {\r\n  "fine": -8,\r\n  "dim": -4,\r\n  "tiny": -2,\r\n  "sm": -1,\r\n  "med": 0,\r\n  "lg": 1,\r\n  "huge": 2,\r\n  "grg": 4,\r\n  "col": 8\r\n};\r\n\r\nPF1.sizeFlyMods = {\r\n  "fine": 8,\r\n  "dim": 6,\r\n  "tiny": 4,\r\n  "sm": 2,\r\n  "med": 0,\r\n  "lg": -2,\r\n  "huge": -4,\r\n  "grg": -6,\r\n  "col": -8\r\n};\r\n\r\nPF1.sizeStealthMods = {\r\n  "fine": 16,\r\n  "dim": 12,\r\n  "tiny": 8,\r\n  "sm": 4,\r\n  "med": 0,\r\n  "lg": -4,\r\n  "huge": -8,\r\n  "grg": -12,\r\n  "col": -16\r\n};\r\n\r\nPF1.flyManeuverabilities = {\r\n  "clumsy": "PF1.FlyManeuverabilityClumsy",\r\n  "poor": "PF1.FlyManeuverabilityPoor",\r\n  "average": "PF1.FlyManeuverabilityAverage",\r\n  "good": "PF1.FlyManeuverabilityGood",\r\n  "perfect": "PF1.FlyManeuverabilityPerfect",\r\n};\r\n\r\nPF1.flyManeuverabilityValues = {\r\n  "clumsy": -8,\r\n  "poor": -4,\r\n  "average": 0,\r\n  "good": 4,\r\n  "perfect": 8,\r\n};\r\n\r\nPF1.speedReduction = {\r\n  "5": 5,\r\n  "15": 10,\r\n  "20": 15,\r\n  "30": 20,\r\n  "35": 25,\r\n  "45": 30,\r\n  "50": 35,\r\n  "60": 40,\r\n  "65": 45,\r\n  "75": 50,\r\n  "80": 55,\r\n  "90": 60,\r\n  "95": 65,\r\n  "105": 70,\r\n  "110": 75,\r\n  "120": 80,\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nPF1.encumbranceLoads = [\r\n  0,\r\n  10, 20, 30, 40, 50, 60, 70, 80, 90, 100,\r\n  115, 130, 150, 175, 200, 230, 260, 300, 350,\r\n  400, 460, 520, 600, 700, 800, 920, 1040, 1200, 1400, 1600\r\n];\r\n\r\nPF1.encumbranceMultipliers = {\r\n  normal: {\r\n    fine: 0.125,\r\n    dim: 0.25,\r\n    tiny: 0.5,\r\n    sm: 0.75,\r\n    med: 1,\r\n    lg: 2,\r\n    huge: 4,\r\n    grg: 8,\r\n    col: 16,\r\n  },\r\n  quadruped: {\r\n    fine: 0.25,\r\n    dim: 0.5,\r\n    tiny: 0.75,\r\n    sm: 1,\r\n    med: 1.5,\r\n    lg: 3,\r\n    huge: 6,\r\n    grg: 12,\r\n    col: 24,\r\n  },\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Classification types for item action types\r\n * @type {Object}\r\n */\r\nPF1.itemActionTypes = {\r\n  "mwak": "PF1.ActionMWAK",\r\n  "rwak": "PF1.ActionRWAK",\r\n  "msak": "PF1.ActionMSAK",\r\n  "rsak": "PF1.ActionRSAK",\r\n  "spellsave": "PF1.ActionSpellSave",\r\n  "save": "PF1.ActionSave",\r\n  "heal": "PF1.ActionHeal",\r\n  "other": "PF1.ActionOther"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nPF1.itemCapacityTypes = {\r\n  "items": "PF1.ItemContainerCapacityItems",\r\n  "weight": "PF1.ItemContainerCapacityWeight"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Enumerate the lengths of time over which an item can have limited use ability\r\n * @type {Object}\r\n */\r\nPF1.limitedUsePeriods = {\r\n  "single": "PF1.LimitedUseSingle",\r\n  "unlimited": "PF1.Unlimited",\r\n  "day": "PF1.LimitedUseDay",\r\n  "week": "PF1.LimitedUseWeek",\r\n  "charges": "PF1.LimitedUseCharges",\r\n};\r\n\r\n\r\n/* -------------------------------------------- */\r\n\r\n// Equipment Types\r\nPF1.equipmentTypes = {\r\n  "armor": {\r\n    "_label": "PF1.EquipTypeArmor",\r\n    "lightArmor": "PF1.EquipTypeLight",\r\n    "mediumArmor": "PF1.EquipTypeMedium",\r\n    "heavyArmor": "PF1.EquipTypeHeavy",\r\n  },\r\n  "shield": {\r\n    "_label": "PF1.EquipTypeShield",\r\n    "lightShield": "PF1.EquipTypeLightShield",\r\n    "heavyShield": "PF1.EquipTypeHeavyShield",\r\n    "towerShield": "PF1.EquipTypeTowerShield",\r\n    "other": "PF1.EquipTypeOtherShield",\r\n  },\r\n  "misc": {\r\n    "_label": "PF1.Misc",\r\n    "wondrous": "PF1.EquipTypeWondrousItem",\r\n    "clothing": "PF1.EquipTypeClothing",\r\n    "other": "PF1.Other",\r\n  },\r\n};\r\n\r\nPF1.equipmentSlots = {\r\n  "armor": {\r\n    "armor": "PF1.EquipSlotArmor",\r\n  },\r\n  "shield": {\r\n    "shield": "PF1.EquipSlotShield",\r\n  },\r\n  "misc": {\r\n    "slotless": "PF1.EquipSlotSlotless",\r\n    "head": "PF1.EquipSlotHead",\r\n    "headband": "PF1.EquipSlotHeadband",\r\n    "eyes": "PF1.EquipSlotEyes",\r\n    "shoulders": "PF1.EquipSlotShoulders",\r\n    "neck": "PF1.EquipSlotNeck",\r\n    "chest": "PF1.EquipSlotChest",\r\n    "body": "PF1.EquipSlotBody",\r\n    "belt": "PF1.EquipSlotBelt",\r\n    "wrists": "PF1.EquipSlotWrists",\r\n    "hands": "PF1.EquipSlotHands",\r\n    "ring": "PF1.EquipSlotRing",\r\n    "feet": "PF1.EquipSlotFeet",\r\n  },\r\n};\r\n\r\nPF1.lootTypes = {\r\n  "gear": "PF1.LootTypeGear",\r\n  "ammo": "PF1.LootTypeAmmo",\r\n  "tradeGoods": "PF1.LootTypeTradeGoods",\r\n  "misc": "PF1.Misc",\r\n};\r\n\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Enumerate the valid consumable types which are recognized by the system\r\n * @type {Object}\r\n */\r\nPF1.consumableTypes = {\r\n  "potion": "PF1.ConsumableTypePotion",\r\n  "poison": "PF1.ConsumableTypePoison",\r\n  "drug": "PF1.ConsumableTypeDrug",\r\n  "scroll": "PF1.ConsumableTypeScroll",\r\n  "wand": "PF1.ConsumableTypeWand",\r\n  "staff": "PF1.ConsumableTypeStaff",\r\n  "misc": "PF1.Misc",\r\n};\r\n\r\nPF1.attackTypes = {\r\n  "weapon": "PF1.AttackTypeWeapon",\r\n  "natural": "PF1.AttackTypeNatural",\r\n  "ability": "PF1.AttackTypeAbility",\r\n  "racialAbility": "PF1.AttackTypeRacial",\r\n  "item": "PF1.Item",\r\n  "misc": "PF1.Misc",\r\n};\r\n\r\nPF1.featTypes = {\r\n  "feat": "PF1.FeatTypeFeat",\r\n  "classFeat": "PF1.FeatTypeClassFeat",\r\n  "trait": "PF1.FeatTypeTraits",\r\n  "racial": "PF1.FeatTypeRacial",\r\n  "misc": "PF1.Misc",\r\n  "template": "PF1.FeatTypeTemplate",\r\n};\r\n\r\nPF1.abilityTypes = {\r\n  "ex": {\r\n    "short": "Ex",\r\n    "long": "Extraordinary",\r\n  },\r\n  "su": {\r\n    "short": "Su",\r\n    "long": "Supernatural",\r\n  },\r\n  "sp": {\r\n    "short": "Sp",\r\n    "long": "Spell-Like",\r\n  },\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * The valid currency denominations supported by the 5e system\r\n * @type {Object}\r\n */\r\nPF1.currencies = {\r\n  "pp": "PF1.CurrencyPP",\r\n  "gp": "PF1.CurrencyGP",\r\n  "sp": "PF1.CurrencySP",\r\n  "cp": "PF1.CurrencyCP",\r\n};\r\n\r\nPF1.acTypes = {\r\n  "armor": "Armor",\r\n  "shield": "Shield",\r\n  "natural": "Natural Armor",\r\n};\r\n\r\nPF1.bonusModifiers = {\r\n  "untyped": "Untyped",\r\n  "base": "Base",\r\n  "enh": "Enhancement",\r\n  "dodge": "Dodge",\r\n  "inherent": "Inherent",\r\n  "deflection": "Deflection",\r\n  "morale": "Morale",\r\n  "luck": "Luck",\r\n  "sacred": "Sacred",\r\n  "insight": "Insight",\r\n  "resist": "Resistance",\r\n  "profane": "Profane",\r\n  "trait": "Trait",\r\n  "racial": "Racial",\r\n  "size": "Size",\r\n  "competence": "Competence",\r\n  "circumstance": "Circumstance",\r\n  "alchemical": "Alchemical",\r\n  "penalty": "Penalty",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n\r\n// Damage Types\r\nPF1.damageTypes = {\r\n  "bludgeoning": "Bludgeoning",\r\n  "piercing": "Piercing",\r\n  "slashing": "Slashing",\r\n  "cold": "Cold",\r\n  "fire": "Fire",\r\n  "electric": "Electricity",\r\n  "sonic": "Sonic",\r\n  "acid": "Acid",\r\n  "force": "Force",\r\n  "negative": "Negative",\r\n  "positive": "Positive",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nPF1.distanceUnits = {\r\n  "none": "PF1.None",\r\n  "personal": "PF1.DistPersonal",\r\n  "touch": "PF1.DistTouch",\r\n  "close": "PF1.DistClose",\r\n  "medium": "PF1.DistMedium",\r\n  "long": "PF1.DistLong",\r\n  "ft": "PF1.DistFt",\r\n  "mi": "PF1.DistMi",\r\n  "spec": "PF1.Special",\r\n  "seeText": "PF1.SeeText",\r\n  "unlimited": "PF1.Unlimited",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * This Object defines the types of single or area targets which can be applied in D&D5e\r\n * @type {Object}\r\n */\r\nPF1.targetTypes = {\r\n  "none": "PF1.None",\r\n  "self": "PF1.TargetSelf",\r\n  "creature": "PF1.TargetCreature",\r\n  "ally": "PF1.TargetAlly",\r\n  "enemy": "PF1.TargetEnemy",\r\n  "object": "PF1.TargetObject",\r\n  "space": "PF1.TargetSpace",\r\n  "radius": "PF1.TargetRadius",\r\n  "sphere": "PF1.TargetSphere",\r\n  "cylinder": "PF1.TargetCylinder",\r\n  "cone": "PF1.TargetCone",\r\n  "square": "PF1.TargetSquare",\r\n  "cube": "PF1.TargetCube",\r\n  "line": "PF1.TargetLine",\r\n  "wall": "PF1.TargetWall"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * This Object defines the various lengths of time which can occur in PF1\r\n * @type {Object}\r\n */\r\nPF1.timePeriods = {\r\n  "inst": "PF1.TimeInst",\r\n  "turn": "PF1.TimeTurn",\r\n  "round": "PF1.TimeRound",\r\n  "minute": "PF1.TimeMinute",\r\n  "hour": "PF1.TimeHour",\r\n  "day": "PF1.TimeDay",\r\n  "month": "PF1.TimeMonth",\r\n  "year": "PF1.TimeYear",\r\n  "perm": "PF1.TimePerm",\r\n  "seeText": "PF1.SeeText",\r\n  "spec": "PF1.Special",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n// Healing Types\r\nPF1.healingTypes = {\r\n  "healing": "PF1.Healing",\r\n  "temphp": "PF1.HealingTemp"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Character senses options\r\n * @type {Object}\r\n */\r\nPF1.senses = {\r\n  "bs": "PF1.SenseBS",\r\n  "dv": "PF1.SenseDV",\r\n  "ts": "PF1.SenseTS",\r\n  "tr": "PF1.SenseTR",\r\n  "ll": "PF1.SenseLL"\r\n};\r\n\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * The set of skill which can be trained in PF1\r\n * @type {Object}\r\n */\r\nPF1.skills = {\r\n  "acr": "PF1.SkillAcr",\r\n  "apr": "PF1.SkillApr",\r\n  "art": "PF1.SkillArt",\r\n  "blf": "PF1.SkillBlf",\r\n  "clm": "PF1.SkillClm",\r\n  "crf": "PF1.SkillCrf",\r\n  "dip": "PF1.SkillDip",\r\n  "dev": "PF1.SkillDev",\r\n  "dis": "PF1.SkillDis",\r\n  "esc": "PF1.SkillEsc",\r\n  "fly": "PF1.SkillFly",\r\n  "han": "PF1.SkillHan",\r\n  "hea": "PF1.SkillHea",\r\n  "int": "PF1.SkillInt",\r\n  "kar": "PF1.SkillKAr",\r\n  "kdu": "PF1.SkillKDu",\r\n  "ken": "PF1.SkillKEn",\r\n  "kge": "PF1.SkillKGe",\r\n  "khi": "PF1.SkillKHi",\r\n  "klo": "PF1.SkillKLo",\r\n  "kna": "PF1.SkillKNa",\r\n  "kno": "PF1.SkillKNo",\r\n  "kpl": "PF1.SkillKPl",\r\n  "kre": "PF1.SkillKRe",\r\n  "lin": "PF1.SkillLin",\r\n  "lor": "PF1.SkillLor",\r\n  "per": "PF1.SkillPer",\r\n  "prf": "PF1.SkillPrf",\r\n  "pro": "PF1.SkillPro",\r\n  "rid": "PF1.SkillRid",\r\n  "sen": "PF1.SkillSen",\r\n  "slt": "PF1.SkillSlt",\r\n  "spl": "PF1.SkillSpl",\r\n  "ste": "PF1.SkillSte",\r\n  "sur": "PF1.SkillSur",\r\n  "swm": "PF1.SkillSwm",\r\n  "umd": "PF1.SkillUMD"\r\n};\r\n\r\nPF1.arbitrarySkills = [\r\n  "art", "crf", "lor", "prf", "pro"\r\n];\r\n\r\n\r\n/* -------------------------------------------- */\r\n\r\nPF1.spellPreparationModes = {\r\n  "atwill": "PF1.SpellPrepAtWill",\r\n  "prepared": "PF1.SpellPrepPrepared",\r\n  "spontaneous": "PF1.SpellPrepSpontaneous",\r\n};\r\n\r\nPF1.classCasterType = {\r\n  "sorcerer": "high",\r\n  "wizard": "high",\r\n  "cleric": "high",\r\n  "oracle": "high",\r\n  "druid": "high",\r\n  "psychic": "high",\r\n  "shaman": "high",\r\n  "witch": "high",\r\n  "alchemist": "med",\r\n  "bard": "med",\r\n  "hunter": "med",\r\n  "inquisitor": "med",\r\n  "investigator": "med",\r\n  "magus": "med",\r\n  "mesmerist": "med",\r\n  "occultist": "med",\r\n  "skald": "med",\r\n  "spiritualist": "med",\r\n  "summoner": "med",\r\n  "unchained Summoner": "med",\r\n  "antipaladin": "low",\r\n  "bloodrager": "low",\r\n  "medium": "low",\r\n  "paladin": "low",\r\n  "ranger": "low",\r\n};\r\n\r\nPF1.magicAuraByLevel = {\r\n  "spell": [\r\n    { power: "faint", level: 1 },\r\n    { power: "moderate", level: 4 },\r\n    { power: "strong", level: 7 },\r\n    { power: "overwhelming", level: 10 },\r\n  ],\r\n  "item": [\r\n    { power: "faint", level: 1 },\r\n    { power: "moderate", level: 6 },\r\n    { power: "strong", level: 12 },\r\n    { power: "overwhelming", level: 21 },\r\n  ],\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/* -------------------------------------------- */\r\n\r\n// Weapon Types\r\nPF1.weaponTypes = {\r\n  "simple": {\r\n    "_label": "PF1.WeaponTypeSimple",\r\n    "light": "PF1.WeaponPropLight",\r\n    "1h": "PF1.WeaponPropOneHanded",\r\n    "2h": "PF1.WeaponPropTwoHanded",\r\n    "ranged": "PF1.WeaponSubtypeRanged",\r\n  },\r\n  "martial": {\r\n    "_label": "PF1.WeaponTypeMartial",\r\n    "light": "PF1.WeaponPropLight",\r\n    "1h": "PF1.WeaponPropOneHanded",\r\n    "2h": "PF1.WeaponPropTwoHanded",\r\n    "ranged": "PF1.WeaponSubtypeRanged",\r\n  },\r\n  "exotic": {\r\n    "_label": "PF1.WeaponTypeExotic",\r\n    "light": "PF1.WeaponPropLight",\r\n    "1h": "PF1.WeaponPropOneHanded",\r\n    "2h": "PF1.WeaponPropTwoHanded",\r\n    "ranged": "PF1.WeaponSubtypeRanged",\r\n  },\r\n  "misc": {\r\n    "_label": "PF1.Misc",\r\n    "splash": "PF1.WeaponTypeSplash",\r\n    "other": "PF1.Other",\r\n  }\r\n};\r\n\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Define the set of weapon property flags which can exist on a weapon\r\n * @type {Object}\r\n */\r\nPF1.weaponProperties = {\r\n  "blc": "PF1.WeaponPropBlocking",\r\n  "brc": "PF1.WeaponPropBrace",\r\n  "dbl": "PF1.WeaponPropDouble",\r\n  "dis": "PF1.WeaponPropDisarm",\r\n  "fin": "PF1.WeaponPropFinesse",\r\n  "frg": "PF1.WeaponPropFragile",\r\n  "grp": "PF1.WeaponPropGrapple",\r\n  "imp": "PF1.WeaponPropImprovised",\r\n  "mnk": "PF1.WeaponPropMonk",\r\n  "nnl": "PF1.WeaponPropNonLethal",\r\n  "prf": "PF1.WeaponPropPerformance",\r\n  "rch": "PF1.WeaponPropReach",\r\n  "snd": "PF1.WeaponPropSunder",\r\n  "thr": "PF1.WeaponPropThrown",\r\n  "trp": "PF1.WeaponPropTrip",\r\n};\r\n\r\n\r\n// Spell Components\r\nPF1.spellComponents = {\r\n  "V": "PF1.SpellComponentVerbal",\r\n  "S": "PF1.SpellComponentSomatic",\r\n  "M": "PF1.SpellComponentMaterial",\r\n  "F": "PF1.SpellComponentFocus",\r\n  "DF": "PF1.SpellComponentDivineFocus",\r\n};\r\n\r\n// Spell Schools\r\nPF1.spellSchools = {\r\n  "abj": "PF1.SpellSchoolAbjuration",\r\n  "con": "PF1.SpellSchoolConjuration",\r\n  "div": "PF1.SpellSchoolDivination",\r\n  "enc": "PF1.SpellSchoolEnchantment",\r\n  "evo": "PF1.SpellSchoolEvocation",\r\n  "ill": "PF1.SpellSchoolIllusion",\r\n  "nec": "PF1.SpellSchoolNecromancy",\r\n  "trs": "PF1.SpellSchoolTransmutation",\r\n  "uni": "PF1.SpellSchoolUniversal",\r\n  "misc": "PF1.Misc",\r\n};\r\n\r\n// Spell Levels\r\nPF1.spellLevels = {\r\n  0: "PF1.SpellLevel0",\r\n  1: "PF1.SpellLevel1",\r\n  2: "PF1.SpellLevel2",\r\n  3: "PF1.SpellLevel3",\r\n  4: "PF1.SpellLevel4",\r\n  5: "PF1.SpellLevel5",\r\n  6: "PF1.SpellLevel6",\r\n  7: "PF1.SpellLevel7",\r\n  8: "PF1.SpellLevel8",\r\n  9: "PF1.SpellLevel9",\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Weapon proficiency levels\r\n * Each level provides a proficiency multiplier\r\n * @type {Object}\r\n */\r\nPF1.proficiencyLevels = {\r\n  "-4": "Not Proficient",\r\n  0: "Proficient"\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nPF1.conditionTypes = {\r\n  "bleed": "PF1.CondTypeBleed",\r\n  "blind": "PF1.CondTypeBlind",\r\n  "confuse": "PF1.CondTypeConfuse",\r\n  "daze": "PF1.CondTypeDaze",\r\n  "dazzle": "PF1.CondTypeDazzle",\r\n  "deaf": "PF1.CondTypeDeaf",\r\n  "disease": "PF1.CondTypeDisease",\r\n  "energyDrain": "PF1.CondTypeEnergyDrain",\r\n  "fatigue": "PF1.CondTypeFatigue",\r\n  "fear": "PF1.CondTypeFear",\r\n  "mindAffecting": "PF1.CondTypeMindAffecting",\r\n  "poison": "PF1.CondTypePoison",\r\n  "sicken": "PF1.CondTypeSicken",\r\n  "paralyze": "PF1.CondTypeParalyze",\r\n  "petrify": "PF1.CondTypePetrify",\r\n  "stun": "PF1.CondTypeStun",\r\n  "sleep": "PF1.CondTypeSleep",\r\n};\r\n\r\nPF1.conditions = {\r\n  "blind": "PF1.CondBlind",\r\n  "dazzled": "PF1.CondDazzled",\r\n  "deaf": "PF1.CondDeaf",\r\n  "entangled": "PF1.CondEntangled",\r\n  "fatigued": "PF1.CondFatigued",\r\n  "exhausted": "PF1.CondExhausted",\r\n  "grappled": "PF1.CondGrappled",\r\n  "helpless": "PF1.CondHelpless",\r\n  "paralyzed": "PF1.CondParalyzed",\r\n  "pinned": "PF1.CondPinned",\r\n  "fear": "PF1.CondFear",\r\n  "sickened": "PF1.CondSickened",\r\n  "stunned": "PF1.CondStunned",\r\n};\r\n\r\nPF1.buffTypes = {\r\n  "temp": "PF1.Temporary",\r\n  "perm": "PF1.Permanent",\r\n  "item": "PF1.Item",\r\n  "misc": "PF1.Misc",\r\n};\r\n\r\nPF1.buffTargets = {\r\n  "ac": {\r\n    "_label": "PF1.BuffTarAC",\r\n    "ac": "PF1.BuffTarACGeneric",\r\n    "aac": "PF1.BuffTarACArmor",\r\n    "sac": "PF1.BuffTarACShield",\r\n    "nac": "PF1.BuffTarACNatural",\r\n  },\r\n  "attack": {\r\n    "_label": "PF1.AttackRollPlural",\r\n    "attack": "PF1.All",\r\n    "mattack": "PF1.Melee",\r\n    "rattack": "PF1.Ranged",\r\n  },\r\n  "damage": {\r\n    "_label": "PF1.Damage",\r\n    "damage": "PF1.All",\r\n    "wdamage": "PF1.WeaponDamage",\r\n    "sdamage": "PF1.SpellDamage",\r\n  },\r\n  "ability": {\r\n    "_label": "PF1.AbilityScore",\r\n    "str": "PF1.AbilityStr",\r\n    "dex": "PF1.AbilityDex",\r\n    "con": "PF1.AbilityCon",\r\n    "int": "PF1.AbilityInt",\r\n    "wis": "PF1.AbilityWis",\r\n    "cha": "PF1.AbilityCha",\r\n  },\r\n  "savingThrows": {\r\n    "_label": "PF1.SavingThrowPlural",\r\n    "allSavingThrows": "PF1.All",\r\n    "fort": "PF1.SavingThrowFort",\r\n    "ref": "PF1.SavingThrowRef",\r\n    "will": "PF1.SavingThrowWill",\r\n  },\r\n  "skills": {\r\n    "_label": "PF1.Skills",\r\n    "skills": "PF1.All",\r\n    "strSkills": "PF1.BuffTarStrSkills",\r\n    "dexSkills": "PF1.BuffTarDexSkills",\r\n    "conSkills": "PF1.BuffTarConSkills",\r\n    "intSkills": "PF1.BuffTarIntSkills",\r\n    "wisSkills": "PF1.BuffTarWisSkills",\r\n    "chaSkills": "PF1.BuffTarChaSkills",\r\n  },\r\n  "skill": {\r\n    "_label": "PF1.BuffTarSpecificSkill",\r\n  },\r\n  "abilityChecks": {\r\n    "_label": "PF1.BuffTarAbilityChecks",\r\n    "allChecks": "PF1.All",\r\n    "strChecks": "PF1.BuffTarStrChecks",\r\n    "dexChecks": "PF1.BuffTarDexChecks",\r\n    "conChecks": "PF1.BuffTarConChecks",\r\n    "intChecks": "PF1.BuffTarIntChecks",\r\n    "wisChecks": "PF1.BuffTarWisChecks",\r\n    "chaChecks": "PF1.BuffTarChaChecks",\r\n  },\r\n  "speed": {\r\n    "_label": "PF1.Speed",\r\n    "allSpeeds": "PF1.All",\r\n    "landSpeed": "PF1.SpeedLand",\r\n    "climbSpeed": "PF1.SpeedClimb",\r\n    "swimSpeed": "PF1.SpeedSwim",\r\n    "burrowSpeed": "PF1.SpeedBurrow",\r\n    "flySpeed": "PF1.SpeedFly",\r\n  },\r\n  "misc": {\r\n    "_label": "PF1.MiscShort",\r\n    "cmb": "CMB",\r\n    "cmd": "CMD",\r\n    "init": "PF1.Initiative",\r\n    "mhp": "Hit Points",\r\n    "wounds": "PF1.Wounds",\r\n    "vigor": "PF1.Vigor",\r\n  },\r\n};\r\n\r\nPF1.contextNoteTargets = {\r\n  "attacks": {\r\n    "_label": "PF1.Attacks",\r\n    "attack": "PF1.AttackRollPlural",\r\n    "effect": "PF1.DamageRollPlural",\r\n  },\r\n  "savingThrows": {\r\n    "_label": "PF1.SavingThrowPlural",\r\n    "allSavingThrows": "PF1.All",\r\n    "fort": "PF1.SavingThrowFort",\r\n    "ref": "PF1.SavingThrowRef",\r\n    "will": "PF1.SavingThrowWill",\r\n  },\r\n  "skills": {\r\n    "_label": "PF1.Skills",\r\n    "skills": "PF1.All",\r\n    "strSkills": "PF1.BuffTarStrSkills",\r\n    "dexSkills": "PF1.BuffTarDexSkills",\r\n    "conSkills": "PF1.BuffTarConSkills",\r\n    "intSkills": "PF1.BuffTarIntSkills",\r\n    "wisSkills": "PF1.BuffTarWisSkills",\r\n    "chaSkills": "PF1.BuffTarChaSkills",\r\n  },\r\n  "skill": {\r\n    "_label": "PF1.BuffTarSpecificSkill",\r\n  },\r\n  "abilityChecks": {\r\n    "_label": "PF1.BuffTarAbilityChecks",\r\n    "allChecks": "PF1.All",\r\n    "strChecks": "PF1.BuffTarStrChecks",\r\n    "dexChecks": "PF1.BuffTarDexChecks",\r\n    "conChecks": "PF1.BuffTarConChecks",\r\n    "intChecks": "PF1.BuffTarIntChecks",\r\n    "wisChecks": "PF1.BuffTarWisChecks",\r\n    "chaChecks": "PF1.BuffTarChaChecks",\r\n  },\r\n  "misc": {\r\n    "_label": "PF1.MiscShort",\r\n    "ac": "PF1.ACNormal",\r\n    "cmb": "CMB",\r\n    "cmd": "CMD",\r\n    "sr": "PF1.SpellResistance",\r\n  },\r\n};\r\n\r\n// Languages\r\nPF1.languages = {\r\n  "common": "Common",\r\n  "aboleth": "Aboleth",\r\n  "abyssal": "Abyssal",\r\n  "aklo": "Aklo",\r\n  "aquan": "Aquan",\r\n  "auran": "Auran",\r\n  "boggard": "Boggard",\r\n  "celestial": "Celestial",\r\n  "common": "Common",\r\n  "cyclops": "Cyclops",\r\n  "dark": "Dark Folk",\r\n  "draconic": "Draconic",\r\n  "drowsign": "Drow Sign Language",\r\n  "druidic": "Druidic",\r\n  "dwarven": "Dwarven",\r\n  "dziriak": "D\'ziriak",\r\n  "elven": "Elven",\r\n  "giant": "Giant",\r\n  "gnome": "Gnome",\r\n  "goblin": "Goblin",\r\n  "gnoll": "Gnoll",\r\n  "grippli": "Grippli",\r\n  "halfling": "Halfling",\r\n  "ignan": "Ignan",\r\n  "infernal": "Infernal",\r\n  "nercil": "Necril",\r\n  "orc": "Orc",\r\n  "protean": "Protean",\r\n  "sphinx": "Sphinx",\r\n  "sylvan": "Sylvan",\r\n  "tengu": "Tengu",\r\n  "terran": "Terran",\r\n  "treant": "Treant",\r\n  "undercommon": "Undercommon",\r\n  "vegepygmy": "Vegepygmy"\r\n};\r\n\r\nPF1.creatureTypes = {\r\n  "aberration": "PF1.CreatureTypeAberration",\r\n  "animal": "PF1.CreatureTypeAnimal",\r\n  "construct": "PF1.CreatureTypeConstruct",\r\n  "dragon": "PF1.CreatureTypeDragon",\r\n  "fey": "PF1.CreatureTypeFey",\r\n  "humanoid": "PF1.CreatureTypeHumanoid",\r\n  "magicalBeast": "PF1.CreatureTypeMagicalBeast",\r\n  "monstrousHumanoid": "PF1.CreatureTypeMonstrousHumanoid",\r\n  "ooze": "PF1.CreatureTypeOoze",\r\n  "outsider": "PF1.CreatureTypeOutsider",\r\n  "plant": "PF1.CreatureTypePlant",\r\n  "undead": "PF1.CreatureTypeUndead",\r\n  "vermin": "PF1.CreatureTypeVermin",\r\n};\r\n\r\nPF1.sizeDie = [\r\n  "1",\r\n  "1d2",\r\n  "1d3",\r\n  "1d4",\r\n  "1d6",\r\n  "1d8",\r\n  "1d10",\r\n  "2d6",\r\n  "2d8",\r\n  "3d6",\r\n  "3d8",\r\n  "4d6",\r\n  "4d8",\r\n  "6d6",\r\n  "6d8",\r\n  "8d6",\r\n  "8d8",\r\n  "12d6",\r\n  "12d8",\r\n  "16d6",\r\n  "16d8",\r\n];\r\n\r\n// Character Level XP Requirements\r\nPF1.CHARACTER_EXP_LEVELS =  {\r\n  slow: [\r\n    0, 3000, 7500, 14000, 23000, 35000, 53000, 77000, 115000, 160000, 235000, 330000,\r\n    475000, 665000, 955000, 1350000, 1900000, 2700000, 3850000, 5350000\r\n  ],\r\n  medium: [\r\n    0, 2000, 5000, 9000, 15000, 23000, 35000, 51000, 75000, 105000, 155000, 220000,\r\n    315000, 445000, 635000, 890000, 1300000, 1800000, 2550000, 3600000\r\n  ],\r\n  fast: [\r\n    0, 1300, 3300, 6000, 10000, 15000, 23000, 34000, 50000, 71000, 105000, 145000,\r\n    210000, 295000, 425000, 600000, 850000, 1200000, 1700000, 2400000\r\n  ]\r\n};\r\n\r\n// Challenge Rating XP Levels\r\nPF1.CR_EXP_LEVELS = [\r\n  200, 400, 600, 800, 1200, 1600, 2400, 3200, 4800, 6400, 9600, 12800, 19200, 25600,\r\n  38400, 51200, 76800, 102400, 153600, 204800, 307200, 409600, 614400, 819200, 1228800, 1638400, 2457600,\r\n  3276800, 4915200, 6553600, 9830400\r\n];\r\n\r\nCONFIG.Combat.initiative.decimals = 2;\r\n\n\n//# sourceURL=webpack://pf1/./module/config.js?')},"./module/config/experience.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExperienceConfig", function() { return ExperienceConfig; });\nclass ExperienceConfig extends FormApplication {\r\n  constructor(object, options) {\r\n    super(object || ExperienceConfig.defaultSettings, options);\r\n\r\n    this._init = false;\r\n  }\r\n\r\n  /** Collect data for the template. @override */\r\n  async getData() {\r\n    const data = {};\r\n\r\n    if (!this._init) {\r\n      const settings = await game.settings.get("pf1", "experienceConfig");\r\n      this._settings = mergeObject(this.constructor.defaultSettings, settings);\r\n      this._init = true;\r\n    }\r\n    data.settings = this._settings;\r\n\r\n    // Custom experience track booleans\r\n    data.hasCustomFormula = data.settings.track === "customFormula";\r\n\r\n    return data;\r\n  }\r\n\r\n  /** @override */\r\n  static get defaultOptions() {\r\n    return mergeObject(super.defaultOptions, {\r\n      title:  game.i18n.localize("PF1.ExperienceConfigName"),\r\n      id: \'experience-config\',\r\n      template: "systems/pf1/templates/settings/experience.html",\r\n      width: 560,\r\n      height: "auto",\r\n    });\r\n  }\r\n\r\n  static get defaultSettings() {\r\n    return {\r\n      track: "medium",\r\n      disableExperienceTracking: false,\r\n      custom: {\r\n        formula: "",\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Activate the default set of listeners for the Entity sheet These listeners handle basic stuff like form submission or updating images.\r\n   * @override\r\n   */\r\n  activateListeners(html) {\r\n    super.activateListeners(html);\r\n    html.find(\'button[type="submit"]\').click(this._onButtonSubmit.bind(this));\r\n  }\r\n\r\n  _onButtonSubmit(event) {\r\n    this._onSubmit(event);\r\n  }\r\n\r\n  _onChangeInput(event) {\r\n    super._onChangeInput(event);\r\n\r\n    this._updateApplicationSettings();\r\n  }\r\n\r\n  _updateApplicationSettings() {\r\n\r\n    // Acquire and validate Form Data\r\n    const form = this.element.find("form").first()[0];\r\n    const FD = this._getFormData(form);\r\n    const dtypes = FD._dtypes;\r\n\r\n    // Construct update data object by casting form data\r\n    let formData = Array.from(FD).reduce((obj, [k, v]) => {\r\n      let dt = dtypes[k];\r\n      if ( dt === "Number" ) obj[k] = v !== "" ? Number(v) : null;\r\n      else if ( dt === "Boolean" ) obj[k] = v === "true";\r\n      else if ( dt === "Radio" ) obj[k] = JSON.parse(v);\r\n      else obj[k] = v;\r\n      return obj;\r\n    }, {});\r\n\r\n    // Update settings and re-render\r\n    this._settings = mergeObject(this._settings, expandObject(formData));\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * This method is called upon form submission after form data is validated.\r\n   * @override\r\n   */\r\n  async _updateObject(event, formData) {\r\n    const settings = expandObject(formData);\r\n    // Some mild sanitation for the numeric values.\r\n    await game.settings.set("pf1", "experienceConfig", settings);\r\n    ui.notifications.info("Updated Pathfinder experience configuration.");\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/config/experience.js?')},"./module/config/health.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HealthConfig", function() { return HealthConfig; });\nclass HealthConfig extends FormApplication {\r\n  constructor(object, options) {\r\n    super(object || HealthConfig.defaultSettings, options)\r\n  }\r\n\r\n  /** Collect data for the template. @override */\r\n  async getData() {\r\n    let settings = await game.settings.get("pf1", "healthConfig")\r\n    settings = mergeObject(HealthConfig.defaultSettings, settings)\r\n    return settings\r\n  }\r\n\r\n  /** @override */\r\n  static get defaultOptions() {\r\n    return mergeObject(super.defaultOptions, {\r\n      title:  game.i18n.localize("SETTINGS.pf1HealthConfigName"),\r\n      id: \'health-config\',\r\n      template: "systems/pf1/templates/settings/health.html",\r\n      width: 480,\r\n      height: "auto",\r\n      tabs: [{\r\n        navSelector: ".tabs",\r\n        contentSelector: ".tabbed",\r\n        initial: "base"\r\n      }]\r\n    })\r\n  }\r\n\r\n  static get defaultSettings() {\r\n    return {\r\n      hitdice: {\r\n        PC:     {auto: false, rate: 0.5, maximized: 1},\r\n        NPC:    {auto: false, rate: 0.5, maximized: 0},\r\n        Racial: {auto: false, rate: 0.5, maximized: 0}\r\n      },\r\n      hitdieOptions: ["Compute", "Rate", "Maximized"],\r\n      rounding: "up",\r\n      continuity: "discrete",\r\n      variants: {\r\n        pc:  {useWoundsAndVigor: false},\r\n        npc: {useWoundsAndVigor: false}\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate the default set of listeners for the Entity sheet These listeners handle basic stuff like form submission or updating images.\r\n   * @override\r\n   */\r\n  activateListeners(html) {\r\n    super.activateListeners(html)\r\n    html.find(\'button[name="reset"]\').click(this._onReset.bind(this))\r\n    html.find(\'button[name="submit"]\').click(this._onSubmit.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Handle button click to reset default settings\r\n   * @param event {Event}   The initial button click event\r\n   * @private\r\n   */\r\n  async _onReset(event) {\r\n    event.preventDefault();\r\n    await game.settings.set("pf1", "healthConfig", HealthConfig.defaultSettings)\r\n    ui.notifications.info(`Reset Pathfinder health configuration.`)\r\n    return this.render()\r\n  }\r\n\r\n  _onSubmit(event) {\r\n    super._onSubmit(event)\r\n  }\r\n\r\n  /**\r\n   * This method is called upon form submission after form data is validated.\r\n   * @override\r\n   */\r\n  async _updateObject(event, formData) {\r\n    const settings = expandObject(formData)\r\n    // Some mild sanitation for the numeric values.\r\n    for (const hd of Object.values(settings.hitdice)) {\r\n      hd.rate = Math.max(0, Math.min(hd.rate, 100))\r\n      hd.maximized = Math.max(0, Math.min(Math.floor(hd.maximized), 100))\r\n    }\r\n    await game.settings.set("pf1", "healthConfig", settings)\r\n    ui.notifications.info("Updated Pathfinder health configuration.")\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/config/health.js?')},"./module/dice.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DicePF", function() { return DicePF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_preProcessDiceFormula", function() { return _preProcessDiceFormula; });\n/* harmony import */ var _sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sidebar/chat-message.js */ "./module/sidebar/chat-message.js");\n\n\nclass DicePF {\n\n  /**\n   * A standardized helper function for managing core 5e "d20 rolls"\n   *\n   * Holding SHIFT, ALT, or CTRL when the attack is rolled will "fast-forward".\n   * This chooses the default options of a normal attack with no bonus, Advantage, or Disadvantage respectively\n   *\n   * @param {Event} event           The triggering event which initiated the roll\n   * @param {Array} parts           The dice roll component parts, excluding the initial d20\n   * @param {Actor} actor           The Actor making the d20 roll\n   * @param {Object} data           Actor or item data against which to parse the roll\n   * @param {String} template       The HTML template used to render the roll dialog\n   * @param {String} title          The dice roll UI window title\n   * @param {Object} speaker        The ChatMessage speaker to pass when creating the chat\n   * @param {Function} flavor       A callable function for determining the chat message flavor given parts and data\n   * @param {Boolean} takeTwenty    Allow rolling with take twenty (and therefore also with take ten)\n   * @param {Boolean} situational   Allow for an arbitrary situational bonus field\n   * @param {Boolean} fastForward   Allow fast-forward advantage selection\n   * @param {Number} critical       The value of d20 result which represents a critical success\n   * @param {Number} fumble         The value of d20 result which represents a critical failure\n   * @param {Function} onClose      Callback for actions to take when the dialog form is closed\n   * @param {Object} dialogOptions  Modal dialog options\n   * @param {Array} extraRolls      An array containing bonuses/penalties for extra rolls\n   * @param {Boolean} autoRender    Whether to automatically render the chat messages\n   */\n  static async d20Roll({event, parts, data, template, title, speaker, flavor, takeTwenty=true, situational=true,\n                  fastForward=true, critical=20, fumble=1, onClose, dialogOptions, extraRolls=[], chatTemplate, chatTemplateData,\n                  staticRoll=null }) {\n    // Handle input arguments\n    flavor = flavor || title;\n    let rollMode = game.settings.get("core", "rollMode");\n    let rolled = false;\n\n    // Inner roll function\n    let _roll = async (parts, setRoll, form) => {\n      const originalFlavor = flavor;\n      rollMode = form ? form.find(\'[name="rollMode"]\').val() : rollMode;\n      for (let a = 0; a < 1 + extraRolls.length; a++) {\n        flavor = originalFlavor;\n        let curParts = duplicate(parts);\n        // Don\'t include situational bonus unless it is defined\n        data.bonus = form ? form.find(\'[name="bonus"]\').val() : 0;\n        if (!data.bonus && curParts.indexOf("@bonus") !== -1) curParts.pop();\n\n        // Extra roll specifics\n        if (a >= 1) {\n          let extraRoll = extraRolls[a-1];\n          curParts.push(extraRoll.bonus);\n          flavor += ` <div class="extra-roll-label">${extraRoll.label}</div>`;\n        }\n\n        // Do set roll\n        if (setRoll != null && setRoll >= 0) {\n          curParts[0] = `${setRoll}`;\n          flavor += ` (Take ${setRoll})`;\n        }\n\n        // Execute the roll\n        let roll = new Roll(curParts.join(" + "), data).roll();\n\n        // Convert the roll to a chat message\n        if (chatTemplate) {\n          // Create roll template data\n          const d20 = roll.parts[0];\n          const rollData = mergeObject({\n            user: game.user._id,\n            formula: roll.formula,\n            tooltip: await roll.getTooltip(),\n            total: roll.total,\n            isCrit: d20.total >= critical,\n            isFumble: d20.total <= fumble,\n          }, chatTemplateData || {});\n\n          // Create chat data\n          let chatData = {\n            user: game.user._id,\n            type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n            sound: a === 0 ? CONFIG.sounds.dice : null,\n            speaker: speaker,\n            content: await renderTemplate(chatTemplate, rollData),\n            "flags.pf1.noRollRender": true,\n          };\n          // Handle different roll modes\n          switch (rollMode) {\n            case "gmroll":\n              chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\n              break;\n            case "selfroll":\n              chatData["whisper"] = [game.user._id];\n              break;\n            case "blindroll":\n              chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\n              chatData["blind"] = true;\n              break;\n          }\n\n          // Send message\n          rolled = true;\n          chatData = mergeObject(roll.toMessage({flavor}, { create: false }), chatData);\n\n          await _sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_0__["ChatMessagePF"].create(chatData);\n        }\n        else {\n          rolled = true;\n          await roll.toMessage({\n            speaker: speaker,\n            flavor: flavor,\n            rollMode: rollMode,\n            sound: a === 0 ? CONFIG.sounds.dice : null\n          });\n        }\n      }\n    };\n\n    // Modify the roll and handle fast-forwarding\n    parts = ["1d20"].concat(parts);\n    if (fastForward === true || event.shiftKey) return _roll(parts, staticRoll);\n    else parts = parts.concat(["@bonus"]);\n\n    // Render modal dialog\n    template = template || "systems/pf1/templates/chat/roll-dialog.html";\n    let dialogData = {\n      formula: parts.join(" + "),\n      data: data,\n      rollMode: rollMode,\n      rollModes: CONFIG.Dice.rollModes\n    };\n    const html = await renderTemplate(template, dialogData);\n\n    let roll;\n    return new Promise(resolve => {\n      new Dialog({\n        title: title,\n        content: html,\n        buttons: {\n          normal: {\n            label: "Normal",\n            callback: html => roll = _roll(parts, staticRoll != null ? staticRoll : -1, html)\n          },\n          takeTen: {\n            label: "Take 10",\n            condition: takeTwenty,\n            callback: html => roll = _roll(parts, 10, html)\n          },\n          takeTwenty: {\n            label: "Take 20",\n            condition: takeTwenty,\n            callback: html => roll = _roll(parts, 20, html)\n          }\n        },\n        default: "normal",\n        close: html => {\n          if ( onClose ) onClose(html, parts, data);\n          resolve(rolled ? roll : false);\n        }\n      }, dialogOptions).render(true);\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n   * A standardized helper function for managing core 5e "d20 rolls"\n   *\n   * Holding SHIFT, ALT, or CTRL when the attack is rolled will "fast-forward".\n   * This chooses the default options of a normal attack with no bonus, Critical, or no bonus respectively\n   *\n   * @param {Event} event           The triggering event which initiated the roll\n   * @param {Array} parts           The dice roll component parts, excluding the initial d20\n   * @param {Actor} actor           The Actor making the damage roll\n   * @param {Object} data           Actor or item data against which to parse the roll\n   * @param {String} template       The HTML template used to render the roll dialog\n   * @param {String} title          The dice roll UI window title\n   * @param {Object} speaker        The ChatMessage speaker to pass when creating the chat\n   * @param {Function} flavor       A callable function for determining the chat message flavor given parts and data\n   * @param {Boolean} critical      Allow critical hits to be chosen\n   * @param {Function} onClose      Callback for actions to take when the dialog form is closed\n   * @param {Object} dialogOptions  Modal dialog options\n   */\n  static async damageRoll({event={}, parts, actor, data, template, title, speaker, flavor, critical=true, onClose, dialogOptions, chatTemplate, chatTemplateData }) {\n    flavor = flavor || title;\n    let rollMode = game.settings.get("core", "rollMode");\n    let rolled = false;\n\n    // Inner roll function\n    const _roll = async (crit, form) => {\n      // Don\'t include situational bonus unless it is defined\n      data.bonus = form ? form.find(\'[name="bonus"]\').val() : 0;\n\n      // Detemrine critical multiplier\n      data["critMult"] = crit ? data.item.ability.critMult : 1;\n      // Determine damage ability\n      data["ablMult"] = 0;\n      if (data.item.ability.damageMult != null) {\n        data["ablMult"] = data.item.ability.damageMult;\n      }\n\n      let roll = new Roll(parts.join("+"), data);\n      if ( crit === true ) {\n        let mult = data.item.ability.critMult || 2;\n\n        // Update first damage part\n        roll.alter(0, mult);\n        flavor = `${flavor} (Critical)`;\n      }\n\n      roll.roll();\n\n      // Convert the roll to a chat message\n      if (chatTemplate) {\n        // Create roll template data\n        const rollData = mergeObject({\n          user: game.user._id,\n          formula: roll.formula,\n          tooltip: await roll.getTooltip(),\n          total: roll.total,\n        }, chatTemplateData || {});\n\n        // Create chat data\n        let chatData = {\n          user: game.user._id,\n          type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n          rollMode: game.settings.get("core", "rollMode"),\n          sound: CONFIG.sounds.dice,\n          speaker: speaker,\n          flavor: flavor,\n          rollMode: rollMode,\n          roll: roll,\n          content: await renderTemplate(chatTemplate, rollData),\n          useCustomContent: true,\n        };\n        // Handle different roll modes\n        switch (chatData.rollMode) {\n          case "gmroll":\n            chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\n            break;\n          case "selfroll":\n            chatData["whisper"] = [game.user._id];\n            break;\n          case "blindroll":\n            chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\n            chatData["blind"] = true;\n        }\n\n        // Send message\n        rolled = true;\n        _sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_0__["ChatMessagePF"].create(chatData);\n      }\n      else {\n        rolled = true;\n        roll.toMessage({\n          speaker: speaker,\n          flavor: flavor,\n          rollMode: rollMode\n        });\n      }\n\n      // Return the Roll object\n      return roll;\n    };\n\n    // Modify the roll and handle fast-forwarding\n    if (!event.shiftKey) return _roll(event.ctrlKey);\n    else parts = parts.concat(["@bonus"]);\n\n    // Construct dialog data\n    template = template || "systems/pf1/templates/chat/roll-dialog.html";\n    let dialogData = {\n      formula: parts.join(" + "),\n      data: data,\n      rollMode: rollMode,\n      rollModes: CONFIG.Dice.rollModes\n    };\n    const html = await renderTemplate(template, dialogData);\n\n    // Render modal dialog\n    let roll;\n    return new Promise(resolve => {\n      new Dialog({\n        title: title,\n        content: html,\n        buttons: {\n          normal: {\n            label: critical ? "Normal" : "Roll",\n            callback: html => roll = _roll(false, html)\n          },\n          critical: {\n            condition: critical,\n            label: "Critical Hit",\n            callback: html => roll = _roll(true, html)\n          },\n        },\n        default: "normal",\n        close: html => {\n          if (onClose) onClose(html, parts, data);\n          resolve(rolled ? roll : false);\n        }\n      }, dialogOptions).render(true);\n    });\n  }\n\n  static messageRoll({data, msgStr}) {\n    let re = /\\[\\[(.+)\\]\\]/g;\n    return msgStr.replace(re, (_, p1) => {\n      const roll = new Roll(p1, data).roll();\n      return roll.total.toString();\n    });\n\n    return msgStr;\n  }\n}\n\nconst _preProcessDiceFormula = function(formula, data={}) {\n\n  // Replace parentheses with semicolons to use for splitting\n  let toSplit = formula.replace(/([A-z]+)?\\(/g, (match, prefix) => {\n    return (prefix in game.pf1.rollPreProcess || prefix in Math) ? `;${prefix};(;` : ";(;";\n  }).replace(/\\)/g, ";);");\n  let terms = toSplit.split(";");\n\n  // Match parenthetical groups\n  let nOpen = 0,\n    nOpenPreProcess = [];\n  terms = terms.reduce((arr, t) => {\n\n    // Handle cases where the prior term is a math function\n    const beginPreProcessFn = (t[0] === "(") && (arr[arr.length-1] in game.pf1.rollPreProcess);\n    if (beginPreProcessFn) nOpenPreProcess.push([arr.length-1, nOpen]);\n    const beginMathFn = (t[0] === "(") && (arr[arr.length-1] in Math);\n    if (beginMathFn && nOpenPreProcess.length > 0) nOpenPreProcess.push([arr.length-1, nOpen]);\n\n    // Add terms to the array\n    arr.push(t);\n\n    // Increment the number of open parentheses\n    if ( t === "(" ) nOpen++;\n    if ( (nOpen > 0) && (t === ")") ) {\n      nOpen--;\n      for (let a = 0; a < nOpenPreProcess.length; a++) {\n        let obj = nOpenPreProcess[a];\n        // End pre process function\n        if (obj[1] === nOpen) {\n          const sliceLen = arr.length - obj[0];\n          let fnData = arr.splice(obj[0], sliceLen),\n            fn = fnData[0];\n          let fnParams = fnData.slice(2, -1).reduce((cur, s) => {\n              cur.push(...s.split(/\\s*,\\s*/));\n              return cur;\n            }, []).map(o => {\n              return new Roll(o, data).roll().total;\n            }).filter(o => o !== "" && o != null);\n          if (fn in Math) {\n            arr.push(Math[fn](...fnParams).toString());\n          }\n          else {\n            arr.push(game.pf1.rollPreProcess[fn](...fnParams).toString());\n          }\n\n          nOpenPreProcess.splice(a, 1);\n          a--;\n        }\n      }\n    }\n    return arr;\n  }, []);\n  \n  return terms.join("");\n\n\n\n  // Replace parentheses with semicolons to use for splitting\n  // let toSplit = formula.replace(/([A-z]+)?\\(/g, (match, prefix) => {\n    // return typeof prefix === "string" ? `;${prefix};(;` : ";(;";\n  // }).replace(/\\)/g, ";);").replace(/,/g, ";,;");\n  // let terms = toSplit.split(";").filter(t => t !== "");\n\n  // // Match parenthetical groups\n  // let nOpen = 0,\n    // fnIndex = -1,\n    // fnOpen = -1,\n    // fnName = "";\n\n  // terms = terms.reduce((arr, t, a) => {\n\n    // // Handle cases where the prior term is a math function\n    // const beginMathFn = (t[0] === "(") && (arr[arr.length-1] in game.pf1.rollPreProcess);\n\n    // // Add to array\n    // arr.push(t);\n\n    // // Increment the number of open parentheses\n    // if ( (t === "(") ) {\n      // if ( beginMathFn ) {\n        // fnIndex = a - 1;\n        // fnOpen = nOpen;\n        // fnName = arr[a-1];\n      // }\n      // nOpen++;\n    // }\n    // if ( (nOpen > 0) && (t === ")") && (fnName !== "") ) {\n      // nOpen--;\n      // if ( fnOpen === nOpen ) {\n        // let nOpen2 = 0,\n          // slice = "";\n        // const fnData = arr.splice(fnIndex, a - fnIndex + 1),\n          // middleSlice = fnData.slice(2, -1).reduce((arr2, t2) => {\n\n            // if ( t2 === "(" ) nOpen2++;\n            // else if ( t2 === ")" ) nOpen2--;\n\n            // if ( nOpen2 === 0 && t2 === "," ) {\n              // arr2.push(slice);\n              // slice = "";\n            // }\n            // else slice += t2.trim();\n\n            // return arr2;\n          // }, []).concat([slice]);//.join("").split(/\\s*,\\s*/).map(o => o.trim());\n\n        // const fnParams = middleSlice.map(o => {\n          // return new Roll(o, data).roll().total;\n        // });\n        // arr.push(game.pf1.rollPreProcess[fnName](...fnParams));\n      // }\n\n      // fnIndex = -1;\n      // fnOpen = -1;\n      // fnName = "";\n    // }\n\n    // return arr;\n  // }, []);\n\n  // return terms.join("");\n\n  // Convert parenthetical groups to inner Roll objects\n  // return terms.reduce((arr, t) => {\n    // if ( t === "" ) return arr;\n    // let pt = t.match(this.rgx.parenthetical);\n    // arr.push(pt ? new Roll(pt[1], data) : t);\n    // return arr;\n  // }, []);\n\n  // return _process(formula, data);\n};\n\n\n//# sourceURL=webpack://pf1/./module/dice.js?')},"./module/item/entity.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemPF", function() { return ItemPF; });\n/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dice.js */ "./module/dice.js");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chat.js */ "./module/chat.js");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib.js */ "./module/lib.js");\n/* harmony import */ var _actor_entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../actor/entity.js */ "./module/actor/entity.js");\n/* harmony import */ var _pixi_ability_template_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pixi/ability-template.js */ "./module/pixi/ability-template.js");\n/* harmony import */ var _misc_chat_attack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../misc/chat-attack.js */ "./module/misc/chat-attack.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Override and extend the basic :class:`Item` implementation\r\n */\r\nclass ItemPF extends Item {\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    /**\r\n     * @property {Object} _prevData\r\n     * When an item gets updated, certain data is stored here for use in _onUpdate.\r\n     */\r\n    this._prevData = {};\r\n\r\n    /**\r\n     * @property {Object} links\r\n     * Links are stored here during runtime.\r\n     */\r\n    this.links = {};\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Item Properties                             */\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Does the Item implement an attack roll as part of its usage\r\n   * @type {boolean}\r\n   */\r\n  get hasAttack() {\r\n    return ["mwak", "rwak", "msak", "rsak"].includes(this.data.data.actionType);\r\n  }\r\n\r\n  get hasMultiAttack() {\r\n    return this.hasAttack && this.data.data.attackParts != null && this.data.data.attackParts.length > 0;\r\n  }\r\n\r\n  get hasTemplate() {\r\n    const v = getProperty(this.data, "data.measureTemplate.type");\r\n    const s = getProperty(this.data, "data.measureTemplate.size");\r\n    return (typeof v === "string" && v !== "") && ((typeof s === "string" && s.length > 0) || (typeof s === "number" && s > 0));\r\n  }\r\n\r\n  get hasAction() {\r\n    return this.hasAttack\r\n    || this.hasDamage\r\n    || this.hasEffect\r\n    || this.hasTemplate;\r\n  }\r\n\r\n  get isSingleUse() {\r\n    return getProperty(this.data, "data.uses.per") === "single";\r\n  }\r\n\r\n  get isCharged() {\r\n    if (this.type === "consumable" && getProperty(this.data, "data.uses.per") === "single") return true;\r\n    return ["day", "week", "charges"].includes(getProperty(this.data, "data.uses.per"));\r\n  }\r\n\r\n  get autoDeductCharges() {\r\n    return this.type === "spell"\r\n      ? getProperty(this.data, "data.preparation.autoDeductCharges") === true\r\n      : (this.isCharged && getProperty(this.data, "data.uses.autoDeductCharges") === true);\r\n  }\r\n\r\n  get charges() {\r\n    // Get linked charges\r\n    const link = getProperty(this, "links.charges");\r\n    if (link) return link.charges;\r\n\r\n    // Get own charges\r\n    if (getProperty(this.data, "data.uses.per") === "single") return getProperty(this.data, "data.quantity");\r\n    if (this.type === "spell") return this.getSpellUses();\r\n    return getProperty(this.data, "data.uses.value") || 0;\r\n  }\r\n\r\n  get chargeCost() {\r\n    if (this.type === "spell") return 1;\r\n    \r\n    const formula = getProperty(this.data, "data.uses.autoDeductChargesCost");\r\n    if (!(typeof formula === "string" && formula.length > 0)) return 1;\r\n    const cost = new Roll(formula, this.getRollData()).roll().total;\r\n    return cost;\r\n  }\r\n\r\n  get spellbook() {\r\n    if (this.type !== "spell") return null;\r\n    if (this.actor == null)    return null;\r\n    \r\n    const spellbookIndex = this.data.data.spellbook;\r\n    return this.actor.data.data.attributes.spells.spellbooks[spellbookIndex];\r\n  }\r\n\r\n  get casterLevel() {\r\n    const spellbook = this.spellbook;\r\n    if (!spellbook) return null;\r\n\r\n    return spellbook.cl.total + (this.data.data.clOffset || 0);\r\n  }\r\n\r\n  get spellLevel() {\r\n    if (this.type !== "spell") return null;\r\n\r\n    return this.data.data.level + (this.data.data.slOffset || 0);\r\n  }\r\n\r\n  get dc() {\r\n    const rollData = this.getRollData();\r\n    const data = this.data.data;\r\n\r\n    if (this.type === "spell") {\r\n      const spellbook = this.spellbook;\r\n      if (spellbook != null) {\r\n        return new Roll(spellbook.baseDCFormula, rollData).roll().total + new Roll(data.save.dc.length > 0 ? data.save.dc : "0", rollData).roll().total;\r\n      }\r\n    }\r\n    const dcFormula = getProperty(data, "save.dc") || "";\r\n    return new Roll(dcFormula.length > 0 ? data.save.dc : "0", rollData).roll().total;\r\n  }\r\n\r\n  get typeColor() {\r\n    switch (this.type) {\r\n      case "feat":\r\n        return "#8900EA";\r\n      case "spell":\r\n        return "#5C37FF";\r\n      case "class":\r\n        return "#85B1D2";\r\n      case "race":\r\n        return "#00BD29";\r\n      case "attack":\r\n        return "#F21B1B";\r\n      case "weapon":\r\n      case "equipment":\r\n      case "consumable":\r\n      case "loot":\r\n        return "#E5E5E5";\r\n      case "buff":\r\n        return "#FDF767";\r\n    }\r\n\r\n    return "white";\r\n  }\r\n\r\n  get typeColor2() {\r\n    switch (this.type) {\r\n      case "feat":\r\n        return "#5F00A3";\r\n      case "spell":\r\n        return "#4026B2";\r\n      case "class":\r\n        return "#6A8DA8";\r\n      case "race":\r\n        return "#00841C";\r\n      case "attack":\r\n        return "#A91212";\r\n      case "weapon":\r\n      case "equipment":\r\n      case "consumable":\r\n      case "loot":\r\n        return "#B7B7B7";\r\n      case "buff":\r\n        return "#FDF203";\r\n    }\r\n\r\n    return "#C1C1C1";\r\n  }\r\n\r\n  static get defaultChange() {\r\n    return {\r\n      formula: "",\r\n      operator: "+",\r\n      target: "",\r\n      subTarget: "",\r\n      modifier: "",\r\n      priority: 0,\r\n      value: 0,\r\n    };\r\n  }\r\n\r\n  static get defaultContextNote() {\r\n    return {\r\n      text: "",\r\n      target: "",\r\n      subTarget: "",\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generic charge addition (or subtraction) function that either adds charges\r\n   * or quantity, based on item data.\r\n   * @param {number} value       - The amount of charges to add.\r\n   * @returns {Promise}\r\n   */\r\n  async addCharges(value) {\r\n    // Add link charges\r\n    const link = getProperty(this, "links.charges");\r\n    if (link) return link.addCharges(value);\r\n\r\n    // Add own charges\r\n    if ( getProperty(this.data, "data.uses.per") === "single"\r\n      && getProperty(this.data, "data.quantity") == null) return;\r\n\r\n    if (this.type === "spell") return this.addSpellUses(value);\r\n\r\n    let prevValue = this.isSingleUse ? getProperty(this.data, "data.quantity") : getProperty(this.data, "data.uses.value");\r\n\r\n    if (this.isSingleUse) await this.update({ "data.quantity"  : prevValue + value });\r\n    else                  await this.update({ "data.uses.value": prevValue + value });\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Does the Item implement a damage roll as part of its usage\r\n   * @type {boolean}\r\n   */\r\n  get hasDamage() {\r\n    return !!(this.data.data.damage && this.data.data.damage.parts.length);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Does the item provide an amount of healing instead of conventional damage?\r\n   * @return {boolean}\r\n   */\r\n  get isHealing() {\r\n    return (this.data.data.actionType === "heal") && this.data.data.damage.parts.length;\r\n  }\r\n\r\n  get hasEffect() {\r\n    return this.hasDamage || (this.data.data.effectNotes && this.data.data.effectNotes.length > 0);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Does the Item implement a saving throw as part of its usage\r\n   * @type {boolean}\r\n   */\r\n  get hasSave() {\r\n    return !!(this.data.data.save && this.data.data.save.ability);\r\n  }\r\n\r\n  /**\r\n   * Should the item show unidentified data\r\n   * @type {boolean}\r\n   */\r\n  get showUnidentifiedData() {\r\n    return (!game.user.isGM && getProperty(this.data, "data.identified") === false);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*\tData Preparation\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Augment the basic Item data model with additional dynamic data.\r\n   */\r\n  prepareData() {\r\n    super.prepareData();\r\n\r\n    const itemData = this.data;\r\n    const data = itemData.data;\r\n    const C = CONFIG.PF1;\r\n    const labels = {};\r\n\r\n    // Physical items\r\n    if (hasProperty(itemData, "data.weight")) {\r\n      // Sync name\r\n      if (!hasProperty(this.data, "data.identifiedName")) setProperty(this.data, "data.identifiedName", this.name);\r\n      // Prepare unidentified cost\r\n      if (!hasProperty(this.data, "data.unidentified.price")) setProperty(this.data, "data.unidentified.price", 0);\r\n\r\n      // Set basic data\r\n      itemData.data.hp = itemData.data.hp || { max: 10, value: 10 };\r\n      itemData.data.hardness = itemData.data.hardness || 0;\r\n      itemData.data.carried = itemData.data.carried == null ? true : itemData.data.carried;\r\n\r\n      // Equipped label\r\n      labels.equipped = "";\r\n      if (itemData.data.equipped === true) labels.equipped = game.i18n.localize("PF1.Yes");\r\n      else labels.equipped = game.i18n.localize("PF1.No");\r\n\r\n      // Carried label\r\n      labels.carried = "";\r\n      if (itemData.data.carried === true) labels.carried = game.i18n.localize("PF1.Yes");\r\n      else labels.carried = game.i18n.localize("PF1.No");\r\n\r\n      // Identified label\r\n      labels.identified = "";\r\n      if (itemData.data.identified === true) labels.identified = game.i18n.localize("PF1.YesShort");\r\n      else labels.identified = game.i18n.localize("PF1.NoShort");\r\n\r\n      // Slot label\r\n      if (itemData.data.slot) {\r\n        // Add equipment slot\r\n        const equipmentType = getProperty(this.data, "data.equipmentType") || null;\r\n        if (equipmentType != null) {\r\n          const equipmentSlot = getProperty(this.data, "data.slot") || null;\r\n          labels.slot = equipmentSlot == null ? null : CONFIG.PF1.equipmentSlots[equipmentType][equipmentSlot];\r\n        }\r\n        else labels.slot = null;\r\n      }\r\n    }\r\n\r\n    // Spell Level,  School, and Components\r\n    if ( itemData.type === "spell" ) {\r\n      labels.level = C.spellLevels[data.level];\r\n      labels.school = C.spellSchools[data.school];\r\n      labels.components = Object.entries(data.components).map(c => {\r\n        c[1] === true ? c[0].titleCase().slice(0,1) : null\r\n      }).filterJoin(",");\r\n    }\r\n\r\n    // Feat Items\r\n    else if ( itemData.type === "feat" ) {\r\n      labels.featType = C.featTypes[data.featType];\r\n\r\n      // Ability type\r\n      if (data.abilityType && data.abilityType !== "none") {\r\n        labels.abilityType = C.abilityTypes[data.abilityType].short;\r\n      }\r\n      else if (labels.abilityType) {\r\n        delete labels.abilityType;\r\n      }\r\n    }\r\n\r\n    // Buff Items\r\n    else if (itemData.type === "buff") {\r\n      labels.buffType = C.buffTypes[data.buffType];\r\n    }\r\n\r\n    // Weapon Items\r\n    else if (itemData.type === "weapon") {\r\n      // Type and subtype labels\r\n      let wType = getProperty(this.data, "data.weaponType");\r\n      let typeKeys = Object.keys(C.weaponTypes);\r\n      if (!typeKeys.includes(wType)) wType = typeKeys[0];\r\n\r\n      let wSubtype = getProperty(this.data, "data.weaponSubtype");\r\n      let subtypeKeys = Object.keys(C.weaponTypes[wType]).filter(o => !o.startsWith("_"));\r\n      if (!subtypeKeys.includes(wSubtype)) wSubtype = subtypeKeys[0];\r\n\r\n      labels.weaponType = C.weaponTypes[wType]._label;\r\n      labels.weaponSubtype = C.weaponTypes[wType][wSubtype];\r\n    }\r\n\r\n    // Equipment Items\r\n    else if (itemData.type === "equipment") {\r\n      // Type and subtype labels\r\n      let eType = getProperty(this.data, "data.equipmentType");\r\n      let typeKeys = Object.keys(C.equipmentTypes);\r\n      if (!typeKeys.includes(eType)) eType = typeKeys[0];\r\n\r\n      let eSubtype = getProperty(this.data, "data.equipmentSubtype");\r\n      let subtypeKeys = Object.keys(C.equipmentTypes[eType]).filter(o => !o.startsWith("_"));\r\n      if (!subtypeKeys.includes(eSubtype)) eSubtype = subtypeKeys[0];\r\n\r\n      labels.equipmentType = C.equipmentTypes[eType]._label;\r\n      labels.equipmentSubtype = C.equipmentTypes[eType][eSubtype];\r\n\r\n      // AC labels\r\n      labels.armor = data.armor.value ? `${data.armor.value} AC` : "";\r\n      if (data.armor.dex === "") data.armor.dex = null;\r\n      else if (typeof data.armor.dex === "string" && /\\d+/.test(data.armor.dex)) {\r\n        data.armor.dex = parseInt(data.armor.dex);\r\n      }\r\n      // Add enhancement bonus\r\n      if (data.armor.enh == null) data.armor.enh = 0;\r\n    }\r\n\r\n    // Activated Items\r\n    if ( data.hasOwnProperty("activation") ) {\r\n\r\n      // Ability Activation Label\r\n      let act = data.activation || {};\r\n      if (act) labels.activation = [["minute", "hour"].includes(act.type) ? act.cost.toString() : "", C.abilityActivationTypes[act.type]].filterJoin(" ");\r\n\r\n      // Target Label\r\n      let tgt = data.target || {};\r\n      if (["none", "touch", "personal"].includes(tgt.units)) tgt.value = null;\r\n      if (["none", "personal"].includes(tgt.type)) {\r\n        tgt.value = null;\r\n        tgt.units = null;\r\n      }\r\n      labels.target = [tgt.value, C.distanceUnits[tgt.units], C.targetTypes[tgt.type]].filterJoin(" ");\r\n      if (labels.target) labels.target = `Target: ${labels.target}`;\r\n\r\n      // Range Label\r\n      let rng = data.range || {};\r\n      if (!["ft", "mi", "spec"].includes(rng.units)) {\r\n        rng.value = null;\r\n        rng.long = null;\r\n      }\r\n      labels.range = [rng.value, rng.long ? `/ ${rng.long}` : null, C.distanceUnits[rng.units]].filterJoin(" ");\r\n      if (labels.range.length > 0) labels.range = ["Range:", labels.range].join(" ");\r\n\r\n      // Duration Label\r\n      let dur = data.duration || {};\r\n      if (["inst", "perm", "spec"].includes(dur.units)) dur.value = null;\r\n      labels.duration = [dur.value, C.timePeriods[dur.units]].filterJoin(" ");\r\n    }\r\n\r\n    // Item Actions\r\n    if ( data.hasOwnProperty("actionType") ) {\r\n      // Save DC\r\n      let save = data.save || {};\r\n      if (save.type) {\r\n        labels.save = `DC ${this.dc}`;\r\n      }\r\n\r\n      // Damage\r\n      let dam = data.damage || {};\r\n      if ( dam.parts ) {\r\n        labels.damage = dam.parts.map(d => d[0]).join(" + ").replace(/\\+ -/g, "- ");\r\n        labels.damageTypes = dam.parts.map(d => d[1]).join(", ");\r\n      }\r\n\r\n      // Add attack parts\r\n      if (!data.attack) data.attack = { parts: [] };\r\n    }\r\n\r\n    // Assign labels\r\n    this.labels = labels;\r\n\r\n    this.prepareLinks();\r\n  }\r\n\r\n  prepareLinks() {\r\n    if (!this.links) return;\r\n\r\n    for (let [k, i] of Object.entries(this.links)) {\r\n      switch(k) {\r\n        case "charges":\r\n          const uses = i.data.data.uses;\r\n          for (let [k, v] of Object.entries(uses)) {\r\n            if (["autoDeductCharges", "autoDeductChargesCost"].includes(k)) continue;\r\n            this.data.data.uses[k] = v;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  async update(data, options={}) {\r\n    const srcData = mergeObject(this.data, expandObject(data), { inplace: false });\r\n\r\n    // Update name\r\n    if (data["data.identifiedName"]) data["name"] = data["data.identifiedName"];\r\n    else if (data["name"]) data["data.identifiedName"] = data["name"];\r\n\r\n    // Update description\r\n    if (this.type === "spell") await this._updateSpellDescription(data, srcData);\r\n\r\n    // Set weapon subtype\r\n    if (data["data.weaponType"] != null && data["data.weaponType"] !== getProperty(this.data, "data.weaponType")) {\r\n      const type = data["data.weaponType"];\r\n      const subtype = data["data.weaponSubtype"] || getProperty(this.data, "data.weaponSubtype") || "";\r\n      const keys = Object.keys(CONFIG.PF1.weaponTypes[type])\r\n        .filter(o => !o.startsWith("_"));\r\n      if (!subtype || !keys.includes(subtype)) {\r\n        data["data.weaponSubtype"] = keys[0];\r\n      }\r\n    }\r\n\r\n    // Set equipment subtype and slot\r\n    if (data["data.equipmentType"] != null && data["data.equipmentType"] !== getProperty(this.data, "data.equipmentType")) {\r\n      // Set subtype\r\n      const type = data["data.equipmentType"];\r\n      const subtype = data["data.equipmentSubtype"] || getProperty(this.data, "data.equipmentSubtype") || "";\r\n      let keys = Object.keys(CONFIG.PF1.equipmentTypes[type])\r\n        .filter(o => !o.startsWith("_"));\r\n      if (!subtype || !keys.includes(subtype)) {\r\n        data["data.equipmentSubtype"] = keys[0];\r\n      }\r\n\r\n      // Set slot\r\n      const slot = data["data.slot"] || getProperty(this.data, "data.slot") || "";\r\n      keys = Object.keys(CONFIG.PF1.equipmentSlots[type]);\r\n      if (!slot || !keys.includes(slot)) {\r\n        data["data.slot"] = keys[0];\r\n      }\r\n    }\r\n\r\n    // Set previous data\r\n    this._prevData["level"] = getProperty(this.data, "data.level");\r\n\r\n    // Update maximum uses\r\n    this._updateMaxUses(data, {srcData: srcData});\r\n\r\n    // Update charges for linked items\r\n    if (data["data.uses.value"] != null) {\r\n      const link = getProperty(this, "links.charges");\r\n      if (link && getProperty(link, "links.charges") == null) {\r\n        await link.update({"data.uses.value": data["data.uses.value"]});\r\n      }\r\n    }\r\n\r\n    const diff = diffObject(flattenObject(this.data), data);\r\n    if (Object.keys(diff).length) {\r\n      return super.update(diff, options);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _onUpdate(data, options, userId, context) {\r\n    super._onUpdate(data, options, userId, context);\r\n\r\n    // Get changed attributes\r\n    const changed = new Set(Object.keys(data));\r\n\r\n    // Level changed\r\n    if (changed.has("data.level")) {\r\n      this._onLevelChange(this._prevData["level"], data["data.level"]);\r\n    }\r\n  }\r\n\r\n  _updateMaxUses(data, {srcData=null}={}) {\r\n    let doLinkData = true;\r\n    if (srcData == null) {\r\n      srcData = this.data;\r\n      doLinkData = false;\r\n    }\r\n    const rollData = this.getRollData();\r\n\r\n    if (hasProperty(srcData, "data.uses.maxFormula")) {\r\n      if (getProperty(srcData, "data.uses.maxFormula") !== "") {\r\n        let roll = new Roll(getProperty(srcData, "data.uses.maxFormula"), rollData).roll();\r\n        if (doLinkData) Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, data, "data.uses.max", roll.total);\r\n        else data["data.uses.max"] = roll.total;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Roll the item to Chat, creating a chat card which contains follow up attack or damage roll options\r\n   * @return {Promise}\r\n   */\r\n  async roll(altChatData={}, {addDC=true}={}) {\r\n    const actor = this.actor;\r\n    if (actor && !actor.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    // Basic template rendering data\r\n    const token = this.actor.token;\r\n    const saveType = getProperty(this.data, "data.save.type");\r\n    const saveDC = this.dc;\r\n    const templateData = {\r\n      actor: this.actor,\r\n      tokenId: token ? `${token.scene._id}.${token.id}` : null,\r\n      item: this.data,\r\n      data: this.getChatData(),\r\n      labels: this.labels,\r\n      hasAttack: this.hasAttack,\r\n      hasMultiAttack: this.hasMultiAttack,\r\n      hasAction: this.hasAction || this.isCharged,\r\n      isHealing: this.isHealing,\r\n      hasDamage: this.hasDamage,\r\n      hasEffect: this.hasEffect,\r\n      isVersatile: this.isVersatile,\r\n      hasSave: this.hasSave,\r\n      isSpell: this.data.type === "spell",\r\n      save: {\r\n        hasSave: addDC === true && typeof saveType === "string" && saveType.length > 0,\r\n        dc: saveDC,\r\n        type: saveType,\r\n        label: game.i18n.localize("PF1.SavingThrowButtonLabel").format(CONFIG.PF1.savingThrows[saveType], saveDC.toString()),\r\n      },\r\n    };\r\n\r\n    // Roll spell failure chance\r\n    if (templateData.isSpell && this.actor != null && this.actor.spellFailure > 0) {\r\n      const spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`);\r\n      if (spellbook && spellbook.arcaneSpellFailure) {\r\n        templateData.spellFailure = new Roll("1d100").roll().total;\r\n        templateData.spellFailureSuccess = templateData.spellFailure > this.actor.spellFailure;\r\n      }\r\n    }\r\n\r\n    // Render the chat card template\r\n    const templateType = ["consumable"].includes(this.data.type) ? this.data.type : "item";\r\n    const template = `systems/pf1/templates/chat/${templateType}-card.html`;\r\n\r\n    // Basic chat message data\r\n    const chatData = mergeObject({\r\n      user: game.user._id,\r\n      type: CONST.CHAT_MESSAGE_TYPES.OTHER,\r\n      speaker: ChatMessage.getSpeaker({ actor: this.actor }),\r\n    }, altChatData);\r\n\r\n    // Toggle default roll mode\r\n    let rollMode = chatData.rollMode || game.settings.get("core", "rollMode");\r\n    if ( ["gmroll", "blindroll"].includes(rollMode) ) chatData["whisper"] = ChatMessage.getWhisperRecipients("GM");\r\n    if ( rollMode === "blindroll" ) chatData["blind"] = true;\r\n\r\n    // Create the chat message\r\n    return Object(_chat_js__WEBPACK_IMPORTED_MODULE_1__["createCustomChatMessage"])(template, templateData, chatData);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Chat Cards\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\r\n  /* -------------------------------------------- */\r\n\r\n  getChatData(htmlOptions) {\r\n    const data = duplicate(this.data.data);\r\n    const labels = this.labels;\r\n\r\n    const rollData = this.getRollData();\r\n\r\n    htmlOptions = mergeObject(htmlOptions || {}, {\r\n      rollData: rollData,\r\n    });\r\n\r\n    // Rich text description\r\n    if (this.showUnidentifiedData) {\r\n      data.description.value = TextEditor.enrichHTML(data.description.unidentified, htmlOptions);\r\n    }\r\n    else {\r\n      data.description.value = TextEditor.enrichHTML(data.description.value, htmlOptions);\r\n    }\r\n\r\n    // General equipment properties\r\n    const props = [];\r\n    if ( data.hasOwnProperty("equipped") && ["weapon", "equipment"].includes(this.data.type) ) {\r\n      props.push(\r\n        data.equipped ? game.i18n.localize("PF1.Equipped") : game.i18n.localize("PF1.NotEquipped"),\r\n      );\r\n    }\r\n\r\n    if (!this.showUnidentifiedData) {\r\n      // Gather dynamic labels\r\n      const dynamicLabels = {};\r\n      dynamicLabels.range = labels.range || "";\r\n      dynamicLabels.level = labels.sl || "";\r\n      // Range\r\n      if (data.range != null) {\r\n        if (data.range.units === "close") dynamicLabels.range = game.i18n.localize("PF1.RangeNote").format(25 + Math.floor(rollData.cl / 2) * 5);\r\n        else if (data.range.units === "medium") dynamicLabels.range = game.i18n.localize("PF1.RangeNote").format(100 + rollData.cl * 10);\r\n        else if (data.range.units === "long") dynamicLabels.range = game.i18n.localize("PF1.RangeNote").format(400 + rollData.cl * 40);\r\n        else if (["ft", "mi", "spec"].includes(data.range.units) && typeof data.range.value === "string") {\r\n          let range = new Roll(data.range.value.length > 0 ? data.range.value : "0", rollData).roll().total;\r\n          dynamicLabels.range = [range > 0 ? "Range:" : null, range, CONFIG.PF1.distanceUnits[data.range.units]].filterJoin(" ");\r\n        }\r\n      }\r\n      // Duration\r\n      if (data.duration != null) {\r\n        if (!["inst", "perm"].includes(data.duration.units) && typeof data.duration.value === "string") {\r\n          let duration = new Roll(data.duration.value.length > 0 ? data.duration.value : "0", rollData).roll().total;\r\n          dynamicLabels.duration = [duration, CONFIG.PF1.timePeriods[data.duration.units]].filterJoin(" ");\r\n        }\r\n      }\r\n\r\n      // Item type specific properties\r\n      const fn = this[`_${this.data.type}ChatData`];\r\n      if (fn) fn.bind(this)(data, labels, props);\r\n\r\n      // Ability activation properties\r\n      if ( data.hasOwnProperty("activation") ) {\r\n        props.push(\r\n          labels.target,\r\n          labels.activation,\r\n          dynamicLabels.range,\r\n          dynamicLabels.duration\r\n        );\r\n      }\r\n\r\n      // Add save DC\r\n      if (data.hasOwnProperty("actionType") && getProperty(data, "save.description")) {\r\n        let saveDC = this.dc;\r\n        let saveDesc = data.save.description;\r\n        if (saveDC > 0 && saveDesc) {\r\n          props.push(`DC ${saveDC}`);\r\n          props.push(saveDesc);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add SR reminder\r\n    if (this.type === "spell") {\r\n      if (data.sr) {\r\n        props.push(game.i18n.localize("PF1.SpellResistance"));\r\n      }\r\n    }\r\n\r\n    // Add ability type label\r\n    if (this.type === "feat") {\r\n      if (labels.abilityType) {\r\n        props.push(labels.abilityType);\r\n      }\r\n    }\r\n\r\n    // Filter properties and return\r\n    data.properties = props.filter(p => !!p);\r\n    return data;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare chat card data for equipment type items\r\n   * @private\r\n   */\r\n  _equipmentChatData(data, labels, props) {\r\n    props.push(\r\n      CONFIG.PF1.equipmentTypes[data.equipmentType][data.equipmentSubtype],\r\n      labels.armor || null,\r\n    );\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare chat card data for weapon type items\r\n   * @private\r\n   */\r\n  _weaponChatData(data, labels, props) {\r\n    props.push(\r\n      CONFIG.PF1.weaponTypes[data.weaponType]._label,\r\n      CONFIG.PF1.weaponTypes[data.weaponType][data.weaponSubtype],\r\n    );\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare chat card data for consumable type items\r\n   * @private\r\n   */\r\n  _consumableChatData(data, labels, props) {\r\n    props.push(\r\n      CONFIG.PF1.consumableTypes[data.consumableType]\r\n    );\r\n    if (["day", "week", "charges"].includes(data.uses.per)) {\r\n      props.push(data.uses.value + "/" + data.uses.max + " Charges");\r\n    }\r\n    else props.push(CONFIG.PF1.limitedUsePeriods[data.uses.per]);\r\n    data.hasCharges = data.uses.value >= 0;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare chat card data for tool type items\r\n   * @private\r\n   */\r\n  _lootChatData(data, labels, props) {\r\n    props.push(\r\n      data.weight ? data.weight + " " + (game.settings.get("pf1", "units") === "metric" ? game.i18n.localize("PF1.Kgs") : game.i18n.localize("PF1.Lbs")) : null\r\n    );\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Render a chat card for Spell type data\r\n   * @return {Object}\r\n   * @private\r\n   */\r\n  _spellChatData(data, labels, props) {\r\n    const ad = this.actor.data.data;\r\n\r\n    // Spell saving throw text\r\n    // const abl = data.ability || ad.attributes.spellcasting || "int";\r\n    // if ( this.hasSave && !data.save.dc ) data.save.dc = 8 + ad.abilities[abl].mod + ad.attributes.prof;\r\n    // labels.save = `DC ${data.save.dc} ${CONFIG.PF1.abilities[data.save.ability]}`;\r\n\r\n    // Spell properties\r\n    props.push(\r\n      labels.level,\r\n      labels.components,\r\n    );\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare chat card data for items of the "Feat" type\r\n   */\r\n  _featChatData(data, labels, props) {\r\n    const ad = this.actor.data.data;\r\n\r\n    // Spell saving throw text\r\n    // const abl = data.ability || ad.attributes.spellcasting || "str";\r\n    // if ( this.hasSave && !data.save.dc ) data.save.dc = 8 + ad.abilities[abl].mod + ad.attributes.prof;\r\n    // labels.save = `DC ${data.save.dc} ${CONFIG.PF1.abilities[data.save.ability]}`;\r\n\r\n    // Feat properties\r\n    props.push(\r\n      CONFIG.PF1.featTypes[data.featType]\r\n    );\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Item Rolls - Attack, Damage, Saves, Checks  */\r\n  /* -------------------------------------------- */\r\n\r\n  async use({ev=null, skipDialog=false}) {\r\n    if (this.type === "spell") {\r\n      return this.actor.useSpell(this, ev, {skipDialog: skipDialog});\r\n    }\r\n    else if (this.hasAction) {\r\n      return this.useAttack({ev: ev, skipDialog: skipDialog});\r\n    }\r\n\r\n    if (this.isCharged) {\r\n      if (this.charges <= 0) {\r\n        if (this.isSingleUse) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoQuantity"));\r\n        return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoCharges").format(this.name));\r\n      }\r\n      if (this.autoDeductCharges) {\r\n        this.addCharges(-this.chargeCost);\r\n      }\r\n    }\r\n    this.roll();\r\n  }\r\n\r\n  async useAttack({ev=null, skipDialog=false}={}) {\r\n    if (ev && ev.originalEvent) ev = ev.originalEvent;\r\n    const actor = this.actor;\r\n    if (actor && !actor.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n\r\n    const itemQuantity = getProperty(this.data, "data.quantity");\r\n    if (itemQuantity != null && itemQuantity <= 0) {\r\n      return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoQuantity"));\r\n    }\r\n\r\n    if (this.isCharged && this.charges <= 0) {\r\n      return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoCharges").format(this.name));\r\n    }\r\n\r\n    const rollData = this.getRollData();\r\n\r\n    let rolled = false;\r\n    const _roll = async function(fullAttack, form) {\r\n      let attackExtraParts = [],\r\n        damageExtraParts = [],\r\n        primaryAttack = true,\r\n        useMeasureTemplate = false,\r\n        rollMode = game.settings.get("core", "rollMode");\r\n      // Get form data\r\n      if (form) {\r\n        rollData.attackBonus = form.find(\'[name="attack-bonus"]\').val();\r\n        if (rollData.attackBonus) attackExtraParts.push("@attackBonus");\r\n        rollData.damageBonus = form.find(\'[name="damage-bonus"]\').val();\r\n        if (rollData.damageBonus) damageExtraParts.push("@damageBonus");\r\n        rollMode = form.find(\'[name="rollMode"]\').val();\r\n\r\n        // Power Attack\r\n        if (form.find(\'[name="power-attack"]\').prop("checked")) {\r\n          rollData.powerAttackBonus = (1 + Math.floor(getProperty(rollData, "attributes.bab.total") / 4)) * 2;\r\n          damageExtraParts.push("floor(@powerAttackBonus * max(0.5, min(1.5, @ablMult))) * @critMult");\r\n          rollData.powerAttackPenalty = -(1 + Math.floor(getProperty(rollData, "attributes.bab.total") / 4));\r\n          attackExtraParts.push("@powerAttackPenalty");\r\n        }\r\n        \r\n        // Point-Blank Shot\r\n        if (form.find(\'[name="point-blank-shot"]\').prop("checked")) {\r\n          rollData.pointBlankBonus = 1;\r\n          attackExtraParts.push("@pointBlankBonus");\r\n          damageExtraParts.push("@pointBlankBonus");\r\n        }\r\n        \r\n        // Rapid Shot\r\n        if (form.find(\'[name="rapid-shot"]\').prop("checked")) {\r\n          rollData.rapidShotPenalty = -2;\r\n          attackExtraParts.push("@rapidShotPenalty");\r\n        }\r\n        \r\n        // Primary Attack (for natural attacks)\r\n        let html = form.find(\'[name="primary-attack"]\');\r\n        if (typeof html.prop("checked") === "boolean") {\r\n          primaryAttack = html.prop("checked");\r\n        }\r\n        // Use measure template\r\n        html = form.find(\'[name="measure-template"]\');\r\n        if (typeof html.prop("checked") === "boolean") {\r\n          useMeasureTemplate = html.prop("checked");\r\n        }\r\n        // Damage ability multiplier\r\n        html = form.find(\'[name="damage-ability-multiplier"]\');\r\n        if (html.length > 0) {\r\n          rollData.item.ability.damageMult = parseFloat(html.val());\r\n        }\r\n      }\r\n\r\n      // Prepare the chat message data\r\n      let chatTemplateData = {\r\n        name: this.name,\r\n        type: CONST.CHAT_MESSAGE_TYPES.OTHER,\r\n        rollMode: rollMode,\r\n      };\r\n\r\n      // Create attacks\r\n      const allAttacks = fullAttack ? this.data.data.attackParts.reduce((cur, r) => {\r\n        cur.push({ bonus: r[0], label: r[1] });\r\n        return cur;\r\n      }, [{ bonus: "", label: `${game.i18n.localize("PF1.Attack")}` }]) : [{ bonus: "", label: `${game.i18n.localize("PF1.Attack")}` }];\r\n      let attacks = [];\r\n      if (this.hasAttack) {\r\n        for (let a = 0; a < allAttacks.length; a++) {\r\n          let atk = allAttacks[a];\r\n          // Create attack object\r\n          let attack = new _misc_chat_attack_js__WEBPACK_IMPORTED_MODULE_5__["ChatAttack"](this, {label: atk.label, rollData: rollData, primaryAttack: primaryAttack});\r\n\r\n          // Add attack roll\r\n          await attack.addAttack({bonus: atk.bonus, extraParts: attackExtraParts});\r\n\r\n          // Add damage\r\n          if (this.hasDamage) {\r\n            await attack.addDamage({extraParts: damageExtraParts, critical: false});\r\n\r\n            // Add critical hit damage\r\n            if (attack.hasCritConfirm) {\r\n              await attack.addDamage({extraParts: damageExtraParts, critical: true});\r\n            }\r\n          }\r\n\r\n          // Add attack notes\r\n          if (a === 0) attack.addAttackNotes();\r\n\r\n          // Add effect notes\r\n          attack.addEffectNotes();\r\n\r\n          // Add to list\r\n          attacks.push(attack);\r\n          \r\n          if (a === 0 && form && form.find(\'[name="rapid-shot"]\').prop("checked")) {\r\n            let rapidShotAttack = new _misc_chat_attack_js__WEBPACK_IMPORTED_MODULE_5__["ChatAttack"](this, {label: game.i18n.localize("PF1.RapidShot"), rollData: rollData, primaryAttack: primaryAttack});\r\n            await rapidShotAttack.addAttack({bonus: atk.bonus, extraParts: attackExtraParts});\r\n\r\n            // Add damage\r\n            if (this.hasDamage) {\r\n              await rapidShotAttack.addDamage({extraParts: damageExtraParts, critical: false});\r\n  \r\n              // Add critical hit damage\r\n              if (rapidShotAttack.hasCritConfirm) {\r\n                await rapidShotAttack.addDamage({extraParts: damageExtraParts, critical: true});\r\n              }\r\n            }\r\n  \r\n            // Add effect notes\r\n            rapidShotAttack.addEffectNotes();\r\n            \r\n            attacks.push(rapidShotAttack);\r\n          }\r\n        }\r\n      }\r\n      // Add damage only\r\n      else if (this.hasDamage) {\r\n        let attack = new _misc_chat_attack_js__WEBPACK_IMPORTED_MODULE_5__["ChatAttack"](this, {rollData: rollData, primaryAttack: primaryAttack});\r\n        // Add damage\r\n        await attack.addDamage({extraParts: damageExtraParts, critical: false});\r\n\r\n        // Add attack notes\r\n        attack.addAttackNotes();\r\n\r\n        // Add effect notes\r\n        attack.addEffectNotes();\r\n\r\n        // Add to list\r\n        attacks.push(attack);\r\n      }\r\n      // Add effect notes only\r\n      else if (this.hasEffect) {\r\n        let attack = new _misc_chat_attack_js__WEBPACK_IMPORTED_MODULE_5__["ChatAttack"](this, {rollData: rollData, primaryAttack: primaryAttack});\r\n\r\n        // Add attack notes\r\n        attack.addAttackNotes();\r\n\r\n        // Add effect notes\r\n        attack.addEffectNotes();\r\n        \r\n        // Add to list\r\n        attacks.push(attack);\r\n      }\r\n      chatTemplateData.attacks = attacks;\r\n\r\n      // Prompt measure template\r\n      if (useMeasureTemplate) {\r\n        // Gather data\r\n        let dist = getProperty(this.data, "data.measureTemplate.size");\r\n        if (typeof dist === "string") {\r\n          dist = new Roll(getProperty(this.data, "data.measureTemplate.size"), this.getRollData()).roll().total;\r\n        }\r\n        const templateOptions = {\r\n          type: getProperty(this.data, "data.measureTemplate.type"),\r\n          distance: dist,\r\n        };\r\n        if (getProperty(this.data, "data.measureTemplate.overrideColor")) {\r\n          templateOptions.color = getProperty(this.data, "data.measureTemplate.customColor");\r\n        }\r\n        if (getProperty(this.data, "data.measureTemplate.overrideTexture")) {\r\n          templateOptions.texture = getProperty(this.data, "data.measureTemplate.customTexture");\r\n        }\r\n\r\n        // Create template\r\n        const template = _pixi_ability_template_js__WEBPACK_IMPORTED_MODULE_4__["AbilityTemplate"].fromData(templateOptions);\r\n        if (template) {\r\n          if (getProperty(this, "actor.sheet.rendered")) this.actor.sheet.minimize();\r\n          const success = await template.drawPreview(ev);\r\n          if (!success) {\r\n            if (getProperty(this, "actor.sheet.rendered")) this.actor.sheet.maximize();\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Deduct charge\r\n      if (this.autoDeductCharges) {\r\n        this.addCharges(-this.chargeCost);\r\n      }\r\n      \r\n      // Set chat data\r\n      let chatData = {\r\n        speaker: ChatMessage.getSpeaker({actor: this.actor}),\r\n        rollMode: rollMode,\r\n        sound: CONFIG.sounds.dice,\r\n        "flags.pf1.noRollRender": true,\r\n      };\r\n\r\n      // Send spell info\r\n      const hasAction = this.hasAttack || this.hasDamage || this.hasEffect;\r\n      if (this.data.type === "spell" && !hasAction) await this.roll({ rollMode: rollMode }, {addDC: hasAction ? false : true});\r\n\r\n      // Dice So Nice integration\r\n      if (game.dice3d != null && game.dice3d.isEnabled()) {\r\n        let dice3dData = attacks.reduce((obj, a) => {\r\n          if (a.attack.roll != null)      obj.results.push(a.attack.roll.parts[0].total);\r\n          if (a.critConfirm.roll != null) obj.results.push(a.critConfirm.roll.parts[0].total);\r\n          return obj;\r\n        }, {\r\n          formula: "",\r\n          results: [],\r\n          whisper: [],\r\n          blind: false,\r\n        });\r\n        if (dice3dData.results.length) {\r\n          dice3dData.formula = `${dice3dData.results.length}d20`;\r\n          // Handle different roll modes\r\n          switch (rollMode) {\r\n            case "gmroll":\r\n              dice3dData.whisper = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n              break;\r\n            case "selfroll":\r\n              dice3dData.whisper = [game.user._id];\r\n              break;\r\n            case "blindroll":\r\n              dice3dData.whisper = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n              dice3dData.blind = true;\r\n              break;\r\n          }\r\n          // Roll 3D dice\r\n          chatData.sound = null;\r\n          await game.dice3d.show(dice3dData);\r\n        }\r\n      }\r\n      \r\n      // Post message\r\n      if (hasAction) {\r\n        // Get extra text and properties\r\n        let props = [];\r\n        let extraText = "";\r\n        if (chatTemplateData.attacks.length > 0) extraText = chatTemplateData.attacks[0].attackNotesHTML;\r\n\r\n        const properties = this.getChatData().properties;\r\n        if (properties.length > 0) props.push({ header: game.i18n.localize("PF1.InfoShort"), value: properties });\r\n\r\n        // Get saving throw data\r\n        const save = getProperty(this.data, "data.save.type");\r\n        const saveDC = this.dc;\r\n\r\n        const templateData = mergeObject(chatTemplateData, {\r\n          extraText: extraText,\r\n          hasExtraText: extraText.length > 0,\r\n          properties: props,\r\n          hasProperties: props.length > 0,\r\n          item: this.data,\r\n          actor: this.actor.data,\r\n          save: {\r\n            hasSave: typeof save === "string" && save.length > 0,\r\n            dc: saveDC,\r\n            type: save,\r\n            label: game.i18n.localize("PF1.SavingThrowButtonLabel").format(CONFIG.PF1.savingThrows[save], saveDC.toString()),\r\n          },\r\n        }, { inplace: false });\r\n        // Spell failure\r\n        if (this.type === "spell" && this.actor != null && this.actor.spellFailure > 0) {\r\n          const spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`);\r\n          if (spellbook && spellbook.arcaneSpellFailure) {\r\n            templateData.spellFailure = new Roll("1d100").roll().total;\r\n            templateData.spellFailureSuccess = templateData.spellFailure > this.actor.spellFailure;\r\n          }\r\n        }\r\n        // Create message\r\n        await Object(_chat_js__WEBPACK_IMPORTED_MODULE_1__["createCustomChatMessage"])("systems/pf1/templates/chat/attack-roll.html", templateData, chatData);\r\n      }\r\n    };\r\n\r\n    // Handle fast-forwarding\r\n    if (skipDialog || (ev instanceof MouseEvent && (ev.shiftKey || ev.button === 2))) return _roll.call(this, true);\r\n\r\n    // Render modal dialog\r\n    let template = "systems/pf1/templates/apps/attack-roll-dialog.html";\r\n    let dialogData = {\r\n      data: rollData,\r\n      item: this.data.data,\r\n      rollMode: game.settings.get("core", "rollMode"),\r\n      rollModes: CONFIG.Dice.rollModes,\r\n      hasAttack: this.hasAttack,\r\n      hasDamage: this.hasDamage,\r\n      hasDamageAbility: getProperty(this.data, "data.ability.damage") !== "",\r\n      isNaturalAttack: getProperty(this.data, "data.attackType") === "natural",\r\n      isWeaponAttack: getProperty(this.data, "data.attackType") === "weapon",\r\n      hasTemplate: this.hasTemplate,\r\n    };\r\n    const html = await renderTemplate(template, dialogData);\r\n\r\n    let roll;\r\n    const buttons = {};\r\n    if (this.hasAttack) {\r\n      if (this.type !== "spell") {\r\n        buttons.normal = {\r\n          label: game.i18n.localize("PF1.SingleAttack"),\r\n          callback: html => roll = _roll.call(this, false, html)\r\n        };\r\n      }\r\n      if ((getProperty(this.data, "data.attackParts") || []).length || this.type === "spell") {\r\n        buttons.multi = {\r\n          label: this.type === "spell" ? game.i18n.localize("PF1.Cast") : game.i18n.localize("PF1.FullAttack"),\r\n          callback: html => roll = _roll.call(this, true, html)\r\n        };\r\n      }\r\n    }\r\n    else {\r\n      buttons.normal = {\r\n        label: this.type === "spell" ? game.i18n.localize("PF1.Cast") : game.i18n.localize("PF1.Use"),\r\n        callback: html => roll = _roll.call(this, false, html)\r\n      };\r\n    }\r\n    return new Promise(resolve => {\r\n      new Dialog({\r\n        title: `${game.i18n.localize("PF1.Use")}: ${this.name}`,\r\n        content: html,\r\n        buttons: buttons,\r\n        default: buttons.multi != null ? "multi" : "normal",\r\n        close: html => {\r\n          resolve(rolled ? roll : false);\r\n        }\r\n      }).render(true);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Place an attack roll using an item (weapon, feat, spell, or equipment)\r\n   * Rely upon the DicePF.d20Roll logic for the core implementation\r\n   */\r\n  rollAttack({data=null, extraParts=[], bonus=null, primaryAttack=true}={}) {\r\n    const itemData = this.data.data;\r\n    const rollData = mergeObject(this.getRollData(), data || {});\r\n\r\n    // Determine size bonus\r\n    rollData.sizeBonus = CONFIG.PF1.sizeMods[rollData.traits.size];\r\n    // Add misc bonuses/penalties\r\n    rollData.item.proficiencyPenalty = -4;\r\n\r\n    // Determine ability score modifier\r\n    let abl = itemData.ability.attack;\r\n\r\n    // Define Roll parts\r\n    let parts = [];\r\n    // Add ability modifier\r\n    if (abl != "" && rollData.abilities[abl] != null && rollData.abilities[abl].mod !== 0) parts.push(`@abilities.${abl}.mod`);\r\n    // Add bonus parts\r\n    parts = parts.concat(extraParts);\r\n    // Add size bonus\r\n    if (rollData.sizeBonus !== 0) parts.push("@sizeBonus");\r\n    // Add attack bonus\r\n    if (itemData.attackBonus !== "") {\r\n      let attackBonus = new Roll(itemData.attackBonus, rollData).roll().total;\r\n      rollData.item.attackBonus = attackBonus.toString();\r\n      parts.push("@item.attackBonus");\r\n    }\r\n\r\n    // Add certain attack bonuses\r\n    if (rollData.attributes.attack.general !== 0) {\r\n      parts.push("@attributes.attack.general");\r\n    }\r\n    if (["mwak", "msak"].includes(itemData.actionType) && rollData.attributes.attack.melee !== 0) {\r\n      parts.push("@attributes.attack.melee");\r\n    }\r\n    else if (["rwak", "rsak"].includes(itemData.actionType) && rollData.attributes.attack.ranged !== 0) {\r\n      parts.push("@attributes.attack.ranged");\r\n    }\r\n    // Add BAB\r\n    if (rollData.attributes.bab.total !== 0 && rollData.attributes.bab.total != null) {\r\n      parts.push("@attributes.bab.total");\r\n    }\r\n    // Add item\'s enhancement bonus\r\n    if (rollData.item.enh !== 0 && rollData.item.enh != null) {\r\n      parts.push("@item.enh");\r\n    }\r\n    // Subtract energy drain\r\n    if (rollData.attributes.energyDrain != null && rollData.attributes.energyDrain !== 0) {\r\n      parts.push("- max(0, abs(@attributes.energyDrain))");\r\n    }\r\n    // Add proficiency penalty\r\n    if ((this.data.type === "attack") && !itemData.proficient) { parts.push("@item.proficiencyPenalty"); }\r\n    // Add masterwork bonus\r\n    if (this.data.type === "attack" && itemData.masterwork === true && itemData.enh < 1) {\r\n      rollData.item.masterworkBonus = 1;\r\n      parts.push("@item.masterworkBonus");\r\n    }\r\n    // Add secondary natural attack penalty\r\n    if (primaryAttack === false) parts.push("-5");\r\n    // Add bonus\r\n    if (bonus != null) {\r\n      rollData.bonus = bonus;\r\n      parts.push("@bonus");\r\n    }\r\n\r\n    let roll = new Roll(["1d20"].concat(parts).join("+"), rollData).roll();\r\n    return roll;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Only roll the item\'s effect.\r\n   */\r\n  rollEffect({critical=false, primaryAttack=true}={}) {\r\n    const rollData = this.getRollData();\r\n\r\n    if (!this.hasEffect) {\r\n      throw new Error("You may not make an Effect Roll with this Item.");\r\n    }\r\n\r\n    // Determine critical multiplier\r\n    rollData.critMult = 1;\r\n    if (critical) rollData.critMult = this.data.data.ability.critMult;\r\n    // Determine ability multiplier\r\n    if (this.data.data.ability.damageMult != null) rollData.ablMult = this.data.data.ability.damageMult;\r\n    if (primaryAttack === false && rollData.ablMult > 0) rollData.ablMult = 0.5;\r\n\r\n    // Create effect string\r\n    let effectNotes = this.actor.getContextNotes("attacks.effect").reduce((cur, o) => {\r\n      o.notes.reduce((cur2, n) => {\r\n        cur2.push(...n.split(/[\\n\\r]+/));\r\n        return cur2;\r\n      }, []).forEach(n => {\r\n        cur.push(n);\r\n      });\r\n      return cur;\r\n    }, []);\r\n    effectNotes.push(...(this.data.data.effectNotes || "").split(/[\\n\\r]+/));\r\n    let effectContent = "";\r\n    for (let fx of effectNotes) {\r\n      if (fx.length > 0) {\r\n        effectContent += `<span class="tag">${fx}</span>`;\r\n      }\r\n    }\r\n\r\n    if (effectContent.length === 0) return "";\r\n\r\n    const inner = TextEditor.enrichHTML(effectContent, { rollData: rollData });\r\n    return `<div class="flexcol property-group"><label>${game.i18n.localize("PF1.EffectNotes")}</label><div class="flexrow">${inner}</div></div>`;\r\n  }\r\n\r\n  /**\r\n   * Place an attack roll using an item (weapon, feat, spell, or equipment)\r\n   * Rely upon the DicePF.d20Roll logic for the core implementation\r\n   */\r\n  async rollFormula(options={}) {\r\n    const itemData = this.data.data;\r\n    if ( !itemData.formula ) {\r\n      throw new Error(game.i18n.localize("PF1.ErrorNoFormula").format(this.name));\r\n    }\r\n\r\n    // Define Roll Data\r\n    const rollData = this.actor.getRollData();\r\n    rollData.item = itemData;\r\n    const title = `${this.name} - ${game.i18n.localize("PF1.OtherFormula")}`;\r\n\r\n    const roll = new Roll(itemData.formula, rollData).roll();\r\n    return roll.toMessage({\r\n      speaker: ChatMessage.getSpeaker({actor: this.actor}),\r\n      flavor: itemData.chatFlavor || title,\r\n      rollMode: game.settings.get("core", "rollMode")\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Place a damage roll using an item (weapon, feat, spell, or equipment)\r\n   * Rely upon the DicePF.damageRoll logic for the core implementation\r\n   */\r\n  rollDamage({data=null, critical=false, extraParts=[]}={}) {\r\n    const rollData = mergeObject(this.getRollData(), data || {});\r\n\r\n    if (!this.hasDamage) {\r\n      throw new Error("You may not make a Damage Roll with this Item.");\r\n    }\r\n\r\n    // Define Roll parts\r\n    let parts = this.data.data.damage.parts.map(p => { return { base: p[0], extra: [], damageType: p[1] }; });\r\n    parts[0].base = Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["alterRoll"])(parts[0].base, 0, rollData.critMult);\r\n    // Add critical damage parts\r\n    if (critical === true && getProperty(this.data, "data.damage.critParts") != null) {\r\n      parts = parts.concat(this.data.data.damage.critParts.map(p => { return { base: p[0], extra: [], damageType: p[1] }; }));\r\n    }\r\n\r\n    // Determine ability score modifier\r\n    let abl = this.data.data.ability.damage;\r\n    if (typeof abl === "string" && abl !== "") {\r\n      rollData.ablDamage = Math.floor(rollData.abilities[abl].mod * rollData.ablMult);\r\n      if (rollData.abilities[abl].mod < 0) rollData.ablDamage = rollData.abilities[abl].mod;\r\n      if (rollData.ablDamage < 0) parts[0].extra.push("@ablDamage");\r\n      else if (critical === true) parts[0].extra.push("@ablDamage * @critMult");\r\n      else if (rollData.ablDamage !== 0) parts[0].extra.push("@ablDamage");\r\n    }\r\n    // Add enhancement bonus\r\n    if (rollData.item.enh != null && rollData.item.enh !== 0 && rollData.item.enh != null) {\r\n      if (critical === true) parts[0].extra.push("@item.enh * @critMult");\r\n      else parts[0].extra.push("@item.enh");\r\n    }\r\n\r\n    // Add general damage\r\n    if (rollData.attributes.damage.general !== 0) {\r\n      if (critical === true) parts[0].extra.push("@attributes.damage.general * @critMult");\r\n      else parts[0].extra.push("@attributes.damage.general");\r\n    }\r\n    // Add melee or spell damage\r\n    if (rollData.attributes.damage.weapon !== 0 && ["mwak", "rwak"].includes(this.data.data.actionType)) {\r\n      if (critical === true) parts[0].extra.push("@attributes.damage.weapon * @critMult");\r\n      else parts[0].extra.push("@attributes.damage.weapon");\r\n    }\r\n    else if (rollData.attributes.damage.spell !== 0 && ["msak", "rsak", "spellsave"].includes(this.data.data.actionType)) {\r\n      if (critical === true) parts[0].extra.push("@attributes.damage.spell * @critMult");\r\n      else parts[0].extra.push("@attributes.damage.spell");\r\n    }\r\n\r\n    // Create roll\r\n    let rolls = [];\r\n    for (let a = 0; a < parts.length; a++) {\r\n      const part = parts[a];\r\n      let rollParts = [];\r\n      if (a === 0) rollParts = [...part.extra, ...extraParts];\r\n      const roll = {\r\n        roll: new Roll([part.base, ...rollParts].join("+"), rollData).roll(),\r\n        damageType: part.damageType,\r\n      };\r\n      rolls.push(roll);\r\n    }\r\n\r\n    return rolls;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Adjust a cantrip damage formula to scale it for higher level characters and monsters\r\n   * @private\r\n   */\r\n  _scaleCantripDamage(parts, level, scale) {\r\n    const add = Math.floor((level + 1) / 6);\r\n    if ( add === 0 ) return;\r\n    if ( scale && (scale !== parts[0]) ) {\r\n      parts[0] = parts[0] + " + " + scale.replace(new RegExp(Roll.diceRgx, "g"), (match, nd, d) => `${add}d${d}`);\r\n    } else {\r\n      parts[0] = parts[0].replace(new RegExp(Roll.diceRgx, "g"), (match, nd, d) => `${parseInt(nd)+add}d${d}`);\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Use a consumable item\r\n   */\r\n  async useConsumable(options={}) {\r\n    let itemData = this.data.data;\r\n    let parts = itemData.damage.parts;\r\n    const data = this.getRollData();\r\n\r\n    // Add effect string\r\n    let effectStr = "";\r\n    if (typeof itemData.effectNotes === "string" && itemData.effectNotes.length) {\r\n      effectStr = _dice_js__WEBPACK_IMPORTED_MODULE_0__["DicePF"].messageRoll({\r\n        data: data,\r\n        msgStr: itemData.effectNotes\r\n      });\r\n    }\r\n\r\n    parts = parts.map(obj => {\r\n      return obj[0];\r\n    });\r\n    // Submit the roll to chat\r\n    if (effectStr === "") {\r\n      new Roll(parts.join("+")).toMessage({\r\n        speaker: ChatMessage.getSpeaker({ actor: this.actor }),\r\n        flavor: game.i18n.localize("PF1.UsesItem").format(this.name)\r\n      });\r\n    }\r\n    else {\r\n      const chatTemplate = "systems/pf1/templates/chat/roll-ext.html";\r\n      const chatTemplateData = { hasExtraText: true, extraText: effectStr };\r\n      // Execute the roll\r\n      let roll = new Roll(parts.join("+"), data).roll();\r\n\r\n      // Create roll template data\r\n      const rollData = mergeObject({\r\n        user: game.user._id,\r\n        formula: roll.formula,\r\n        tooltip: await roll.getTooltip(),\r\n        total: roll.total,\r\n      }, chatTemplateData || {});\r\n\r\n      // Create chat data\r\n      let chatData = {\r\n        user: game.user._id,\r\n        type: CONST.CHAT_MESSAGE_TYPES.CHAT,\r\n        rollMode: game.settings.get("core", "rollMode"),\r\n        sound: CONFIG.sounds.dice,\r\n        speaker: ChatMessage.getSpeaker({ actor: this.actor }),\r\n        flavor: game.i18n.localize("PF1.UsesItem").format(this.name),\r\n        rollMode: game.settings.get("core", "rollMode"),\r\n        roll: roll,\r\n        content: await renderTemplate(chatTemplate, rollData),\r\n      };\r\n      // Handle different roll modes\r\n      switch (chatData.rollMode) {\r\n        case "gmroll":\r\n          chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n          break;\r\n        case "selfroll":\r\n          chatData["whisper"] = [game.user._id];\r\n          break;\r\n        case "blindroll":\r\n          chatData["whisper"] = game.users.entities.filter(u => u.isGM).map(u => u._id);\r\n          chatData["blind"] = true;\r\n      }\r\n\r\n      // Send message\r\n      ChatMessage.create(chatData);\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * @returns {Object} An object with data to be used in rolls in relation to this item.\r\n   */\r\n  getRollData() {\r\n    const result = this.actor != null ? this.actor.getRollData() : {};\r\n    result.item = duplicate(this.data.data);\r\n\r\n    if (this.type === "spell" && this.actor != null) {\r\n      const spellbook = this.spellbook;\r\n      const spellAbility = spellbook.ability;\r\n      let ablMod = "";\r\n      if (spellAbility !== "") ablMod = getProperty(this.actor.data, `data.abilities.${spellAbility}.mod`);\r\n\r\n      result.cl = this.casterLevel || 0;\r\n      result.sl = this.spellLevel  || 0;\r\n      result.ablMod = ablMod;\r\n    }\r\n    if (this.type === "buff") result.item.level = this.data.data.level;\r\n\r\n    return result;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  static chatListeners(html) {\r\n    html.on(\'click\', \'.card-buttons button\', this._onChatCardButton.bind(this));\r\n    html.on(\'click\', \'.item-name\', this._onChatCardToggleContent.bind(this));\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  static async _onChatCardButton(event) {\r\n    event.preventDefault();\r\n\r\n    // Extract card data\r\n    const button = event.currentTarget;\r\n    button.disabled = true;\r\n    const card = button.closest(".chat-card");\r\n    const messageId = card.closest(".message").dataset.messageId;\r\n    const message =  game.messages.get(messageId);\r\n    const action = button.dataset.action;\r\n\r\n    // Validate permission to proceed with the roll\r\n    let isTargetted = ["save", "applyDamage"].includes(action);\r\n    if ( !( isTargetted || game.user.isGM || message.isAuthor ) ) return;\r\n\r\n    // Get the Actor from a synthetic Token\r\n    const actor = this._getChatCardActor(card);\r\n    if ( !actor ) return;\r\n\r\n    // Get the Item\r\n    const item = actor.getOwnedItem(card.dataset.itemId);\r\n\r\n    // Perform action\r\n    await this._onChatCardAction(action, {button: button, item: item});\r\n\r\n    // Re-enable the button\r\n    button.disabled = false;\r\n  }\r\n\r\n  static async _onChatCardAction(action, {button=null, item=null}={}) {\r\n    // Get card targets\r\n    // const targets = isTargetted ? this._getChatCardTargets(card) : [];\r\n\r\n    // Consumable usage\r\n    if (action === "consume") await item.useConsumable({event});\r\n    // Apply damage\r\n    else if (action === "applyDamage") {\r\n      const value = button.dataset.value;\r\n      if (!isNaN(parseInt(value))) _actor_entity_js__WEBPACK_IMPORTED_MODULE_3__["ActorPF"].applyDamage(parseInt(value));\r\n    }\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Handle toggling the visibility of chat card content when the name is clicked\r\n   * @param {Event} event   The originating click event\r\n   * @private\r\n   */\r\n  static _onChatCardToggleContent(event) {\r\n    event.preventDefault();\r\n    const header = event.currentTarget;\r\n    const card = header.closest(".chat-card");\r\n    const content = card.querySelector(".card-content");\r\n    content.style.display = content.style.display === "none" ? "block" : "none";\r\n  }\r\n\r\n  /**\r\n   * Get the Actor which is the author of a chat card\r\n   * @param {HTMLElement} card    The chat card being used\r\n   * @return {Actor|null}         The Actor entity or null\r\n   * @private\r\n   */\r\n  static _getChatCardActor(card) {\r\n\r\n    // Case 1 - a synthetic actor from a Token\r\n    const tokenKey = card.dataset.tokenId;\r\n    if (tokenKey) {\r\n      const [sceneId, tokenId] = tokenKey.split(".");\r\n      const scene = game.scenes.get(sceneId);\r\n      if (!scene) return null;\r\n      const tokenData = scene.getEmbeddedEntity("Token", tokenId);\r\n      if (!tokenData) return null;\r\n      const token = new Token(tokenData);\r\n      return token.actor;\r\n    }\r\n\r\n    // Case 2 - use Actor ID directory\r\n    const actorId = card.dataset.actorId;\r\n    return game.actors.get(actorId) || null;\r\n  }\r\n\r\n  /**\r\n   * Updates the spell\'s description.\r\n   */\r\n\r\n  async _updateSpellDescription(updateData, srcData) {\r\n    const reSplit = CONFIG.PF1.re.traitSeparator;\r\n\r\n    const label = {\r\n      school: (CONFIG.PF1.spellSchools[getProperty(srcData, "data.school")] || "").toLowerCase(),\r\n      subschool: (getProperty(srcData, "data.subschool") || ""),\r\n      types: "",\r\n    };\r\n    const data = {\r\n      data: mergeObject(this.data.data, srcData.data, { inplace: false }),\r\n      label: label,\r\n    };\r\n\r\n    // Set subschool and types label\r\n    const types = getProperty(srcData, "data.types");\r\n    if (typeof types === "string" && types.length > 0) {\r\n      label.types = types.split(reSplit).join(", ");\r\n    }\r\n    // Set information about when the spell is learned\r\n    data.learnedAt = {};\r\n    data.learnedAt.class = (getProperty(srcData, "data.learnedAt.class") || []).map(o => {\r\n      return `${o[0]} ${o[1]}`;\r\n    }).sort().join(", ");\r\n    data.learnedAt.domain = (getProperty(srcData, "data.learnedAt.domain") || []).map(o => {\r\n      return `${o[0]} ${o[1]}`;\r\n    }).sort().join(", ");\r\n    data.learnedAt.subDomain = (getProperty(srcData, "data.learnedAt.subDomain") || []).map(o => {\r\n      return `${o[0]} ${o[1]}`;\r\n    }).sort().join(", ");\r\n    data.learnedAt.elementalSchool = (getProperty(srcData, "data.learnedAt.elementalSchool") || []).map(o => {\r\n      return `${o[0]} ${o[1]}`;\r\n    }).sort().join(", ");\r\n    data.learnedAt.bloodline = (getProperty(srcData, "data.learnedAt.bloodline") || []).map(o => {\r\n      return `${o[0]} ${o[1]}`;\r\n    }).sort().join(", ");\r\n\r\n    // Set casting time label\r\n    if (getProperty(srcData, "data.activation")) {\r\n      const activationCost = getProperty(srcData, "data.activation.cost");\r\n      const activationType = getProperty(srcData, "data.activation.type");\r\n\r\n      if (activationType) {\r\n        if (CONFIG.PF1.abilityActivationTypesPlurals[activationType] != null) {\r\n          if (activationCost === 1) label.castingTime = `${CONFIG.PF1.abilityActivationTypes[activationType]}`;\r\n          else label.castingTime = `${CONFIG.PF1.abilityActivationTypesPlurals[activationType]}`;\r\n        }\r\n        else label.castingTime = `${CONFIG.PF1.abilityActivationTypes[activationType]}`;\r\n      }\r\n      if (!Number.isNaN(activationCost) && label.castingTime != null) label.castingTime = `${activationCost} ${label.castingTime}`;\r\n      if (label.castingTime) label.castingTime = label.castingTime.toLowerCase();\r\n    }\r\n\r\n    // Set components label\r\n    let components = [];\r\n    for (let [key, value] of Object.entries(getProperty(srcData, "data.components"))) {\r\n      if (key === "value" && value.length > 0) components.push(...value.split(reSplit));\r\n      else if (key === "verbal" && value) components.push("V");\r\n      else if (key === "somatic" && value) components.push("S");\r\n      else if (key === "material" && value) components.push("M");\r\n      else if (key === "focus" && value) components.push("F");\r\n    }\r\n    if (getProperty(srcData, "data.components.divineFocus") === 1) components.push("DF");\r\n    const df = getProperty(srcData, "data.components.divineFocus");\r\n    // Sort components\r\n    const componentsOrder = ["V", "S", "M", "F", "DF"];\r\n    components.sort((a, b) => {\r\n      let index = [componentsOrder.indexOf(a), components.indexOf(b)];\r\n      if (index[0] === -1 && index[1] === -1) return 0;\r\n      if (index[0] === -1 && index[1] >= 0) return 1;\r\n      if (index[0] >= 0 && index[1] === -1) return -1;\r\n      return index[0] - index[1];\r\n    });\r\n    components = components.map(o => {\r\n      if (o === "M") {\r\n        if (df === 2) o = "M/DF";\r\n        if (getProperty(srcData, "data.materials.value")) o = `${o} (${getProperty(srcData, "data.materials.value")})`;\r\n      }\r\n      if (o === "F") {\r\n        if (df === 3) o = "F/DF";\r\n        if (getProperty(srcData, "data.materials.focus")) o = `${o} (${getProperty(srcData, "data.materials.focus")})`;\r\n      }\r\n      return o;\r\n    });\r\n    if (components.length > 0) label.components = components.join(", ");\r\n\r\n    // Set duration label\r\n    {\r\n      const duration = getProperty(srcData, "data.spellDuration");\r\n      if (duration) label.duration = duration;\r\n    }\r\n    // Set effect label\r\n    {\r\n      const effect = getProperty(srcData, "data.spellEffect");\r\n      if (effect) label.effect = effect;\r\n    }\r\n    // Set targets label\r\n    {\r\n      const targets = getProperty(srcData, "data.target.value");\r\n      if (targets) label.targets = targets;\r\n    }\r\n    // Set range label\r\n    {\r\n      const rangeUnit = getProperty(srcData, "data.range.units");\r\n      const rangeValue = getProperty(srcData, "data.range.value");\r\n\r\n      if (rangeUnit != null && rangeUnit !== "none") {\r\n        label.range = (CONFIG.PF1.distanceUnits[rangeUnit] || "").toLowerCase();\r\n        if (rangeUnit === "close") label.range = `${label.range} (25 ft. + 5 ft./2 levels)`;\r\n        else if (rangeUnit === "medium") label.range = `${label.range} (100 ft. + 10 ft./level)`;\r\n        else if (rangeUnit === "long") label.range = `${label.range} (400 ft. + 40 ft./level)`;\r\n        else if (["ft", "mi"].includes(rangeUnit)) {\r\n          if (!rangeValue) label.range = "";\r\n          else label.range = `${rangeValue} ${label.range}`;\r\n        }\r\n      }\r\n    }\r\n    // Set area label\r\n    {\r\n      const area = getProperty(srcData, "data.spellArea");\r\n\r\n      if (area) label.area = area;\r\n    }\r\n\r\n    // Set DC and SR\r\n    {\r\n      const savingThrowDescription = getProperty(srcData, "data.save.description");\r\n      if (savingThrowDescription) label.savingThrow = savingThrowDescription;\r\n      else label.savingThrow = "none";\r\n\r\n      const sr = getProperty(srcData, "data.sr");\r\n      label.sr = (sr === true ? game.i18n.localize("PF1.Yes") : game.i18n.localize("PF1.No")).toLowerCase();\r\n\r\n      if (getProperty(srcData, "data.range.units") !== "personal") data.useDCandSR = true;\r\n    }\r\n\r\n    Object(_lib_js__WEBPACK_IMPORTED_MODULE_2__["linkData"])(srcData, updateData, "data.description.value", await renderTemplate("systems/pf1/templates/internal/spell-description.html", data));\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Get the Actor which is the author of a chat card\r\n   * @param {HTMLElement} card    The chat card being used\r\n   * @return {Array.<Actor>}      The Actor entity or null\r\n   * @private\r\n   */\r\n  static _getChatCardTargets(card) {\r\n    const character = game.user.character;\r\n    const controlled = canvas.tokens.controlled;\r\n    const targets = controlled.reduce((arr, t) => t.actor ? arr.concat([t.actor]) : arr, []);\r\n    if ( character && (controlled.length === 0) ) targets.push(character);\r\n    if ( !targets.length ) throw new Error(`You must designate a specific Token as the roll target`);\r\n    return targets;\r\n  }\r\n\r\n  async addSpellUses(value, data=null) {\r\n    if (!this.actor) return;\r\n    if (this.data.data.atWill) return;\r\n    if (this.data.data.level === 0) return;\r\n\r\n    const spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`),\r\n      isSpontaneous = spellbook.spontaneous,\r\n      spellbookKey = getProperty(this.data, "data.spellbook") || "primary",\r\n      spellLevel = getProperty(this.data, "data.level");\r\n    const newCharges = isSpontaneous\r\n      ? Math.max(0, (getProperty(spellbook, `spells.spell${spellLevel}.value`) || 0) + value)\r\n      : Math.max(0, (getProperty(this.data, "data.preparation.preparedAmount") || 0) + value);\r\n\r\n    if (!isSpontaneous) {\r\n      const key = "data.preparation.preparedAmount";\r\n      if (data == null) {\r\n        data = {};\r\n        data[key] = newCharges;\r\n        return this.update(data);\r\n      }\r\n      else {\r\n        data[key] = newCharges;\r\n      }\r\n    }\r\n    else {\r\n      const key = `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${spellLevel}.value`;\r\n      const actorUpdateData = {};\r\n      actorUpdateData[key] = newCharges;\r\n      return this.actor.update(actorUpdateData);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  getSpellUses() {\r\n    if (!this.actor) return 0;\r\n    if (this.data.data.atWill) return Number.POSITIVE_INFINITY;\r\n\r\n    const spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`),\r\n      isSpontaneous = spellbook.spontaneous,\r\n      spellLevel = getProperty(this.data, "data.level");\r\n    \r\n    if (isSpontaneous) {\r\n      if (getProperty(this.data, "data.preparation.spontaneousPrepared") === true) {\r\n        return getProperty(spellbook, `spells.spell${spellLevel}.value`) || 0;\r\n      }\r\n    }\r\n    else {\r\n      return getProperty(this.data, "data.preparation.preparedAmount") || 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  static async toConsumable(origData, type) {\r\n    let data = duplicate(game.system.template.Item.consumable);\r\n    for (let t of data.templates) {\r\n      mergeObject(data, duplicate(game.system.template.Item.templates[t]));\r\n    }\r\n    delete data.templates;\r\n    data = {\r\n      type: "consumable",\r\n      name: origData.name,\r\n      data: data,\r\n    };\r\n\r\n    const slcl = this.getMinimumCasterLevelBySpellData(origData.data);\r\n\r\n    // Set consumable type\r\n    data.data.consumableType = type;\r\n\r\n    // Set name\r\n    if (type === "wand") {\r\n      data.name = `Wand of ${origData.name}`;\r\n      data.img = "systems/pf1/icons/items/inventory/wand-star.jpg";\r\n      data.data.price = slcl[0] * slcl[1] * 750;\r\n      data.data.hardness = 5;\r\n      data.data.hp.max = 5;\r\n      data.data.hp.value = 5;\r\n    }\r\n    else if (type === "potion") {\r\n      data.name = `Potion of ${origData.name}`;\r\n      data.img = "systems/pf1/icons/items/potions/minor-blue.jpg";\r\n      data.data.price = slcl[0] * slcl[1] * 50;\r\n      data.data.hardness = 1;\r\n      data.data.hp.max = 1;\r\n      data.data.hp.value = 1;\r\n    }\r\n    else if (type === "scroll") {\r\n      data.name = `Scroll of ${origData.name}`;\r\n      data.img = "systems/pf1/icons/items/inventory/scroll-magic.jpg";\r\n      data.data.price = slcl[0] * slcl[1] * 25;\r\n      data.data.hardness = 0;\r\n      data.data.hp.max = 1;\r\n      data.data.hp.value = 1;\r\n    }\r\n\r\n    // Set charges\r\n    if (type === "wand") {\r\n      data.data.uses.maxFormula = "50";\r\n      data.data.uses.value      = 50;\r\n      data.data.uses.max        = 50;\r\n      data.data.uses.per        = "charges";\r\n    }\r\n    else {\r\n      data.data.uses.per = "single";\r\n    }\r\n\r\n    // Set activation method\r\n    data.data.activation.type = "standard";\r\n\r\n    // Set measure template\r\n    if (type !== "potion") {\r\n      data.data.measureTemplate = getProperty(origData, "data.measureTemplate");\r\n    }\r\n\r\n    // Set damage formula\r\n    data.data.actionType = origData.data.actionType;\r\n    for (let d of getProperty(origData, "data.damage.parts")) {\r\n      d[0] = d[0].replace(/@sl/g, slcl[0]);\r\n      d[0] = d[0].replace(/@cl/g, slcl[1]);\r\n      data.data.damage.parts.push(d);\r\n    }\r\n\r\n    // Set saves\r\n    data.data.save.description = origData.data.save.description;\r\n    data.data.save.dc = 10 + slcl[0] + Math.floor(slcl[0] / 2);\r\n\r\n    // Copy variables\r\n    data.data.attackNotes = origData.data.attackNotes;\r\n    data.data.effectNotes = origData.data.effectNotes;\r\n    data.data.attackBonus = origData.data.attackBonus;\r\n    data.data.critConfirmBonus = origData.data.critConfirmBonus;\r\n\r\n    // Determine aura power\r\n    let auraPower = "faint";\r\n    for (let a of CONFIG.PF1.magicAuraByLevel.item) {\r\n      if (a.level <= slcl[1]) auraPower = a.power;\r\n    }\r\n    // Determine caster level label\r\n    let clLabel;\r\n    if (slcl[1] === 1) clLabel = "1st";\r\n    else if (slcl[1] === 2) clLabel = "2nd";\r\n    else if (slcl[1] === 3) clLabel = "3rd";\r\n    else clLabel = `${slcl[1]}th`;\r\n    // Determine spell level label\r\n    let slLabel;\r\n    if (slcl[0] === 1) slLabel = "1st";\r\n    else if (slcl[0] === 2) slLabel = "2nd";\r\n    else if (slcl[0] === 3) slLabel = "3rd";\r\n    else slLabel = `${slcl[0]}th`;\r\n\r\n    // Set description\r\n    data.data.description.value = await renderTemplate("systems/pf1/templates/internal/consumable-description.html", {\r\n      origData: origData,\r\n      data: data,\r\n      isWand: type === "wand",\r\n      isPotion: type === "potion",\r\n      isScroll: type === "scroll",\r\n      auraPower: auraPower,\r\n      aura: (CONFIG.PF1.spellSchools[origData.data.school] || "").toLowerCase(),\r\n      sl: slcl[0],\r\n      cl: slcl[1],\r\n      slLabel: slLabel,\r\n      clLabel: clLabel,\r\n      config: CONFIG.PF1,\r\n    });\r\n\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {object} itemData - A spell item\'s data.\r\n   * @returns {number[]} An array containing the spell level and caster level.\r\n   */\r\n  static getMinimumCasterLevelBySpellData(itemData) {\r\n    const learnedAt = getProperty(itemData, "learnedAt.class").reduce((cur, o) => {\r\n      const classes = o[0].split("/");\r\n      for (let cls of classes) cur.push([cls, o[1]]);\r\n      return cur;\r\n    }, []);\r\n    let result = [9, 20];\r\n    for (let o of learnedAt) {\r\n      result[0] = Math.min(result[0], o[1]);\r\n      \r\n      const tc = CONFIG.PF1.classCasterType[o[0]] || "high";\r\n      if (tc === "high") {\r\n        result[1] = Math.min(result[1], 1 + Math.max(0, (o[1] - 1)) * 2);\r\n      }\r\n      else if (tc === "med") {\r\n        result[1] = Math.min(result[1], 1 + Math.max(0, (o[1] - 1)) * 3);\r\n      }\r\n      else if (tc === "low") {\r\n        result[1] = Math.min(result[1], 4 + Math.max(0, (o[1] - 1)) * 3);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async _onLevelChange(curLevel, newLevel) {\r\n\r\n    // let newItems = [];\r\n    // // Add linked items by minLevel\r\n    // for (let o of this.links.minLevel) {\r\n      // if (newLevel > curLevel && newLevel >= o.level) {\r\n        // const id = o.target.split(".");\r\n\r\n        // // Add from compendium\r\n        // if (id.length === 3) {\r\n          // const pack = game.packs.get([id[0], id[1]].join("."));\r\n          // const item = await pack.getEntity(id[2]);\r\n          // if (item != null) {\r\n            // newItems.push(item);\r\n          // }\r\n        // }\r\n      // }\r\n    // }\r\n\r\n    // if (this.actor != null) {\r\n      // if (newItems.length > 0) {\r\n        // this.actor.createEmbeddedEntity("OwnedItem", newItems);\r\n      // }\r\n    // }\r\n  }\r\n\r\n  async getLinkedItems(type) {\r\n    const items = getProperty(this.data, `data.links.${type}`);\r\n    if (!items) return [];\r\n\r\n    let result = [];\r\n    for (let l of items) {\r\n      let item = await this.getLinkItem(l);\r\n      if (item) result.push(item);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getLinkItem(l) {\r\n    const id = l.id.split(".");\r\n\r\n    // Compendium entry\r\n    if (l.dataType === "compendium") {\r\n      const pack = game.packs.get(id.slice(0, 2).join("."));\r\n      return await pack.getEntity(id[2]);\r\n    }\r\n    // World entry\r\n    else if (l.dataType === "world") {\r\n      return game.items.get(id[1]);\r\n    }\r\n    // Same actor\'s item\r\n    else if (this.actor != null && this.actor.items != null) {\r\n      return this.actor.items.find(o => o._id === id[0]);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  async updateLinkItems() {\r\n\r\n    // Update link items\r\n    const linkGroups = (getProperty(this.data, "data.links") || {});\r\n    for (let links of Object.values(linkGroups)) {\r\n      for (let l of links) {\r\n        const i = await this.getLinkItem(l);\r\n        if (i == null) continue;\r\n        l.name = i.name;\r\n        l.img = i.img;\r\n      }\r\n    }\r\n  }\r\n\r\n  _cleanLink(oldLink, linkType) {\r\n    if (!this.actor) return;\r\n\r\n    const otherItem = this.actor.items.find(o => o._id === oldLink.id);\r\n    if (linkType === "charges" && otherItem && hasProperty(otherItem, "links.charges")) {\r\n      delete otherItem.links.charges;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates lists of change subtargets this item can have.\r\n   * @param {string} target - The target key, as defined in CONFIG.PF1.buffTargets.\r\n   * @returns {Object.<string, string>} A list of changes\r\n   */\r\n  getChangeSubTargets(target) {\r\n\r\n    let result = {};\r\n    // Add specific skills\r\n    if (target === "skill") {\r\n      if (this.actor == null) {\r\n        for (let [s, skl] of Object.entries(CONFIG.PF1.skills)) {\r\n          result[`skill.${s}`] = skl;\r\n        }\r\n      }\r\n      else {\r\n        const actorSkills = this.actor.data.data.skills;\r\n        for (let [s, skl] of Object.entries(actorSkills)) {\r\n          if (!skl.subSkills) {\r\n            if (skl.custom) result[`skill.${s}`] = skl.name;\r\n            else result[`skill.${s}`] = CONFIG.PF1.skills[s];\r\n          }\r\n          else {\r\n            for (let [s2, skl2] of Object.entries(skl.subSkills)) {\r\n              result[`skill.${s}.subSkills.${s2}`] = `${CONFIG.PF1.skills[s]} (${skl2.name})`;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add static subtargets\r\n    else if (hasProperty(CONFIG.PF1.buffTargets, target)) {\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.buffTargets[target])) {\r\n        if (!k.startsWith("_")) result[k] = v;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates lists of context note subtargets this item can have.\r\n   * @param {string} target - The target key, as defined in CONFIG.PF1.buffTargets.\r\n   * @returns {Object.<string, string>} A list of changes\r\n   */\r\n  getContextNoteSubTargets(target) {\r\n\r\n    let result = {};\r\n    // Add specific skills\r\n    if (target === "skill") {\r\n      if (this.actor == null) {\r\n        for (let [s, skl] of Object.entries(CONFIG.PF1.skills)) {\r\n          result[`skill.${s}`] = skl;\r\n        }\r\n      }\r\n      else {\r\n        const actorSkills = this.actor.data.data.skills;\r\n        for (let [s, skl] of Object.entries(actorSkills)) {\r\n          if (!skl.subSkills) {\r\n            if (skl.custom) result[`skill.${s}`] = skl.name;\r\n            else result[`skill.${s}`] = CONFIG.PF1.skills[s];\r\n          }\r\n          else {\r\n            for (let [s2, skl2] of Object.entries(skl.subSkills)) {\r\n              result[`skill.${s}.subSkills.${s2}`] = `${CONFIG.PF1.skills[s]} (${skl2.name})`;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add static subtargets\r\n    else if (hasProperty(CONFIG.PF1.contextNoteTargets, target)) {\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.contextNoteTargets[target])) {\r\n        if (!k.startsWith("_")) result[k] = v;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/item/entity.js?')},"./module/item/sheets/base.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemSheetPF", function() { return ItemSheetPF; });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib.js */ "./module/lib.js");\n/* harmony import */ var _apps_entry_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../apps/entry-selector.js */ "./module/apps/entry-selector.js");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity.js */ "./module/item/entity.js");\n\r\n\r\n\r\n\r\n/**\r\n * Override and extend the core ItemSheet implementation to handle D&D5E specific item types\r\n * @type {ItemSheet}\r\n */\r\nclass ItemSheetPF extends ItemSheet {\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    this.options.submitOnClose = false;\r\n\r\n    /**\r\n     * Track the set of item filters which are applied\r\n     * @type {Set}\r\n     */\r\n    this._filters = {\r\n    };\r\n\r\n    this.items = [];\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  static get defaultOptions() {\r\n    return mergeObject(super.defaultOptions, {\r\n      width: 560,\r\n      height: 600,\r\n      classes: ["pf1", "sheet", "item"],\r\n      resizable: false\r\n    });\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Return a dynamic reference to the HTML template path used to render this Item Sheet\r\n   * @return {string}\r\n   */\r\n  get template() {\r\n    const path = "systems/pf1/templates/items/";\r\n    return `${path}/${this.item.data.type}.html`;\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Prepare item sheet data\r\n   * Start with the base item data and extending with additional properties for rendering.\r\n   */\r\n  async getData() {\r\n    const data = super.getData();\r\n    data.labels = this.item.labels;\r\n\r\n    // Include sub-items\r\n    data.items = [];\r\n    if (this.item.items != null) {\r\n      data.items = this.item.items.map(i => {\r\n        i.data.labels = i.labels;\r\n        return i.data;\r\n      });\r\n    }\r\n\r\n    // Include CONFIG values\r\n    data.config = CONFIG.PF1;\r\n\r\n    // Item Type, Status, and Details\r\n    data.itemType = data.item.type.titleCase();\r\n    data.itemStatus = this._getItemStatus(data.item);\r\n    data.itemProperties = this._getItemProperties(data.item);\r\n    data.itemName = data.item.name;\r\n    data.isPhysical = data.item.data.hasOwnProperty("quantity");\r\n    data.isSpell = this.item.type === "spell";\r\n    data.owner = this.item.actor != null;\r\n    data.isGM = game.user.isGM;\r\n    data.showIdentifyDescription = data.isGM && data.isPhysical;\r\n    data.showUnidentifiedData = this.item.showUnidentifiedData;\r\n\r\n    // Unidentified data\r\n    if (this.item.showUnidentifiedData) {\r\n      data.itemName = getProperty(this.item.data, "data.unidentified.name") || getProperty(this.item.data, "data.identifiedName") || this.item.name;\r\n    }\r\n    else {\r\n      data.itemName = getProperty(this.item.data, "data.identifiedName") || this.item.name;\r\n    }\r\n\r\n    // Action Details\r\n    data.hasAttackRoll = this.item.hasAttack;\r\n    data.isHealing = data.item.data.actionType === "heal";\r\n\r\n    data.isCharged = false;\r\n    if (data.item.data.uses != null) {\r\n      data.isCharged = ["day", "week", "charges"].includes(data.item.data.uses.per);\r\n    }\r\n    if (data.item.data.range != null) {\r\n      data.canInputRange = ["ft", "mi", "spec"].includes(data.item.data.range.units);\r\n    }\r\n    if (data.item.data.duration != null) {\r\n      data.canInputDuration = !(["", "inst", "perm", "seeText"].includes(data.item.data.duration.units));\r\n    }\r\n\r\n    // Prepare feat specific stuff\r\n    if (data.item.type === "feat") {\r\n      data.isClassFeature = getProperty(this.item.data, "data.featType") === "classFeat";\r\n      data.isTemplate = getProperty(this.item.data, "data.featType") === "template";\r\n    }\r\n\r\n    // Prepare weapon specific stuff\r\n    if (data.item.type === "weapon") {\r\n      data.isRanged = (data.item.data.weaponSubtype === "ranged" || data.item.data.properties["thr"] === true);\r\n\r\n      // Prepare categories for weapons\r\n      data.weaponCategories = { types: {}, subTypes: {} };\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.weaponTypes)) {\r\n        if (typeof v === "object") data.weaponCategories.types[k] = v._label;\r\n      }\r\n      const type = data.item.data.weaponType;\r\n      if (hasProperty(CONFIG.PF1.weaponTypes, type)) {\r\n        for (let [k, v] of Object.entries(CONFIG.PF1.weaponTypes[type])) {\r\n          // Add static targets\r\n          if (!k.startsWith("_")) data.weaponCategories.subTypes[k] = v;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Prepare equipment specific stuff\r\n    if (data.item.type === "equipment") {\r\n      // Prepare categories for equipment\r\n      data.equipmentCategories = { types: {}, subTypes: {} };\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.equipmentTypes)) {\r\n        if (typeof v === "object") data.equipmentCategories.types[k] = v._label;\r\n      }\r\n      const type = data.item.data.equipmentType;\r\n      if (hasProperty(CONFIG.PF1.equipmentTypes, type)) {\r\n        for (let [k, v] of Object.entries(CONFIG.PF1.equipmentTypes[type])) {\r\n          // Add static targets\r\n          if (!k.startsWith("_")) data.equipmentCategories.subTypes[k] = v;\r\n        }\r\n      }\r\n\r\n      // Prepare slots for equipment\r\n      data.equipmentSlots = CONFIG.PF1.equipmentSlots[type];\r\n\r\n      // Whether the equipment should show armor data\r\n      data.showArmorData = ["armor", "shield"].includes(type);\r\n\r\n      // Whether the current equipment type has multiple slots\r\n      data.hasMultipleSlots = Object.keys(data.equipmentSlots).length > 1;\r\n    }\r\n\r\n    // Prepare attack specific stuff\r\n    if (data.item.type === "attack") {\r\n      data.isWeaponAttack = data.item.data.attackType === "weapon";\r\n      data.isNaturalAttack = data.item.data.attackType === "natural";\r\n    }\r\n\r\n    // Prepare spell specific stuff\r\n    if (data.item.type === "spell") {\r\n      let spellbook = null;\r\n      if (this.actor != null) {\r\n        spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.item.data.data.spellbook}`);\r\n      }\r\n\r\n      data.isPreparedSpell = spellbook != null ? !spellbook.spontaneous : false;\r\n      data.isAtWill = data.item.data.atWill;\r\n      data.spellbooks = {};\r\n      if (this.item.actor) {\r\n        data.spellbooks = duplicate(this.item.actor.data.data.attributes.spells.spellbooks);\r\n      }\r\n\r\n      // Enrich description\r\n      data.description = TextEditor.enrichHTML(data.data.description.value, { rollData: this.item.getRollData() });\r\n      if (data.data.shortDescription != null) {\r\n        data.shortDescription = TextEditor.enrichHTML(data.data.shortDescription, { rollData: this.item.getRollData() });\r\n      }\r\n    }\r\n\r\n    // Prepare class specific stuff\r\n    if (data.item.type === "class") {\r\n      for (let [a, s] of Object.entries(data.data.savingThrows)) {\r\n        s.label = CONFIG.PF1.savingThrows[a];\r\n      }\r\n      for (let [a, s] of Object.entries(data.data.fc)) {\r\n        s.label = CONFIG.PF1.favouredClassBonuses[a];\r\n      }\r\n\r\n      data.isBaseClass = data.data.classType === "base";\r\n      data.isRacialHD = data.data.classType === "racial";\r\n\r\n      if (this.actor != null) {\r\n        let healthConfig  = game.settings.get("pf1", "healthConfig");\r\n        data.healthConfig =  data.isRacialHD ? healthConfig.hitdice.Racial : this.actor.data.type === "character" ? healthConfig.hitdice.PC : healthConfig.hitdice.NPC;\r\n      } else data.healthConfig = {auto: false};\r\n\r\n      // Add skill list\r\n      if (!this.item.actor) {\r\n        data.skills = Object.entries(CONFIG.PF1.skills).reduce((cur, o) => {\r\n          cur[o[0]] = { name: o[1], classSkill: getProperty(this.item.data, `data.classSkills.${o[0]}`) === true };\r\n          return cur;\r\n        }, {});\r\n      }\r\n      else {\r\n        data.skills = Object.entries(this.item.actor.data.data.skills).reduce((cur, o) => {\r\n          const key = o[0];\r\n          const name = CONFIG.PF1.skills[key] != null ? CONFIG.PF1.skills[key] : o[1].name;\r\n          cur[o[0]] = { name: name, classSkill: getProperty(this.item.data, `data.classSkills.${o[0]}`) === true };\r\n          return cur;\r\n        }, {});\r\n      }\r\n    }\r\n\r\n    // Prepare stuff for items with changes\r\n    if (data.item.data.changes) {\r\n      data.changes = { targets: {}, modifiers: CONFIG.PF1.bonusModifiers };\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.buffTargets)) {\r\n        if (typeof v === "object") data.changes.targets[k] = v._label;\r\n      }\r\n      data.item.data.changes.forEach(item => {\r\n        item.subTargets = this.item.getChangeSubTargets(item.target);\r\n      });\r\n    }\r\n\r\n    // Prepare stuff for items with context notes\r\n    if (data.item.data.contextNotes) {\r\n      data.contextNotes = { targets: {} };\r\n      for (let [k, v] of Object.entries(CONFIG.PF1.contextNoteTargets)) {\r\n        if (typeof v === "object") data.contextNotes.targets[k] = v._label;\r\n      }\r\n      data.item.data.contextNotes.forEach(item => {\r\n        item.subNotes = this.item.getContextNoteSubTargets(item.target);\r\n      });\r\n    }\r\n\r\n    // Add links\r\n    await this._prepareLinks(data);\r\n\r\n    return data;\r\n  }\r\n\r\n  async _prepareLinks(data) {\r\n\r\n    data.links = {\r\n      list: [],\r\n    };\r\n\r\n    // Add children link type\r\n    data.links.list.push({\r\n      id: "children",\r\n      label: game.i18n.localize("PF1.LinkTypeChildren"),\r\n      help: game.i18n.localize("PF1.LinkHelpChildren"),\r\n      items: [],\r\n    });\r\n\r\n    // Add charges link type\r\n    if (["feat", "consumable", "attack"].includes(this.item.type)) {\r\n      data.links.list.push({\r\n        id: "charges",\r\n        label: game.i18n.localize("PF1.LinkTypeCharges"),\r\n        help: game.i18n.localize("PF1.LinkHelpCharges"),\r\n        items: [],\r\n      });\r\n    }\r\n\r\n    // Post process data\r\n    for (let l of data.links.list) {\r\n      const items = getProperty(this.item.data, `data.links.${l.id}`) || [];\r\n      for (let i of items) {\r\n        l.items.push(i);\r\n      }\r\n    }\r\n\r\n    await this.item.updateLinkItems();\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Get the text item status which is shown beneath the Item type in the top-right corner of the sheet\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  _getItemStatus(item) {\r\n    if ( item.type === "spell" ) {\r\n      const spellbook = this.item.spellbook;\r\n      if (item.data.preparation.mode === "prepared") {\r\n        if (item.data.preparation.preparedAmount > 0) {\r\n          if (spellbook != null && spellbook.spontaneous) {\r\n            return game.i18n.localize("PF1.SpellPrepPrepared");\r\n          }\r\n          else {\r\n            return game.i18n.localize("PF1.AmountPrepared").format(item.data.preparation.preparedAmount);\r\n          }\r\n        }\r\n        return game.i18n.localize("PF1.Unprepared");\r\n      }\r\n      else if (item.data.preparation.mode) {\r\n        return item.data.preparation.mode.titleCase();\r\n      }\r\n      else return "";\r\n    }\r\n    else if ( ["weapon", "equipment"].includes(item.type) ) return item.data.equipped ? game.i18n.localize("PF1.Equipped") : game.i18n.localize("PF1.NotEquipped");\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Get the Array of item properties which are used in the small sidebar of the description tab\r\n   * @return {Array}\r\n   * @private\r\n   */\r\n  _getItemProperties(item) {\r\n    const props = [];\r\n    const labels = this.item.labels;\r\n\r\n    if ( item.type === "weapon" ) {\r\n      props.push(...Object.entries(item.data.properties)\r\n        .filter(e => e[1] === true)\r\n        .map(e => CONFIG.PF1.weaponProperties[e[0]]));\r\n    }\r\n\r\n    else if ( item.type === "spell" ) {\r\n      props.push(\r\n        labels.components,\r\n        labels.materials\r\n      )\r\n    }\r\n\r\n    else if ( item.type === "equipment" ) {\r\n      props.push(CONFIG.PF1.equipmentTypes[item.data.armor.type]);\r\n      props.push(labels.armor);\r\n    }\r\n\r\n    else if ( item.type === "feat" ) {\r\n      props.push(labels.featType);\r\n    }\r\n\r\n    // Action type\r\n    if ( item.data.actionType ) {\r\n      props.push(CONFIG.PF1.itemActionTypes[item.data.actionType]);\r\n    }\r\n\r\n    // Action usage\r\n    if ( (item.type !== "weapon") && item.data.activation && !isObjectEmpty(item.data.activation) ) {\r\n      props.push(\r\n        labels.activation,\r\n        labels.range,\r\n        labels.target,\r\n        labels.duration\r\n      )\r\n    }\r\n\r\n    // Tags\r\n    if (getProperty(item, "data.tags") != null) {\r\n      props.push(...getProperty(item, "data.tags").map(o => {\r\n        return o[0];\r\n      }));\r\n    }\r\n\r\n    return props.filter(p => !!p);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  setPosition(position={}) {\r\n    // if ( this._sheetTab === "details" ) position.height = "auto";\r\n    return super.setPosition(position);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n  /*  Form Submission                             */\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Extend the parent class _updateObject method to ensure that damage ends up in an Array\r\n   * @private\r\n   */\r\n  _updateObject(event, formData) {\r\n    // Handle Damage Array\r\n    let damage = Object.entries(formData).filter(e => e[0].startsWith("data.damage.parts"));\r\n    formData["data.damage.parts"] = damage.reduce((arr, entry) => {\r\n      let [i, j] = entry[0].split(".").slice(3);\r\n      if ( !arr[i] ) arr[i] = [];\r\n      arr[i][j] = entry[1];\r\n      return arr;\r\n    }, []);\r\n\r\n    // Handle Critical Damage Array\r\n    let critDamage = Object.entries(formData).filter(e => e[0].startsWith("data.damage.critParts"));\r\n    formData["data.damage.critParts"] = critDamage.reduce((arr, entry) => {\r\n      let [i, j] = entry[0].split(".").slice(3);\r\n      if ( !arr[i] ) arr[i] = [];\r\n      arr[i][j] = entry[1];\r\n      return arr;\r\n    }, []);\r\n\r\n    // Handle Attack Array\r\n    let attacks = Object.entries(formData).filter(e => e[0].startsWith("data.attackParts"));\r\n    formData["data.attackParts"] = attacks.reduce((arr, entry) => {\r\n      let [i, j] = entry[0].split(".").slice(2);\r\n      if ( !arr[i] ) arr[i] = [];\r\n      arr[i][j] = entry[1];\r\n      return arr;\r\n    }, []);\r\n\r\n    // Handle change array\r\n    let change = Object.entries(formData).filter(e => e[0].startsWith("data.changes"));\r\n    formData["data.changes"] = change.reduce((arr, entry) => {\r\n      let [i, j] = entry[0].split(".").slice(2);\r\n      if ( !arr[i] ) arr[i] = _entity_js__WEBPACK_IMPORTED_MODULE_2__["ItemPF"].defaultChange;\r\n      arr[i][j] = entry[1];\r\n      // Reset subtarget (if necessary)\r\n      if (j === "subTarget") {\r\n        const target = (change.find(o => o[0] === `data.changes.${i}.target`) || [])[1];\r\n        const subTarget = entry[1];\r\n        if (typeof target === "string") {\r\n          const keys = Object.keys(this.item.getChangeSubTargets(target));\r\n          if (!keys.includes(subTarget)) arr[i][j] = keys[0];\r\n        }\r\n      }\r\n      // Limit priority\r\n      if (j === "priority") {\r\n        const prio = Math.max(-1000, Math.min(1000, entry[1]));\r\n        arr[i][j] = prio;\r\n      }\r\n      return arr;\r\n    }, []);\r\n\r\n    // Handle notes array\r\n    let note = Object.entries(formData).filter(e => e[0].startsWith("data.contextNotes"));\r\n    formData["data.contextNotes"] = note.reduce((arr, entry) => {\r\n      let [i, j] = entry[0].split(".").slice(2);\r\n      if ( !arr[i] ) arr[i] = {};\r\n      arr[i][j] = entry[1];\r\n      // Reset subtarget (if necessary)\r\n      if (j === "subTarget") {\r\n        const target = (note.find(o => o[0] === `data.contextNotes.${i}.target`) || [])[1];\r\n        const subTarget = entry[1];\r\n        if (typeof target === "string") {\r\n          const keys = Object.keys(this.item.getContextNoteSubTargets(target));\r\n          if (!keys.includes(subTarget)) arr[i][j] = keys[0];\r\n        }\r\n      }\r\n      // }\r\n      return arr;\r\n    }, []);\r\n\r\n    // Handle links arrays\r\n    let links = Object.entries(formData).filter(e => e[0].startsWith("data.links"));\r\n    for (let e of links) {\r\n\r\n      formData[e[0]] = e[1].reduce((arr, entry) => {\r\n        let [i, j] = entry[0].split(".").slice(2);\r\n        if ( !arr[i] ) arr[i] = [];\r\n        arr[i][j] = entry[1];\r\n        return arr;\r\n      }, []);\r\n    }\r\n\r\n    // Update the Item\r\n    super._updateObject(event, formData);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Activate listeners for interactive item sheet events\r\n   */\r\n  activateListeners(html) {\r\n    super.activateListeners(html);\r\n\r\n    // Activate tabs\r\n    // Only run this if TabsV2 is already available (which is available since FoundryVTT 0.5.2)\r\n    if (typeof TabsV2 !== "undefined") {\r\n      const tabGroups = {\r\n        "primary": {\r\n          "description": {},\r\n          "links": {},\r\n        },\r\n      };\r\n      _lib_js__WEBPACK_IMPORTED_MODULE_0__["createTabs"].call(this, html, tabGroups);\r\n    }\r\n    // Run older Tabs as a fallback\r\n    else {\r\n      new Tabs(html.find(".tabs"), {\r\n        initial: this["_sheetTab"],\r\n        callback: clicked => {\r\n          this._scrollTab = 0;\r\n          this["_sheetTab"] = clicked.data("tab");\r\n          this.setPosition();\r\n        }\r\n      });\r\n\r\n      // Save scroll position\r\n      html.find(".tab.active")[0].scrollTop = this._scrollTab;\r\n      html.find(".tab").scroll(ev => this._scrollTab = ev.currentTarget.scrollTop);\r\n    }\r\n\r\n    // Tooltips\r\n    html.mousemove(ev => this._moveTooltips(ev));\r\n\r\n    // Everything below here is only needed if the sheet is editable\r\n    if (!this.options.editable) return;\r\n\r\n    // Trigger form submission from textarea elements.\r\n    html.find("textarea").change(this._onSubmit.bind(this));\r\n\r\n    // Add drop handler to textareas\r\n    html.find("textarea").on("drop", this._onTextAreaDrop.bind(this));\r\n\r\n    // Modify attack formula\r\n    html.find(".attack-control").click(this._onAttackControl.bind(this));\r\n\r\n    // Modify damage formula\r\n    html.find(".damage-control").click(this._onDamageControl.bind(this));\r\n\r\n    // Modify damage formula\r\n    html.find(".crit-damage-control").click(this._onCritDamageControl.bind(this));\r\n\r\n    // Modify buff changes\r\n    html.find(".change-control").click(this._onBuffControl.bind(this));\r\n\r\n    // Modify note changes\r\n    html.find(".context-note-control").click(this._onNoteControl.bind(this));\r\n\r\n    // Create attack\r\n    if (["weapon"].includes(this.item.data.type)) {\r\n      html.find("button[name=\'create-attack\']").click(this._createAttack.bind(this));\r\n    }\r\n\r\n    // Listen to field entries\r\n    html.find(".entry-selector").click(this._onEntrySelector.bind(this));\r\n\r\n    // Add drop handler to link tabs\r\n    html.find(\'div[data-group="links"]\').on("drop", this._onLinksDrop.bind(this));\r\n\r\n    html.find(".link-control").click(this._onLinkControl.bind(this));\r\n\r\n    // Handle alternative file picker\r\n    html.find(".file-picker-alt").click(this._onFilePickerAlt.bind(this));\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  _moveTooltips(event) {\r\n    $(event.currentTarget).find(".tooltip:hover .tooltipcontent").css("left", `${event.clientX}px`).css("top", `${event.clientY + 24}px`);\r\n  }\r\n\r\n  _onTextAreaDrop(event) {\r\n    const elem = event.currentTarget;\r\n  }\r\n\r\n  async _onLinksDrop(event) {\r\n    const elem = event.currentTarget;\r\n    const linkType = elem.dataset.tab;\r\n    \r\n    // Try to extract the data\r\n    let data;\r\n    try {\r\n      data = JSON.parse(event.originalEvent.dataTransfer.getData(\'text/plain\'));\r\n      if (data.type !== "Item") return;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n\r\n    let itemData = {};\r\n    let dataType = "";\r\n    let itemLink = "";\r\n\r\n    // Case 1 - Import from a Compendium pack\r\n    if (data.pack) {\r\n      dataType = "compendium";\r\n      const pack = game.packs.find(p => p.collection === data.pack);\r\n      const packItem = await pack.getEntity(data.id);\r\n      if (packItem != null) {\r\n        itemData = packItem.data;\r\n        itemLink = `${pack.key}.${packItem._id}`;\r\n      }\r\n    }\r\n\r\n    // Case 2 - Data explicitly provided\r\n    else if (data.data) {\r\n      dataType = "data";\r\n      itemData = data.data;\r\n      itemLink = itemData._id;\r\n    }\r\n\r\n    // Case 3 - Import from World entity\r\n    else {\r\n      dataType = "world";\r\n      itemData = game.items.get(data.id).data;\r\n      itemLink = `world.${data.id}`;\r\n    }\r\n\r\n    if (this.canCreateLink(linkType, dataType, itemData, itemLink, data)) {\r\n      const updateData = {};\r\n      let _links = duplicate(getProperty(this.item.data, `data.links.${linkType}`) || []);\r\n      const link = this.generateInitialLinkData(linkType, dataType, itemData, itemLink);\r\n      _links.push(link);\r\n      updateData[`data.links.${linkType}`] = _links;\r\n\r\n      // Call link creation hook\r\n      await this.item.update(updateData);\r\n      Hooks.call("createItemLink", this.item, link, linkType);\r\n\r\n      /**\r\n       * @TODO This is a really shitty way of re-rendering the actor sheet, so I should change this method at some point,\r\n       * but the premise is that the actor sheet should show data for newly linked items, and it won\'t do it immediately for some reason\r\n       */\r\n      window.setTimeout(() => { if (this.item.actor) this.item.actor.sheet.render(); }, 50);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} linkType - The type of link.\r\n   * @param {string} dataType - Either "compendium", "data" or "world".\r\n   * @param {Object} itemData - The (new) item\'s data.\r\n   * @param {string} itemLink - The link identifier for the item.\r\n   * @param {Object} [data] - The raw data from a drop event.\r\n   * @returns {boolean} Whether a link to the item is possible here.\r\n   */\r\n  canCreateLink(linkType, dataType, itemData, itemLink, data=null) {\r\n    const actor = this.item.actor;\r\n    const sameActor = actor != null && data != null && data.actorId === actor._id;\r\n\r\n    // Don\'t create link to self\r\n    const itemId = itemLink.split(".").slice(-1)[0];\r\n    if (itemId === this.item._id) return false;\r\n\r\n    // Don\'t create existing links\r\n    const links = getProperty(this.item.data, `data.links.${linkType}`) || [];\r\n    if (links.filter(o => o.id === itemLink).length) return false;\r\n\r\n    if (["children", "charges"].includes(linkType) && sameActor) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {string} linkType - The type of link.\r\n   * @param {string} dataType - Either "compendium", "data" or "world".\r\n   * @param {Object} itemData - The (new) item\'s data.\r\n   * @param {string} itemLink - The link identifier for the item.\r\n   * @param {Object} [data] - The raw data from a drop event.\r\n   * @returns {Array} An array to insert into this item\'s link data.\r\n   */\r\n  generateInitialLinkData(linkType, dataType, itemData, itemLink, data=null) {\r\n\r\n    return {\r\n      id: itemLink,\r\n      dataType: dataType,\r\n      name: itemData.name,\r\n      img: itemData.img,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add or remove a damage part from the damage formula\r\n   * @param {Event} event     The original click event\r\n   * @return {Promise}\r\n   * @private\r\n   */\r\n  async _onDamageControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add new damage component\r\n    if ( a.classList.contains("add-damage") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const damage = this.item.data.data.damage;\r\n      return this.item.update({"data.damage.parts": damage.parts.concat([["", ""]])});\r\n    }\r\n\r\n    // Remove a damage component\r\n    if ( a.classList.contains("delete-damage") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const li = a.closest(".damage-part");\r\n      const damage = duplicate(this.item.data.data.damage);\r\n      damage.parts.splice(Number(li.dataset.damagePart), 1);\r\n      return this.item.update({"data.damage.parts": damage.parts});\r\n    }\r\n  }\r\n\r\n  async _onCritDamageControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add new damage component\r\n    if ( a.classList.contains("add-damage") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const damage = this.item.data.data.damage;\r\n      return this.item.update({"data.damage.critParts": damage.critParts.concat([["", ""]])});\r\n    }\r\n\r\n    // Remove a damage component\r\n    if ( a.classList.contains("delete-damage") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const li = a.closest(".damage-part");\r\n      const damage = duplicate(this.item.data.data.damage);\r\n      damage.critParts.splice(Number(li.dataset.damagePart), 1);\r\n      return this.item.update({"data.damage.critParts": damage.critParts});\r\n    }\r\n  }\r\n\r\n  async _onAttackControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add new attack component\r\n    if ( a.classList.contains("add-attack") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const attackParts = this.item.data.data.attackParts;\r\n      return this.item.update({"data.attackParts": attackParts.concat([["", ""]])});\r\n    }\r\n\r\n    // Remove an attack component\r\n    if ( a.classList.contains("delete-attack") ) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const li = a.closest(".attack-part");\r\n      const attackParts = duplicate(this.item.data.data.attackParts);\r\n      attackParts.splice(Number(li.dataset.attackPart), 1);\r\n      return this.item.update({"data.attackParts": attackParts});\r\n    }\r\n  }\r\n\r\n  async _onBuffControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add new change\r\n    if (a.classList.contains("add-change")) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const changes = this.item.data.data.changes || [];\r\n      return this.item.update({"data.changes": changes.concat([_entity_js__WEBPACK_IMPORTED_MODULE_2__["ItemPF"].defaultChange])});\r\n    }\r\n\r\n    // Remove a change\r\n    if (a.classList.contains("delete-change")) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const li = a.closest(".change");\r\n      const changes = duplicate(this.item.data.data.changes);\r\n      changes.splice(Number(li.dataset.change), 1);\r\n      return this.item.update({"data.changes": changes});\r\n    }\r\n  }\r\n\r\n  async _onNoteControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Add new note\r\n    if (a.classList.contains("add-note")) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const contextNotes = this.item.data.data.contextNotes || [];\r\n      return this.item.update({"data.contextNotes": contextNotes.concat([_entity_js__WEBPACK_IMPORTED_MODULE_2__["ItemPF"].defaultContextNote])});\r\n    }\r\n\r\n    // Remove a note\r\n    if (a.classList.contains("delete-note")) {\r\n      await this._onSubmit(event);  // Submit any unsaved changes\r\n      const li = a.closest(".context-note");\r\n      const contextNotes = duplicate(this.item.data.data.contextNotes);\r\n      contextNotes.splice(Number(li.dataset.note), 1);\r\n      return this.item.update({"data.contextNotes": contextNotes});\r\n    }\r\n  }\r\n\r\n  async _onLinkControl(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n\r\n    // Delete link\r\n    if (a.classList.contains("delete-link")) {\r\n      await this._onSubmit(event);\r\n      const li = a.closest(".links-item");\r\n      const group = a.closest(\'div[data-group="links"]\');\r\n      let links = duplicate(getProperty(this.item.data, `data.links.${group.dataset.tab}`) || []);\r\n      const link = links.find(o => o.id === li.dataset.link);\r\n      links = links.filter(o => o !== link);\r\n\r\n      const updateData = {};\r\n      updateData[`data.links.${group.dataset.tab}`] = links;\r\n\r\n      // Call hook for deleting a link\r\n      Hooks.call("deleteItemLink", this.item, link, group.dataset.tab);\r\n\r\n      await this.item.update(updateData);\r\n\r\n      // Clean link\r\n      this.item._cleanLink(link, group.dataset.tab);\r\n      game.socket.emit("system.pf1", { eventType: "cleanItemLink", actorUUID: this.item.actor.uuid, itemUUID: this.item.uuid, link: link, linkType: group.dataset.tab });\r\n    }\r\n  }\r\n\r\n  async _onFilePickerAlt(event) {\r\n    const button = event.currentTarget;\r\n    const attr = button.dataset.for;\r\n    const current = getProperty(this.item.data, attr);\r\n    const form = button.form;\r\n    const targetField = form[attr];\r\n    if (!targetField) return;\r\n\r\n    const fp = new FilePicker({\r\n      type: button.dataset.type,\r\n      current: current,\r\n      callback: path => {\r\n        targetField.value = path;\r\n        if (this.options.submitOnChange) {\r\n          this._onSubmit(event);\r\n        }\r\n      },\r\n      top: this.position.top + 40,\r\n      left: this.position.left + 10,\r\n    });\r\n    fp.browse(current);\r\n  }\r\n\r\n  async _createAttack(event) {\r\n    if (this.item.actor == null) throw new Error(game.i18n.localize("PF1.ErrorItemNoOwner"));\r\n\r\n    await this._onSubmit(event);\r\n\r\n    await this.item.actor.createAttackFromWeapon(this.item);\r\n  }\r\n\r\n  _onEntrySelector(event) {\r\n    event.preventDefault();\r\n    const a = event.currentTarget;\r\n    const options = {\r\n      name: a.getAttribute("for"),\r\n      title: a.innerText,\r\n      fields: a.dataset.fields,\r\n      dtypes: a.dataset.dtypes,\r\n    };\r\n    new _apps_entry_selector_js__WEBPACK_IMPORTED_MODULE_1__["EntrySelector"](this.item, options).render(true);\r\n  }\r\n\r\n  async saveMCEContent(updateData=null) {\r\n    let manualUpdate = false;\r\n    if (updateData == null) {\r\n      manualUpdate = true;\r\n      updateData = {};\r\n    }\r\n\r\n    for (const [key, editor] of Object.entries(this.editors)) {\r\n      if (editor.mce == null) continue;\r\n\r\n      updateData[key] = editor.mce.getContent();\r\n    }\r\n\r\n    if (manualUpdate && Object.keys(updateData).length > 0) await this.item.update(updateData);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/item/sheets/base.js?')},"./module/lib.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTag", function() { return createTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alterRoll", function() { return alterRoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTabs", function() { return createTabs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpackVersion", function() { return unpackVersion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMinimumCoreVersion", function() { return isMinimumCoreVersion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degtorad", function() { return degtorad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radtodeg", function() { return radtodeg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkData", function() { return linkData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getItemOwner", function() { return getItemOwner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CR", function() { return CR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sizeDie", function() { return sizeDie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalDie", function() { return normalDie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sizeRoll", function() { return sizeRoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalRoll", function() { return normalRoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActorFromId", function() { return getActorFromId; });\n/* harmony import */ var _misc_list_tabs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc/list-tabs.js */ "./module/misc/list-tabs.js");\n\n\n/**\n * Creates a tag from a string.\n * For example, if you input the string "Wizard of Oz 2", you will get "wizardOfOz2"\n */\nconst createTag = function(str) {\n  if (str.length === 0) str = "tag";\n  return str.replace(/[^a-zA-Z0-9\\s]/g, "").split(/\\s+/).map((s, a) => {\n    s = s.toLowerCase();\n    if (a > 0) s = s.substring(0, 1).toUpperCase() + s.substring(1);\n    return s;\n  }).join("");\n};\n\n/**\n * Alters a roll in string form.\n */\nconst alterRoll = function(str, add, multiply) {\n  const rgx = new RegExp(Die.rgx.die, "g");\n  if (str.match(/^([0-9]+)d([0-9]+)/)) {\n    return str.replace(rgx, (match, nd, d, mods) => {\n      nd = (nd * (multiply || 1)) + (add || 0);\n      mods = mods || "";\n      return ((nd == null || Number.isNaN(nd)) ? "" : nd) + "d" + d + mods;\n    });\n  }\n  return str;\n};\n\n/**\n * Creates tabs for a sheet object\n */\nconst createTabs = function(html, tabGroups) {\n  // Create recursive activation/callback function\n  const _recursiveActivate = function(rtabs, tabName=null) {\n    if (tabName == null) this._initialTab[rtabs.group] = rtabs.active;\n    else {\n      rtabs.activate(tabName);\n      this._initialTab[rtabs.group] = tabName;\n    }\n\n    // Scroll to previous position\n    let scrollElems = html.find(`.scroll-${rtabs.group}`);\n    if (scrollElems.length === 0) scrollElems = html.find(`.tab[data-group="${rtabs.group}"]`);\n    for (let o of scrollElems) { o.scrollTop = this._scrollTab[rtabs.group]; }\n\n    // Recursively activate tabs\n    for (let subTab of rtabs.subTabs) {\n      _recursiveActivate.call(this, subTab, subTab.active);\n    }\n  };\n\n  // Create all tabs\n  const _func = function(group, children) {\n    if (html.find(`nav[data-group="${group}"]`).length === 0) return null;\n\n    if (this._initialTab == null) this._initialTab = {};\n    if (this._scrollTab == null) this._scrollTab = {};\n\n    const subHtml = html.find(`.${group}-body > div[data-group="${group}"]`);\n    const activeSubHtml = subHtml.filter(".active");\n    const initial = this._initialTab[group] !== undefined ? this._initialTab[group] : (activeSubHtml.length > 0 ? activeSubHtml[0].dataset.tab : "");\n\n    // Set up data for scroll position and active tab\n    if (this._scrollTab[group] === undefined) this._scrollTab[group] = 0;\n    if (this._initialTab[group] === undefined) this._initialTab[group] = initial;\n\n    // Set up scrolling callback\n    let scrollElems = html.find(`.scroll-${group}`);\n    if (scrollElems.length === 0) scrollElems = html.find(`.tab[data-group="${group}"]`);\n    scrollElems.scroll(ev => this._scrollTab[group] = ev.currentTarget.scrollTop);\n\n    // Determine tab type\n    const tabsElem = html.find(`.tabs[data-group="${group}"]`)[0];\n    if (!tabsElem) return;\n    let type = tabsElem.dataset.tabsType;\n    let cls = TabsV2;\n    if (type === "list") {\n      cls = _misc_list_tabs_js__WEBPACK_IMPORTED_MODULE_0__["ListTabs"];\n    }\n\n    // Create tabs object\n    const tabs = new cls({\n      navSelector: `.tabs[data-group="${group}"]`,\n      contentSelector: `.${group}-body`,\n      callback: (_, tabs) => {\n        _recursiveActivate.call(this, tabs);\n      },\n    });\n\n    // Recursively create tabs\n    tabs.group = group;\n    tabs.subTabs = [];\n    for (let [childKey, subChildren] of Object.entries(children)) {\n      const newTabs = _func.call(this, childKey, subChildren);\n      if (newTabs != null) tabs.subTabs.push(newTabs);\n    }\n\n    tabs.bind(html[0]);\n    _recursiveActivate.call(this, tabs, this._initialTab[group]);\n    return tabs;\n  };\n\n  for (const groupKey of Object.keys(tabGroups)) {\n    _func.call(this, groupKey, tabGroups[groupKey]);\n  }\n};\n\n/**\n * @param {String} version - A version string to unpack. Must be something like \'0.5.1\'.\n * @returns {Object} An object containing the keys \'release\', \'major\', and \'minor\', which are numbers.\n */\nconst unpackVersion = function(version) {\n  if (version.match(/^([0-9]+)\\.([0-9]+)(?:\\.([0-9]+))?$/)) {\n    return {\n      release: parseInt(RegExp.$1),\n      major: parseInt(RegExp.$2),\n      minor: parseInt(RegExp.$3) || null,\n    };\n  }\n};\n\n/**\n * @param {String} version - The minimum core version to compare to. Must be something like \'0.5.1\'.\n * @returns {Boolean} Whether the current core version is at least the given version.\n */\nconst isMinimumCoreVersion = function(version) {\n  const coreVersion = unpackVersion(game.data.version);\n  const compareVersion = unpackVersion(version);\n\n  for (const versionType of ["release", "major", "minor"]) {\n    const curValue = coreVersion[versionType];\n    const compareValue = compareVersion[versionType];\n\n    if (curValue == null) {\n      if (compareValue == null) continue;\n      return false;\n    }\n    if (compareValue == null) {\n      if (curValue == null) continue;\n      return true;\n    }\n\n    if (curValue > compareValue) return true;\n    if (curValue < compareValue) return false;\n  }\n\n  return true;\n};\n\nconst degtorad = function(degrees) {\n  return degrees * Math.PI / 180;\n};\n\nconst radtodeg = function(radians) {\n  return radians / 180 * Math.PI;\n};\n\nconst linkData = function(expanded, flattened, key, value) {\n  setProperty(expanded, key, value);\n  flattened[key] = value;\n};\n\nconst getItemOwner = function(item) {\n  if (item.actor) return item.actor;\n  if (item._id) {\n    return game.actors.entities.filter(o => {\n      return o.items.filter(i => i._id === item._id).length > 0;\n    })[0];\n  }\n  return null;\n};\n\nconst CR = {\n  fromString(value) {\n    if (value === "1/8") return 0.125;\n    if (value === "1/6") return 0.1625;\n    if (value === "1/4") return 0.25;\n    if (value === "1/3") return 0.3375;\n    if (value === "1/2") return 0.5;\n    return parseFloat(value);\n  },\n\n  fromNumber(value) {\n    if (value === 0.125) return "1/8";\n    if (value === 0.1625) return "1/6";\n    if (value === 0.25) return "1/4";\n    if (value === 0.3375) return "1/3";\n    if (value === 0.5) return "1/2";\n    return value.toString();\n  },\n};\n\nconst sizeDie = function(origCount, origSides, targetSize="M", crit=1) {\n  if (typeof targetSize === "string") targetSize = Object.values(CONFIG.PF1.sizeChart).indexOf(targetSize.toUpperCase());\n  else if (typeof targetSize === "number") targetSize = Math.max(0, Math.min(Object.values(CONFIG.PF1.sizeChart).length - 1, Object.values(CONFIG.PF1.sizeChart).indexOf("M") + targetSize));\n  let c = duplicate(CONFIG.PF1.sizeDie);\n\n  const mediumDie = `${origCount}d${origSides}`;\n  const mediumDieMax = origCount * origSides;\n  if (c.indexOf(mediumDie) === -1) {\n    c = c.map(d => {\n      if (d.match(/^([0-9]+)d([0-9]+)$/)) {\n        const dieCount = parseInt(RegExp.$1),\n          dieSides = parseInt(RegExp.$2),\n          dieMaxValue = dieCount * dieSides;\n        \n        if (dieMaxValue === mediumDieMax) return mediumDie;\n      }\n\n      return d;\n    });\n  }\n\n  // Alter chart based on original die\n  // for (let a = 0; a < c.length; a++) {\n    // const d = c[a];\n    // if (d.match(/^([0-9]+)d([0-9]+)$/)) {\n      // const dieCount = parseInt(RegExp.$1),\n        // dieSides = parseInt(RegExp.$2),\n        // dieMaxValue = dieCount * dieSides;\n\n      // if (origSides === 4 && origCount >= 2) {\n        // if (dieSides === 8) {\n          // c[a] = `${dieCount*2}d4`;\n        // }\n        // else if (dieSides === 6 && Math.floor(dieMaxValue / origSides) === dieMaxValue / origSides) {\n          // c[a] = `${Math.floor(dieMaxValue / origSides)}d4`;\n        // }\n      // }\n      // else if (origSides === 12) {\n        // if (dieSides === 6 && Math.floor(dieMaxValue / origSides) === dieMaxValue / origSides) {\n          // c[a] = `${Math.floor(dieMaxValue / origSides)}d12`;\n        // }\n      // }\n    // }\n  // }\n\n  // Pick an index from the chart\n  let index = c.indexOf(mediumDie),\n    formula = mediumDie;\n  if (index >= 0) {\n    const d6Index = c.indexOf("1d6");\n    let d8Index = c.indexOf("1d8");\n    if (d8Index === -1) d8Index = c.indexOf("2d4");\n    let indexOffset = (targetSize - 4);\n    const sizeIncrease = indexOffset > 0;\n\n    while (indexOffset !== 0) {\n      if ((sizeIncrease && index <= d6Index) ||\n        (!sizeIncrease && index <= d8Index)) {\n      // if ((index <= d8Index && indexOffset < 1) ||\n      // (index <= d6Index && indexOffset < 0)) {\n        if (indexOffset < 0) {\n          index--;\n          indexOffset++;\n        }\n        else {\n          index++;\n          indexOffset--;\n        }\n      }\n      else {\n        if (indexOffset < 0) {\n          index -= 2;\n          indexOffset++;\n        }\n        else {\n          index += 2;\n          indexOffset--;\n        }\n      }\n    }\n\n    // Alter crit\n    index = Math.max(0, Math.min(c.length - 1, index));\n    formula = c[index];\n  }\n\n  if (crit !== 1 && formula.match(/^([0-9]+)d([0-9]+)(.*)/)) {\n    const count = parseInt(RegExp.$1);\n    const sides = parseInt(RegExp.$2);\n    formula = `${count * crit}d${sides}${RegExp.$3}`;\n  }\n  if (index === -1) {\n    ui.notifications.warn(game.i18n.localize("PF1.WarningNoSizeDie").format(mediumDie, formula));\n  }\n\n  return formula;\n};\n\nconst normalDie = function(origCount, origSides, crit=1) {\n  let formula = `${origCount}d${origSides}`;\n\n  if (crit !== 1 && formula.match(/^([0-9]+)d([0-9]+)(.*)/)) {\n    const count = parseInt(RegExp.$1);\n    const sides = parseInt(RegExp.$2);\n    formula = `${count * crit}d${sides}${RegExp.$3}`;\n  }\n\n  return formula;\n};\n\n/**\n * Returns the result of a roll of die, which changes based on different sizes.\n * @param {number} origCount - The original number of die to roll.\n * @param {number} origSides - The original number of sides per die to roll.\n * @param {string|number} [targetSize="M"] - The target size to change the die to.\n * @param {number} [crit=1] - The critical multiplier (for if the attack is a critical threat).\n *   Can be a string of values "F", "D", "T", "S", "M", "L", "H", "G" or "C" for the different sizes.\n *   Can also be a number in the range of -4 to 4, where 0 is Medium.\n * @returns {number} The result of the new roll.\n */\nconst sizeRoll = function(origCount, origSides, targetSize="M", crit=1) {\n  return new Roll(sizeDie(origCount, origSides, targetSize, crit)).roll().total;\n};\n\n/**\n * Returns the result of a roll of die.\n * @param {number} count - The original number of die to roll.\n * @param {number} sides - The original number of sides per die to roll.\n * @returns {number} The result of the new roll.\n */\nconst normalRoll = function(count, sides, crit=1) {\n  return new Roll(normalDie(count, sides, crit)).roll().total;\n};\n\nconst getActorFromId = function(id) {\n  const speaker = ChatMessage.getSpeaker();\n  let actor = null;\n  if (id) {\n    actor = game.actors.tokens[id];\n    if (!actor) actor = game.actors.get(id);\n  }\n  if (speaker.token && !actor) actor = game.actors.tokens[speaker.token];\n  if (!actor) actor = game.actors.get(speaker.actor);\n  return actor;\n};\n\n\n//# sourceURL=webpack://pf1/./module/lib.js?')},"./module/low-light-vision.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _token_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token-config.js */ "./module/token-config.js");\n\n\n\n// Patch Token\'s sheet template\nObject.defineProperties(Token.prototype, {\n  sheet: {\n    get() {\n      if (!this._sheet) this._sheet = new _token_config_js__WEBPACK_IMPORTED_MODULE_0__["TokenConfigPF"](this);\n      return this._sheet;\n    }\n  },\n  actorVision: {\n    get() {\n      return this.actor.data.data.attributes.vision || {};\n    }\n  }\n});\n\nconst Token_update = Token.prototype.update;\nToken.prototype.update = async function(data, options={}) {\n  const updateData = {};\n\n  if (data.visionLL != null) {\n    updateData["data.attributes.vision.lowLight"] = data.visionLL;\n  }\n  if (data.darkvision != null) {\n    updateData["data.attributes.vision.darkvision"] = data.darkvision;\n  }\n\n  if (Object.keys(updateData).length) {\n    await this.actor.update(updateData);\n  }\n\n  return Token_update.call(this, data, options);\n};\n\nSightLayer.prototype.hasLowLight = function() {\n  const relevantTokens = canvas.tokens.placeables.filter(o => {\n    return o.actor && o.actor.hasPerm(game.user, "OBSERVER");\n  });\n  const lowLightTokens = relevantTokens.filter(o => getProperty(o, "actorVision.lowLight"));\n  if (game.user.isGM) {\n    return lowLightTokens.filter(o => o._controlled).length > 0;\n  }\n  if (game.settings.get("pf1", "lowLightVisionMode")) {\n    return lowLightTokens.filter(o => o._controlled).length > 0;\n  }\n  return (!relevantTokens.filter(o => o._controlled).length && lowLightTokens.length) || lowLightTokens.filter(o => o._controlled).length > 0;\n};\n\nSightLayer.prototype.hasDarkvision = function() {\n  const relevantTokens = canvas.tokens.placeables.filter(o => {\n    return o.actor && o.actor.hasPerm(game.user, "OBSERVER");\n  });\n  const darkvisionTokens = relevantTokens.filter(o => o.getDarkvisionRadius() > 0);\n  if (game.user.isGM) {\n    return darkvisionTokens.filter(o => o._controlled).length > 0;\n  }\n  if (game.settings.get("pf1", "lowLightVisionMode")) {\n    return darkvisionTokens.filter(o => o._controlled).length > 0;\n  }\n  return (!relevantTokens.filter(o => o._controlled).length && darkvisionTokens.length) || darkvisionTokens.filter(o => o._controlled).length > 0;\n};\n\nconst AmbientLight__get__dimRadius = Object.getOwnPropertyDescriptor(AmbientLight.prototype, "dimRadius").get;\nObject.defineProperty(AmbientLight.prototype, "dimRadius", {\n  get: function() {\n    let result = AmbientLight__get__dimRadius.call(this);\n    if (canvas.sight.hasLowLight() && result > 0) result *= 2;\n    return result;\n  }\n});\n\nconst AmbientLight__get__brightRadius = Object.getOwnPropertyDescriptor(AmbientLight.prototype, "brightRadius").get;\nObject.defineProperty(AmbientLight.prototype, "brightRadius", {\n  get: function() {\n    let result = AmbientLight__get__brightRadius.call(this);\n    if (canvas.sight.hasLowLight() && result > 0) result *= 2;\n    return result;\n  }\n});\n\nconst Token__get__dimLightRadius = Object.getOwnPropertyDescriptor(Token.prototype, "dimLightRadius").get;\nObject.defineProperty(Token.prototype, "dimLightRadius", {\n  get: function() {\n    let result = Token__get__dimLightRadius.call(this);\n    if (canvas.sight.hasLowLight() && result > 0) result *= 2;\n    return result;\n  }\n});\n\nconst Token__get__brightLightRadius = Object.getOwnPropertyDescriptor(Token.prototype, "brightLightRadius").get;\nObject.defineProperty(Token.prototype, "brightLightRadius", {\n  get: function() {\n    let result = Token__get__brightLightRadius.call(this);\n    if (canvas.sight.hasLowLight() && result > 0) result *= 2;\n    return result;\n  }\n});\n\nconst SightLayer_initializeTokens = SightLayer.prototype.initializeTokens;\nSightLayer.prototype.initializeTokens = function(options) {\n  options = options || {};\n  const defer = options.defer || false;\n  options.defer = true;\n\n  SightLayer_initializeTokens.call(this, options);\n  this.initializeLights(options);\n  canvas.lighting.update();\n\n  if (!defer) this.update();\n};\n\nToken.prototype.getDarkvisionRadius = function() {\n  return this.getLightRadius(getProperty(this, "actor.data.data.attributes.vision.darkvision") || 0);\n};\n\nToken.prototype.getDarkvisionSight = function() {\n  const radius = this.getDarkvisionRadius();\n  if (!radius) return null;\n\n  const walls = canvas.walls.blockVision;\n  const globalLight = canvas.scene.data.globalLight;\n  const maxR = globalLight ? Math.max(canvas.dimensions.width, canvas.dimensions.height) : null;\n  let [cullMult, cullMin, cullMax] = canvas.sight._cull;\n  if (globalLight) cullMin = maxR;\n\n  return canvas.sight.constructor.computeSight(this.getSightOrigin(), radius, {\n    angle: this.data.angle,\n    cullMult: cullMult,\n    cullMin: cullMin,\n    cullMax: cullMax,\n    density: 6,\n    rotation: this.data.rotation,\n    walls: walls,\n  });\n};\n\nconst SightLayer_update = SightLayer.prototype.update;\nSightLayer.prototype.update = function() {\n  SightLayer_update.call(this);\n};\n\n/**\n * Monkey patched updateToken method for SightLayer\n */\nSightLayer.prototype.updateToken = function(token, {defer=false, deleted=false, walls=null, forceUpdateFog=false}={}) {\n  let sourceId = `Token.${token.id}`;\n  this.sources.vision.delete(sourceId);\n  this.sources.lights.delete(sourceId);\n  if ( deleted ) return defer ? null : this.update();\n  if ( token.data.hidden && !game.user.isGM ) return;\n\n  // Vision is displayed if the token is controlled, or if it is observed by a player with no tokens controlled\n  let displayVision = token._controlled;\n  if ( !displayVision && !game.user.isGM && !canvas.tokens.controlled.length ) {\n    displayVision = token.actor && token.actor.hasPerm(game.user, "OBSERVER");\n  }\n\n  // Take no action for Tokens which are invisible or Tokens that have no sight or light\n  const globalLight = canvas.scene.data.globalLight;\n  let isVisionSource = this.tokenVision && token.hasSight && displayVision;\n  let isLightSource = token.emitsLight;\n\n  // If the Token is no longer a source, we don\'t need further work\n  if ( !isVisionSource && !isLightSource ) return;\n\n  // Prepare some common data\n  const center = token.getSightOrigin();\n  const maxR = globalLight ? Math.max(canvas.dimensions.width, canvas.dimensions.height) : null;\n  let [cullMult, cullMin, cullMax] = this._cull;\n  if ( globalLight ) cullMin = maxR;\n\n  // Prepare vision sources\n  if ( isVisionSource ) {\n\n    // Compute vision polygons\n    let dim = globalLight ? 0 : token.getLightRadius(token.data.dimSight);\n    const bright = globalLight ? maxR : token.getLightRadius(token.data.brightSight);\n    const darkvision = this.hasDarkvision() ? token.getDarkvisionRadius() : 0;\n    if ((dim === 0) && (bright === 0) && (darkvision === 0)) dim = canvas.dimensions.size * 0.6;\n    const radius = Math.max(Math.abs(dim), Math.abs(bright), Math.abs(darkvision));\n    const {los, fov} = this.constructor.computeSight(center, radius, {\n      angle: token.data.sightAngle,\n      cullMult: cullMult,\n      cullMin: cullMin,\n      cullMax: cullMax,\n      density: 6,\n      rotation: token.data.rotation,\n      walls: walls\n    });\n\n    // Add a vision source\n    const source = new SightLayerSource({\n      x: center.x,\n      y: center.y,\n      los: los,\n      fov: fov,\n      dim: dim,\n      bright: Math.max(bright, darkvision),\n      color: "#ffffff",\n      alpha: 1,\n    });\n    this.sources.vision.set(sourceId, source);\n\n    // Update fog exploration for the token position\n    this.updateFog(center.x, center.y, Math.max(dim, bright, darkvision), token.data.sightAngle !== 360, forceUpdateFog);\n  }\n\n  // Prepare light sources\n  if ( isLightSource ) {\n\n    // Compute light emission polygons\n    const dim = token.dimLightRadius;\n    const bright = token.brightLightRadius;\n    const radius = Math.max(Math.abs(dim), Math.abs(bright));\n    const {fov} = this.constructor.computeSight(center, radius, {\n      angle: token.data.lightAngle,\n      cullMult: cullMult,\n      cullMin: cullMin,\n      cullMax: cullMax,\n      density: 6,\n      rotation: token.data.rotation,\n      walls: walls\n    });\n\n    // Add a light source\n    const source = new SightLayerSource({\n      x: center.x,\n      y: center.y,\n      los: null,\n      fov: fov,\n      dim: dim,\n      bright: bright,\n      color: token.data.lightColor,\n      alpha: token.data.lightAlpha\n    });\n    this.sources.lights.set(sourceId, source);\n  }\n\n  // Maybe update\n  if ( CONFIG.debug.sight ) console.debug(`Updated SightLayer source for ${sourceId}`);\n  if ( !defer ) this.update();\n};\n\n/**\n * Monkey patched update method for LightingLayer\n */\nLightingLayer.prototype.update = function(alpha=null) {\n  const d = canvas.dimensions;\n  const c = this.lighting;\n\n  // Draw darkness layer\n  this._darkness = alpha !== null ? alpha : canvas.scene.data.darkness;\n  c.darkness.clear();\n  const darknessPenalty = 0.8;\n  let darknessColor = canvas.scene.getFlag("core", "darknessColor") || CONFIG.Canvas.darknessColor;\n  if ( typeof darknessColor === "string" ) darknessColor = colorStringToHex(darknessColor);\n  c.darkness.beginFill(darknessColor, this._darkness * darknessPenalty)\n    .drawRect(0, 0, d.width, d.height)\n    .endFill();\n\n  // Draw lighting atop the darkness\n  c.lights.clear();\n  for ( let s of canvas.sight.sources.lights.values() ) {\n    if ( s.darknessThreshold <= this._darkness ) {\n      c.lights.beginFill(s.color, s.alpha).drawPolygon(s.fov).endFill();\n    }\n  }\n\n  if (canvas.sight.hasDarkvision) {\n    this.updateDarkvision();\n  }\n};\n\nLightingLayer.prototype.updateDarkvision = function() {\n  const c = this.lighting;\n\n  // Draw token darkvision\n  const vision = canvas.sight.sources.vision;\n  for (let k of vision.keys()) {\n    const t = canvas.tokens.placeables.find(o => `Token.${o.id}` === k);\n    if (!t) continue;\n    const sight = t.getDarkvisionSight();\n    if (!sight) continue;\n    const fov = sight.fov;\n    c.lights.beginFill(0xFFFFFF, 1).drawPolygon(fov).endFill();\n  }\n};\n\n\n//# sourceURL=webpack://pf1/./module/low-light-vision.js?')},"./module/measure.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ "./module/lib.js");\n\n\n// Use 90 degrees cone in PF1 style\nconst TemplateLayer__onDragLeftStart = TemplateLayer.prototype._onDragLeftStart;\nTemplateLayer.prototype._onDragLeftStart = function(event) {\n  if (!game.settings.get("pf1", "measureStyle")) return TemplateLayer__onDragLeftStart.call(this, event);\n\n  PlaceablesLayer.prototype._onDragLeftStart.call(this, event);\n\n  // Create the new preview template\n  const tool = game.activeTool;\n  const origin = event.data.origin;\n  let pos;\n  if (["cone", "circle"].includes(tool)) {\n    pos = canvas.grid.getSnappedPosition(origin.x, origin.y, 2);\n  }\n  else pos = canvas.grid.getSnappedPosition(origin.x, origin.y, 2);\n  origin.x = pos.x;\n  origin.y = pos.y;\n\n  // Create the template\n  const data = {\n    user: game.user._id,\n    t: tool,\n    x: pos.x,\n    y: pos.y,\n    distance: 0,\n    direction: 0,\n    fillColor: game.user.data.color || "#FF0000"\n  };\n  if (tool === "cone") data["angle"] = 90;\n  else if (tool === "ray") data["width"] = 5;\n\n  // Assign the template\n  let template = new MeasuredTemplate(data);\n  event.data.preview = this.preview.addChild(template);\n  template.draw();\n};\n\n\nconst TemplateLayer__onDragLeftMove = TemplateLayer.prototype._onDragLeftMove;\nTemplateLayer.prototype._onDragLeftMove = function(event) {\n  if (!game.settings.get("pf1", "measureStyle")) return TemplateLayer__onDragLeftMove.call(this, event);\n\n  PlaceablesLayer.prototype._onDragLeftMove.call(this, event);\n  if (event.data.createState >= 1) {\n    // Snap the destination to the grid\n    let dest = event.data.destination;\n    let {x, y} = canvas.grid.getSnappedPosition(dest.x, dest.y, 2);\n    dest.x = x;\n    dest.y = y;\n\n    // Compute the ray\n    let template = event.data.preview,\n        ray = new Ray(event.data.origin, event.data.destination),\n        ratio = (canvas.dimensions.size / canvas.dimensions.distance);\n\n    // Update the shape data\n    if (["cone", "circle"].includes(template.data.t)) {\n      const direction = ray.angle;\n      template.data.direction = toDegrees(Math.floor((direction + (Math.PI * 0.125)) / (Math.PI * 0.25)) * (Math.PI * 0.25));\n      const distance = ray.distance / ratio;\n      template.data.distance = Math.floor(distance / canvas.dimensions.distance) * canvas.dimensions.distance;\n    }\n    else {\n      template.data.direction = toDegrees(ray.angle);\n      template.data.distance = ray.distance / ratio;\n    }\n\n    // Draw the pending shape\n    template.refresh();\n    event.data.createState = 2;\n  }\n};\n\n\n// Highlight grid in PF1 style\nconst MeasuredTemplate_highlightGrid = MeasuredTemplate.prototype.highlightGrid;\nMeasuredTemplate.prototype.highlightGrid = function() {\n  if (!game.settings.get("pf1", "measureStyle") || !(["circle", "cone"].includes(this.data.t))) return MeasuredTemplate_highlightGrid.call(this);\n\n  const grid = canvas.grid,\n        d = canvas.dimensions,\n        bc = this.borderColor,\n        fc = this.fillColor;\n\n  // Only highlight for objects which have a defined shape\n  if ( !this.id || !this.shape ) return;\n\n  // Clear existing highlight\n  const hl = grid.getHighlightLayer(`Template.${this.id}`);\n  hl.clear();\n\n  // Get number of rows and columns\n  let nr = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.h)),\n      nc = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.w));\n\n  // Get the center of the grid position occupied by the template\n  let x = this.data.x,\n    y = this.data.y;\n\n  let [cx, cy] = grid.getCenter(x, y),\n    [col0, row0] = grid.grid.getGridPositionFromPixels(cx, cy),\n    minAngle = (360 + ((this.data.direction - this.data.angle * 0.5) % 360)) % 360,\n    maxAngle = (360 + ((this.data.direction + this.data.angle * 0.5) % 360)) % 360;\n\n  const within_angle = function(min, max, value) {\n    min = (360 + min % 360) % 360;\n    max = (360 + max % 360) % 360;\n    value = (360 + value % 360) % 360;\n\n    if (min < max) return (value >= min && value <= max);\n    return (value >= min || value <= max);\n  };\n\n  const measureDistance = function(p0, p1) {\n    let gs = canvas.dimensions.size,\n    ray = new Ray(p0, p1),\n    // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n    nx = Math.ceil(Math.abs(ray.dx / gs)),\n    ny = Math.ceil(Math.abs(ray.dy / gs));\n\n    // Get the number of straight and diagonal moves\n    let nDiagonal = Math.min(nx, ny),\n        nStraight = Math.abs(ny - nx);\n        \n    // Diagonals in PF pretty much count as 1.5 times a straight\n    let distance = Math.floor(nDiagonal * 1.5 + nStraight);\n    let distanceOnGrid = distance * canvas.dimensions.distance;\n    return distanceOnGrid;\n  };\n\n\n  let originOffset = {x: 0, y: 0};\n  // Offset measurement for cones\n  // Offset is to ensure that cones only start measuring from cell borders, as in https://www.d20pfsrd.com/magic/#Aiming_a_Spell\n  if (this.data.t === "cone") {\n    // Degrees anticlockwise from pointing right. In 45-degree increments from 0 to 360\n    const dir = (this.data.direction >= 0 ? 360 - this.data.direction : -this.data.direction) % 360;\n    // If we\'re not on a border for X, offset by 0.5 or -0.5 to the border of the cell in the direction we\'re looking on X axis\n    let xOffset = this.data.x % d.size != 0 ?\n      Math.sign(1 * (Math.round(Math.cos(Object(_lib_js__WEBPACK_IMPORTED_MODULE_0__["degtorad"])(dir)) * 100)) / 100) /2 // /2 turns from 1/0/-1 to 0.5/0/-0.5\n      : 0;\n    // Same for Y, but cos Y goes down on screens, we invert\n    let yOffset = this.data.y % d.size != 0 ?\n      -Math.sign(1 * (Math.round(Math.sin(Object(_lib_js__WEBPACK_IMPORTED_MODULE_0__["degtorad"])(dir)) * 100)) / 100) /2\n      : 0;\n    originOffset.x = xOffset;\n    originOffset.y = yOffset;\n  }\n\n  // Point we are measuring distances from\n  let origin = {\n    x: this.data.x + (originOffset.x * d.size),\n    y: this.data.y + (originOffset.y * d.size)\n  }\n\n  for (let a = -nc; a < nc; a++) {\n    for (let b = -nr; b < nr; b++) {\n      // Position of cell\'s top-left corner, in pixels\n      let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(col0 + a, row0 + b);\n      // Position of cell\'s center, in pixels\n      let [cellCenterX, cellCenterY] = [gx + d.size * 0.5, gy + d.size * 0.5];\n\n      // Determine point of origin\n      let origin = {x: this.data.x, y: this.data.y};\n      origin.x += (originOffset.x * d.size);\n      origin.y += (originOffset.y * d.size);\n\n      let ray = new Ray(origin, {x: cellCenterX, y: cellCenterY});\n\n      let rayAngle = (360 + (ray.angle / (Math.PI / 180)) % 360) % 360;\n      if (this.data.t === "cone" && ray.distance > 0 && !within_angle(minAngle, maxAngle, rayAngle)) {\n        continue;\n      }\n\n      // Determine point we\'re measuring the distance to - always in the center of a grid square\n      let destination = {x: cellCenterX, y: cellCenterY};\n\n      let distance = measureDistance(destination, origin);\n      if (distance <= this.data.distance) {\n        grid.grid.highlightGridPosition(hl, { x: gx, y: gy, color: fc, border: bc });\n      }\n    }\n  }\n};\n\n\n//# sourceURL=webpack://pf1/./module/measure.js?')},"./module/migration.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrateWorld", function() { return migrateWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrateCompendium", function() { return migrateCompendium; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrateActorData", function() { return migrateActorData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrateItemData", function() { return migrateItemData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrateSceneData", function() { return migrateSceneData; });\n/* harmony import */ var _item_entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item/entity.js */ "./module/item/entity.js");\n/* harmony import */ var _config_experience_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config/experience.js */ "./module/config/experience.js");\n\r\n\r\n\r\n/**\r\n * Perform a system migration for the entire World, applying migrations for Actors, Items, and Compendium packs\r\n * @return {Promise}      A Promise which resolves once the migration is completed\r\n */\r\nconst migrateWorld = async function() {\r\n  if (!game.user.isGM) return ui.notifications.error(game.i18n.localize("PF1.ErrorUnauthorizedAction"));\r\n  ui.notifications.info(`Applying PF1 System Migration for version ${game.system.data.version}. Please stand by.`);\r\n\r\n  await _migrateWorldSettings();\r\n\r\n  // Migrate World Actors\r\n  for ( let a of game.actors.entities ) {\r\n    try {\r\n      const updateData = await migrateActorData(a);\r\n      console.log(`Migrating Actor entity ${a.name}`);\r\n      await a.update(updateData);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n  }\r\n\r\n  // Migrate World Items\r\n  for ( let i of game.items.entities ) {\r\n    try {\r\n      const updateData = migrateItemData(i);\r\n      console.log(`Migrating Item entity ${i.name}`);\r\n      await i.update(updateData, {enforceTypes: false});\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n  }\r\n\r\n  // Migrate Actor Override Tokens\r\n  for ( let s of game.scenes.entities ) {\r\n    try {\r\n      const updateData = await migrateSceneData(s.data);\r\n      console.log(`Migrating Scene entity ${s.name}`);\r\n      await s.update(updateData);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n  }\r\n\r\n  // Migrate World Compendium Packs\r\n  const packs = game.packs.filter(p => {\r\n    return (p.metadata.package === "world") && ["Actor", "Item", "Scene"].includes(p.metadata.entity)\r\n  });\r\n  for ( let p of packs ) {\r\n    await migrateCompendium(p);\r\n  }\r\n\r\n  // Set the migration as complete\r\n  game.settings.set("pf1", "systemMigrationVersion", game.system.data.version);\r\n  ui.notifications.info(`PF1 System Migration to version ${game.system.data.version} succeeded!`);\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Apply migration rules to all Entities within a single Compendium pack\r\n * @param pack\r\n * @return {Promise}\r\n */\r\nconst migrateCompendium = async function(pack) {\r\n  const entity = pack.metadata.entity;\r\n  if ( !["Actor", "Item", "Scene"].includes(entity) ) return;\r\n\r\n  // Begin by requesting server-side data model migration and get the migrated content\r\n  await pack.migrate();\r\n  const content = await pack.getContent();\r\n\r\n  // Iterate over compendium entries - applying fine-tuned migration functions\r\n  for ( let ent of content ) {\r\n    try {\r\n      let updateData = null;\r\n      if (entity === "Item") updateData = migrateItemData(ent);\r\n      else if (entity === "Actor") updateData = await migrateActorData(ent);\r\n      else if ( entity === "Scene" ) updateData = await migrateSceneData(ent);\r\n      expandObject(updateData);\r\n      updateData["_id"] = ent._id;\r\n      await pack.updateEntity(updateData);\r\n      console.log(`Migrated ${entity} entity ${ent.name} in Compendium ${pack.collection}`);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n  }\r\n  console.log(`Migrated all ${entity} entities from Compendium ${pack.collection}`);\r\n};\r\n\r\n/**\r\n * Migrates world settings.\r\n */\r\nconst _migrateWorldSettings = async function() {\r\n  const oldXPTrack = game.settings.get("pf1", "experienceRate");\r\n  if (oldXPTrack !== "" && oldXPTrack != null) {\r\n    // Set new config style\r\n    const config = game.settings.get("pf1", "experienceConfig") || _config_experience_js__WEBPACK_IMPORTED_MODULE_1__["ExperienceConfig"].defaultSettings;\r\n    config.track = oldXPTrack;\r\n    await game.settings.set("pf1", "experienceConfig", config);\r\n    // Remove old config style\r\n    await game.settings.set("pf1", "experienceRate", "");\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n/*  Entity Type Migration Helpers               */\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate a single Actor entity to incorporate latest data model changes\r\n * Return an Object of updateData to be applied\r\n * @param {Actor} actor   The actor to Update\r\n * @return {Object}       The updateData to apply\r\n */\r\nconst migrateActorData = async function(actor) {\r\n  const updateData = {};\r\n\r\n  _migrateCharacterLevel(actor, updateData);\r\n  _migrateActorEncumbrance(actor, updateData);\r\n  _migrateActorDefenseNotes(actor, updateData);\r\n  _migrateActorSpeed(actor, updateData);\r\n  _migrateSpellDivineFocus(actor, updateData);\r\n  _migrateActorSpellbookSlots(actor, updateData);\r\n  _migrateActorBaseStats(actor, updateData);\r\n  _migrateActorCreatureType(actor, updateData);\r\n  _migrateActorSpellbookDCFormula(actor, updateData);\r\n  _migrateActorHPAbility(actor, updateData);\r\n  _migrateActorCR(actor, updateData);\r\n\r\n  if ( !actor.items ) return updateData;\r\n\r\n  // Migrate Owned Items\r\n  let items = [];\r\n  const actorItems = Array.from(actor.items);\r\n  for (let a = 0; a < actorItems.length; a++) {\r\n    let i = actorItems[a];\r\n    items[a] = i;\r\n    let itemUpdate = migrateItemData(i);\r\n\r\n    // Update the Owned Item\r\n    items[a] = mergeObject(i, itemUpdate, { enforceTypes: false, inplace: false });\r\n  }\r\n  updateData.items = items;\r\n  return updateData;\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate a single Item entity to incorporate latest data model changes\r\n * @param item\r\n */\r\nconst migrateItemData = function(item) {\r\n  const updateData = {};\r\n  \r\n  _migrateItemSpellUses(item, updateData);\r\n  _migrateWeaponDamage(item, updateData);\r\n  _migrateWeaponImprovised(item, updateData);\r\n  _migrateSpellDescription(item, updateData);\r\n  _migrateClassDynamics(item, updateData);\r\n  _migrateClassType(item, updateData);\r\n  _migrateWeaponCategories(item, updateData);\r\n  _migrateEquipmentCategories(item, updateData);\r\n  _migrateWeaponSize(item, updateData);\r\n  _migrateAbilityTypes(item, updateData);\r\n  _migrateClassLevels(item, updateData);\r\n  _migrateSavingThrowTypes(item, updateData);\r\n  _migrateCR(item, updateData);\r\n  _migrateItemChanges(item, updateData);\r\n  _migrateTemplateSize(item, updateData);\r\n\r\n  // Return the migrated update data\r\n  return updateData;\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate a single Scene entity to incorporate changes to the data model of it\'s actor data overrides\r\n * Return an Object of updateData to be applied\r\n * @param {Object} scene  The Scene data to Update\r\n * @return {Object}       The updateData to apply\r\n */\r\nconst migrateSceneData = async function(scene) {\r\n  const result = { tokens: duplicate(scene.tokens) };\r\n  for (let t of result.tokens) {\r\n    if (!t.actorId || t.actorLink || !t.actorData.data) {\r\n      t.actorData = {};\r\n      continue;\r\n    }\r\n    const token = new Token(t);\r\n    if (!token.actor) {\r\n      t.actorId = null;\r\n      t.actordata = {};\r\n    }\r\n    const originalActor = game.actors.get(token.actor.id);\r\n    if (!originalActor) {\r\n      t.actorId = null;\r\n      t.actorData = {};\r\n    }\r\n    else {\r\n      const updateData = await migrateActorData(token.data.actorData);\r\n      t.actorData = mergeObject(token.data.actorData, updateData);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n/* -------------------------------------------- */\r\n/*  Low level migration utilities\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate string format traits with a comma separator to an array of strings\r\n * @private\r\n */\r\nconst _migrateActorTraits = function(actor, updateData) {\r\n  if ( !actor.data.traits ) return;\r\n  const dt = invertObject(CONFIG.pf1.damageTypes);\r\n  const map = {\r\n    "dr": dt,\r\n    "di": dt,\r\n    "dv": dt,\r\n    "ci": invertObject(CONFIG.pf1.conditionTypes),\r\n    "languages": invertObject(CONFIG.pf1.languages)\r\n  };\r\n  for ( let [t, choices] of Object.entries(map) ) {\r\n    const trait = actor.data.traits[t];\r\n    if ( trait && (typeof trait.value === "string") ) {\r\n      updateData[`data.traits.${t}.value`] = trait.value.split(",").map(t => choices[t.trim()]).filter(t => !!t);\r\n    }\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n\r\n/**\r\n * Flatten several attributes which currently have an unnecessarily nested {value} object\r\n * @private\r\n */\r\nconst _migrateFlattenValues = function(ent, updateData, toFlatten) {\r\n  for ( let a of toFlatten ) {\r\n    const attr = getProperty(ent.data, a);\r\n    if ( attr instanceof Object && !updateData.hasOwnProperty("data."+a) ) {\r\n      updateData["data."+a] = attr.hasOwnProperty("value") ? attr.value : null;\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateAddValues = function(ent, updateData, toAdd) {\r\n  for (let [k, v] of Object.entries(toAdd)) {\r\n    const attr = getProperty(ent.data, k);\r\n    if (!attr && !updateData.hasOwnProperty(k)) {\r\n      updateData[k] = v;\r\n    }\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nconst _migrateCharacterLevel = function(ent, updateData) {\r\n  const arr = ["details.level.value", "details.level.min", "details.level.max"];\r\n  for (let k of arr) {\r\n    const value = getProperty(ent.data.data, k);\r\n    if (value == null) {\r\n      updateData["data."+k] = 0;\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorEncumbrance = function(ent, updateData) {\r\n  const arr = ["attributes.encumbrance.level", "attributes.encumbrance.levels.light",\r\n  "attributes.encumbrance.levels.medium", "attributes.encumbrance.levels.heavy",\r\n  "attributes.encumbrance.levels.carry", "attributes.encumbrance.levels.drag",\r\n  "attributes.encumbrance.carriedWeight"];\r\n  for (let k of arr) {\r\n    const value = getProperty(ent.data.data, k);\r\n    if (value == null) {\r\n      updateData["data."+k] = 0\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorDefenseNotes = function(ent, updateData) {\r\n  const arr = ["attributes.acNotes", "attributes.cmdNotes", "attributes.srNotes"];\r\n  for (let k of arr) {\r\n    const value = getProperty(ent.data.data, k);\r\n    if (value == null) {\r\n      updateData["data."+k] = "";\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorSpeed = function(ent, updateData) {\r\n  const arr = ["attributes.speed.land", "attributes.speed.climb", "attributes.speed.swim", "attributes.speed.fly", "attributes.speed.burrow"];\r\n  for (let k of arr) {\r\n    let value = getProperty(ent.data.data, k);\r\n    if (typeof value === "string") value = parseInt(value);\r\n    if (typeof value === "number") {\r\n      updateData[`data.${k}.base`] = value;\r\n      updateData[`data.${k}.total`] = value;\r\n    }\r\n    else if (value == null) {\r\n      updateData[`data.${k}.base`] = 0;\r\n      updateData[`data.${k}.total`] = null;\r\n    }\r\n\r\n    // Add maneuverability\r\n    if (k === "attributes.speed.fly" && getProperty(ent.data.data, `${k}.maneuverability`) === undefined) {\r\n      updateData[`data.${k}.maneuverability`] = "average";\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorSpellbookSlots = function(ent, updateData) {\r\n  for (let spellbookSlot of Object.keys(getProperty(ent.data.data, "attributes.spells.spellbooks") || {})) {\r\n    if (getProperty(ent.data.data, `attributes.spells.spellbooks.${spellbookSlot}.autoSpellLevels`) == null) {\r\n      updateData[`data.attributes.spells.spellbooks.${spellbookSlot}.autoSpellLevels`] = true;\r\n    }\r\n\r\n    for (let a = 0; a < 10; a++) {\r\n      const baseKey = `data.attributes.spells.spellbooks.${spellbookSlot}.spells.spell${a}.base`;\r\n      const maxKey = `data.attributes.spells.spellbooks.${spellbookSlot}.spells.spell${a}.max`;\r\n      const base = getProperty(ent.data, baseKey);\r\n      const max = getProperty(ent.data, maxKey);\r\n      if (base === undefined && typeof max === "number" && max > 0) {\r\n        updateData[baseKey] = max.toString();\r\n      }\r\n      else if (base === undefined) {\r\n        updateData[baseKey] = "";\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorBaseStats = function(ent, updateData) {\r\n  const keys = ["attributes.hp.base", "attributes.hd.base", "attributes.savingThrows.fort.value",\r\n    "attributes.savingThrows.ref.value", "attributes.savingThrows.will.value"];\r\n  for (let k of keys) {\r\n    if (k === "attributes.hp.base" && !(getProperty(ent, "items") || []).filter(o => o.type === "class").length) continue;\r\n    if (getProperty(ent.data.data, k) != null) {\r\n      let kList = k.split(".");\r\n      kList[kList.length-1] = `-=${kList[kList.length-1]}`;\r\n      updateData[`data.${kList.join(".")}`] = null;\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateActorCreatureType = function(ent, updateData) {\r\n  if (getProperty(ent.data, "data.attributes.creatureType") == null) {\r\n    updateData["data.attributes.creatureType"] = "humanoid";\r\n  }\r\n};\r\n\r\nconst _migrateActorSpellbookDCFormula = function(ent, updateData) {\r\n  const spellbooks = Object.keys(getProperty(ent.data, "data.attributes.spells.spellbooks") || {});\r\n\r\n  for (let k of spellbooks) {\r\n    const key = `data.attributes.spells.spellbooks.${k}.baseDCFormula`;\r\n    const curFormula = getProperty(ent.data, key);\r\n    if (curFormula == null) updateData[key] = "10 + @sl + @ablMod";\r\n  }\r\n};\r\n\r\nconst _migrateActorHPAbility = function(ent, updateData) {\r\n  // Set HP ability\r\n  if (getProperty(ent.data, "data.attributes.hpAbility") === undefined) {\r\n    updateData["data.attributes.hpAbility"] = "con";\r\n  }\r\n\r\n  // Set Fortitude save ability\r\n  if (getProperty(ent.data, "data.attributes.savingThrows.fort.ability") === undefined) {\r\n    updateData["data.attributes.savingThrows.fort.ability"] = "con";\r\n  }\r\n\r\n  // Set Reflex save ability\r\n  if (getProperty(ent.data, "data.attributes.savingThrows.ref.ability") === undefined) {\r\n    updateData["data.attributes.savingThrows.ref.ability"] = "dex";\r\n  }\r\n\r\n  // Set Will save ability\r\n  if (getProperty(ent.data, "data.attributes.savingThrows.will.ability") === undefined) {\r\n    updateData["data.attributes.savingThrows.will.ability"] = "wis";\r\n  }\r\n};\r\n\r\nconst _migrateItemSpellUses = function(ent, updateData) {\r\n  if (getProperty(ent.data.data, "preparation") === undefined) return;\r\n\r\n  const value = getProperty(ent.data.data, "preparation.maxAmount");\r\n  if (typeof value !== "number") updateData["data.preparation.maxAmount"] = 0;\r\n};\r\n\r\nconst _migrateWeaponDamage = function(ent, updateData) {\r\n  if (ent.type !== "weapon") return;\r\n\r\n  const value = getProperty(ent.data.data, "weaponData");\r\n  if (typeof value !== "object") {\r\n    updateData["data.weaponData"] = {};\r\n    updateData["data.weaponData.critRange"] = 20;\r\n    updateData["data.weaponData.critMult"] = 2;\r\n  }\r\n};\r\n\r\nconst _migrateWeaponImprovised = function(ent, updateData) {\r\n  if (ent.type !== "weapon") return;\r\n\r\n  const value = getProperty(ent.data.data, "weaponType");\r\n  if (value === "improv") {\r\n    updateData["data.weaponType"] = "misc";\r\n    updateData["data.properties.imp"] = true;\r\n  }\r\n};\r\n\r\nconst _migrateSpellDescription = function(ent, updateData) {\r\n  if (ent.type !== "spell") return;\r\n\r\n  const curValue = getProperty(ent.data.data, "shortDescription");\r\n  if (curValue != null) return;\r\n\r\n  const obj = getProperty(ent.data.data, "description.value");\r\n  if (typeof obj !== "string") return;\r\n  const html = $(`<div>${obj}</div>`);\r\n  const elem = html.find("h2").next();\r\n  if (elem.length === 1) updateData["data.shortDescription"] = elem.prop("outerHTML");\r\n  else updateData["data.shortDescription"] = html.prop("innerHTML");\r\n};\r\n\r\nconst _migrateSpellDivineFocus = function(ent, updateData) {\r\n  if (ent.type !== "spell") return;\r\n\r\n  const value = getProperty(ent.data.data, "components.divineFocus");\r\n  if (typeof value === "boolean") updateData["data.components.divineFocus"] = (value === true ? 1 : 0);\r\n};\r\n\r\nconst _migrateClassDynamics = function(ent, updateData) {\r\n  if (ent.type !== "class") return;\r\n\r\n  const bab = getProperty(ent.data.data, "bab");\r\n  if (typeof bab === "number") updateData["data.bab"] = "low";\r\n\r\n  const stKeys = ["data.savingThrows.fort.value", "data.savingThrows.ref.value", "data.savingThrows.will.value"];\r\n  for (let key of stKeys) {\r\n    let value = getProperty(ent.data, key);\r\n    if (typeof value === "number") updateData[key] = "low";\r\n  }\r\n};\r\n\r\nconst _migrateClassType = function(ent, updateData) {\r\n  if (ent.type !== "class") return;\r\n\r\n  if (getProperty(ent.data.data, "classType") == null) updateData["data.classType"] = "base";\r\n};\r\n\r\nconst _migrateWeaponCategories = function(ent, updateData) {\r\n  if (ent.type !== "weapon") return;\r\n\r\n  // Change category\r\n  const type = getProperty(ent.data.data, "weaponType");\r\n  if (type === "misc") {\r\n    updateData["data.weaponType"] = "misc";\r\n    updateData["data.weaponSubtype"] = "other";\r\n  }\r\n  else if (type === "splash") {\r\n    updateData["data.weaponType"] = "misc";\r\n    updateData["data.weaponSubtype"] = "splash";\r\n  }\r\n\r\n  const changeProp = (["simple", "martial", "exotic"].includes(type));\r\n  if (changeProp && getProperty(ent.data.data, "weaponSubtype") == null) {\r\n    updateData["data.weaponSubtype"] = "1h";\r\n  }\r\n\r\n  // Change light property\r\n  const lgt = getProperty(ent.data.data, "properties.lgt");\r\n  if (lgt != null) {\r\n    updateData["data.properties.-=lgt"] = null;\r\n    if (lgt === true && changeProp) {\r\n      updateData["data.weaponSubtype"] = "light";\r\n    }\r\n  }\r\n\r\n  // Change two-handed property\r\n  const two = getProperty(ent.data.data, "properties.two");\r\n  if (two != null) {\r\n    updateData["data.properties.-=two"] = null;\r\n    if (two === true && changeProp) {\r\n      updateData["data.weaponSubtype"] = "2h";\r\n    }\r\n  }\r\n\r\n  // Change melee property\r\n  const melee = getProperty(ent.data.data, "weaponData.isMelee");\r\n  if (melee != null) {\r\n    updateData["data.weaponData.-=isMelee"] = null;\r\n    if (melee === false && changeProp) {\r\n      updateData["data.weaponSubtype"] = "ranged";\r\n    }\r\n  }\r\n};\r\n\r\nconst _migrateEquipmentCategories = function(ent, updateData) {\r\n  if (ent.type !== "equipment") return;\r\n\r\n  const oldType = getProperty(ent.data.data, "armor.type");\r\n  if (oldType == null) return;\r\n\r\n  if (oldType === "clothing") {\r\n    updateData["data.equipmentType"] = "misc";\r\n    updateData["data.equipmentSubtype"] = "clothing";\r\n  }\r\n  else if (oldType === "shield") {\r\n    updateData["data.equipmentType"] = "shield";\r\n    updateData["data.equipmentSubtype"] = "lightShield";\r\n    updateData["data.slot"] = "shield";\r\n  }\r\n  else if (oldType === "misc") {\r\n    updateData["data.equipmentType"] = "misc";\r\n    updateData["data.equipmentSubtype"] = "wondrous";\r\n  }\r\n  else if (["light", "medium", "heavy"].includes(oldType)) {\r\n    updateData["data.equipmentType"] = "armor";\r\n    updateData["data.equipmentSubtype"] = `${oldType}Armor`;\r\n  }\r\n\r\n  updateData["data.armor.-=type"] = null;\r\n};\r\n\r\nconst _migrateWeaponSize = function(ent, updateData) {\r\n  if (ent.type !== "weapon") return;\r\n  \r\n  if (!getProperty(ent.data, "data.weaponData.size")) {\r\n    updateData["data.weaponData.size"] = "med";\r\n  }\r\n};\r\n\r\nconst _migrateAbilityTypes = function(ent, updateData) {\r\n  if (ent.type !== "feat") return;\r\n\r\n  if (getProperty(ent.data, "data.abilityType") == null) {\r\n    updateData["data.abilityType"] = "none";\r\n  }\r\n  // Fix buggy value\r\n  if (getProperty(ent.data, "data.abilityType") === "n/a") {\r\n    updateData["data.abilityType"] = "none";\r\n  }\r\n};\r\n\r\nconst _migrateClassLevels = function(ent, updateData) {\r\n  const level = getProperty(ent.data, "data.levels");\r\n  if (typeof level === "number" && updateData["data.level"] == null) {\r\n    updateData["data.level"] = level;\r\n  }\r\n};\r\n\r\nconst _migrateSavingThrowTypes = function(ent, updateData) {\r\n  if (getProperty(ent.data, "data.save.type") == null && typeof getProperty(ent.data, "data.save.description") === "string") {\r\n    const desc = getProperty(ent.data, "data.save.description");\r\n    if (desc.match(/REF/i)) updateData["data.save.type"] = "ref";\r\n    else if (desc.match(/FORT/i)) updateData["data.save.type"] = "fort";\r\n    else if (desc.match(/WILL/i)) updateData["data.save.type"] = "will";\r\n  }\r\n};\r\n\r\nconst _migrateCR = function(ent, updateData) {\r\n  // Migrate CR offset\r\n  const crOffset = getProperty(ent.data, "data.crOffset");\r\n  if (typeof crOffset === "number") {\r\n    updateData["data.crOffset"] = crOffset.toString();\r\n  }\r\n};\r\n\r\nconst _migrateItemChanges = function(ent, updateData) {\r\n  // Migrate changes\r\n  const changes = getProperty(ent.data, "data.changes");\r\n  if (changes != null && changes instanceof Array) {\r\n    let newChanges = [];\r\n    for (let c of changes) {\r\n      if (c instanceof Array) {\r\n        newChanges.push(mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_0__["ItemPF"].defaultChange, { formula: c[0], target: c[1], subTarget: c[2], modifier: c[3], value: c[4] }, {inplace: false}));\r\n      }\r\n      else {\r\n        newChanges.push(c);\r\n      }\r\n    }\r\n    updateData["data.changes"] = newChanges;\r\n  }\r\n\r\n  // Migrate context notes\r\n  const notes = getProperty(ent.data, "data.contextNotes");\r\n  if (notes != null && notes instanceof Array) {\r\n    let newNotes = [];\r\n    for (let n of notes) {\r\n      if (n instanceof Array) {\r\n        newNotes.push(mergeObject(_item_entity_js__WEBPACK_IMPORTED_MODULE_0__["ItemPF"].defaultChange, { text: n[0], target: n[1], subTarget: n[2] }, {inplace: false}));\r\n      }\r\n      else {\r\n        newNotes.push(n);\r\n      }\r\n    }\r\n    updateData["data.contextNotes"] = newNotes;\r\n  }\r\n};\r\n\r\nconst _migrateTemplateSize = function(ent, updateData) {\r\n  const measureSize = getProperty(ent.data, "data.measureTemplate.size");\r\n  if (typeof measureSize === "number") {\r\n    updateData["data.measureTemplate.size"] = measureSize.toString();\r\n  }\r\n};\r\n\r\nconst _migrateActorCR = function(ent, updateData) {\r\n  // Migrate base CR\r\n  const cr = getProperty(ent.data, "data.details.cr");\r\n  if (typeof cr === "number") {\r\n    updateData["data.details.cr.base"] = cr;\r\n    updateData["data.details.cr.total"] = cr;\r\n  }\r\n  else if (cr == null) {\r\n    updateData["data.details.cr.base"] = 1;\r\n    updateData["data.details.cr.total"] = 1;\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a string spell casting time like "1 Bonus Action" to separate fields for activation type and numeric cost\r\n * @private\r\n */\r\nconst _migrateCastTime = function(item, updateData) {\r\n  const value = getProperty(item.data, "time.value");\r\n  if ( !value ) return;\r\n  const ATS = invertObject(CONFIG.pf1.abilityActivationTypes);\r\n  let match = value.match(/([\\d]+\\s)?([\\w\\s]+)/);\r\n  if ( !match ) return;\r\n  let type = ATS[match[2]] || "none";\r\n  let cost = match[1] ? Number(match[1]) : 0;\r\n  if ( type === "none" ) cost = 0;\r\n  updateData["data.activation"] = {type, cost};\r\n};\r\n\r\n/* -------------------------------------------- */\r\n/*  General Migrations                          */\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a string based damage formula like "2d6 + 4 + 1d4" and a single string damage type like "slash" to\r\n * separated damage parts with associated damage type per part.\r\n * @private\r\n */\r\nconst _migrateDamage = function(item, updateData) {\r\n\r\n  // Regular Damage\r\n  let damage = item.data.damage;\r\n  if ( damage && damage.value ) {\r\n    let type = item.data.damageType ? item.data.damageType.value : "";\r\n    const parts = damage.value.split("+").map(s => s.trim()).map(p => [p, type || null]);\r\n    if ( item.type === "weapon" && parts.length ) parts[0][0] += " + @mod";\r\n    updateData["data.damage.parts"] = parts;\r\n    updateData["data.damage.-=value"] = null;\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a string duration field like "1 Minute" to separate fields for duration units and numeric value\r\n * @private\r\n */\r\nconst _migrateDuration = function(item, updateData) {\r\n  const TIME = invertObject(CONFIG.pf1.timePeriods);\r\n  const dur = item.data.duration;\r\n  if ( dur && dur.value && !dur.units ) {\r\n    let match = dur.value.match(/([\\d]+\\s)?([\\w\\s]+)/);\r\n    if ( !match ) return;\r\n    let units = TIME[match[2]] || "inst";\r\n    let value = units === "inst" ? "" : Number(match[1]) || "";\r\n    updateData["data.duration"] = {units, value};\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a string range field like "150 ft." to separate fields for units and numeric distance value\r\n * @private\r\n */\r\nconst _migrateRange = function(item, updateData) {\r\n  if ( updateData["data.range"] ) return;\r\n  const range = item.data.range;\r\n  if ( range && range.value && !range.units ) {\r\n    let match = range.value.match(/([\\d\\/]+)?(?:[\\s]+)?([\\w\\s]+)?/);\r\n    if ( !match ) return;\r\n    let units = "none";\r\n    if ( /ft/i.test(match[2]) ) units = "ft";\r\n    else if ( /mi/i.test(match[2]) ) units = "mi";\r\n    else if ( /touch/i.test(match[2]) ) units = "touch";\r\n    updateData["data.range.units"] = units;\r\n\r\n    // Range value\r\n    if ( match[1] ) {\r\n      let value = match[1].split("/").map(Number);\r\n      updateData["data.range.value"] = value[0];\r\n      if ( value[1] ) updateData["data.range.long"] = value[1];\r\n    }\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\nconst _migrateRarity = function(item, updateData) {\r\n  const rar = item.data.rarity;\r\n  if ( (rar instanceof Object) && !rar.value ) updateData["data.rarity"] = "Common";\r\n  else if ( (typeof rar === "string") && (rar === "") ) updateData["data.rarity"] = "Common";\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n\r\n/**\r\n * A general migration to remove all fields from the data model which are flagged with a _deprecated tag\r\n * @private\r\n */\r\nconst _migrateRemoveDeprecated = function(ent, updateData, toFlatten) {\r\n  const flat = flattenObject(ent.data);\r\n\r\n  // Deprecate entire objects\r\n  const toDeprecate = Object.entries(flat).filter(e => e[0].endsWith("_deprecated") && (e[1] === true)).map(e => {\r\n    let parent = e[0].split(".");\r\n    parent.pop();\r\n    return parent.join(".");\r\n  });\r\n  for ( let k of toDeprecate ) {\r\n    let parts = k.split(".");\r\n    parts[parts.length-1] = "-=" + parts[parts.length-1];\r\n    updateData[`data.${parts.join(".")}`] = null;\r\n  }\r\n\r\n  // Deprecate types and labels\r\n  for ( let [k, v] of Object.entries(flat) ) {\r\n    let parts = k.split(".");\r\n    parts.pop();\r\n\r\n    // Skip any fields which have already been touched by other migrations\r\n    if ( toDeprecate.some(f => k.startsWith(f) ) ) continue;\r\n    if ( toFlatten.some(f => k.startsWith(f)) ) continue;\r\n    if ( updateData.hasOwnProperty(`data.${k}`) ) continue;\r\n\r\n    // Remove the data type field\r\n    const dtypes = ["Number", "String", "Boolean", "Array", "Object"];\r\n    if ( k.endsWith("type") && dtypes.includes(v) ) {\r\n      updateData[`data.${k.replace(".type", ".-=type")}`] = null;\r\n    }\r\n\r\n    // Remove string label\r\n    else if ( k.endsWith("label") ) {\r\n      updateData[`data.${k.replace(".label", ".-=label")}`] = null;\r\n    }\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a target string like "15 ft. Radius" to a more explicit data model with a value, units, and type\r\n * @private\r\n */\r\nconst _migrateTarget = function(item, updateData) {\r\n  const target = item.data.target;\r\n  if ( target.value && !Number.isNumeric(target.value) ) {\r\n\r\n    // Target Type\r\n    let type = null;\r\n    for ( let t of Object.keys(CONFIG.pf1.targetTypes) ) {\r\n      let rgx = new RegExp(t, "i");\r\n      if ( rgx.test(target.value) ) {\r\n        type = t;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Target Units\r\n    let units = null;\r\n    if ( /ft/i.test(target.value) ) units = "ft";\r\n    else if ( /mi/i.test(target.value) ) units = "mi";\r\n    else if ( /touch/i.test(target.value) ) units = "touch";\r\n\r\n    // Target Value\r\n    let value = null;\r\n    let match = target.value.match(/([\\d]+)([\\w\\s]+)?/);\r\n    if ( match ) value = Number(match[1]);\r\n    else if ( /one/i.test(target.value) ) value = 1;\r\n    updateData["data.target"] = {type, units, value};\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from string based components like "V,S,M" to boolean flags for each component\r\n * Move concentration and ritual flags into the components object\r\n * @private\r\n */\r\nconst _migrateSpellComponents = function(item, updateData) {\r\n  const components = item.data.components;\r\n  if ( !components.value ) return;\r\n  let comps = components.value.toUpperCase().replace(/\\s/g, "").split(",");\r\n  updateData["data.components"] = {\r\n    value: "",\r\n    verbal: comps.includes("V"),\r\n    somatic: comps.includes("M"),\r\n    material: comps.includes("S"),\r\n    concentration: item.data.concentration.value === true,\r\n    ritual: item.data.ritual.value === true\r\n  };\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a simple object with save.value to an expanded object where the DC is also configured\r\n * @private\r\n */\r\nconst _migrateSpellAction = function(item, updateData) {\r\n\r\n  // Set default action type for spells\r\n  if ( item.data.spellType ) {\r\n    updateData["data.actionType"] = {\r\n      "attack": "rsak",\r\n      "save": "save",\r\n      "heal": "heal",\r\n      "utility": "util",\r\n    }[item.data.spellType.value] || "util";\r\n  }\r\n\r\n  // Spell saving throw\r\n  const save = item.data.save;\r\n  if ( !save.value ) return;\r\n  updateData["data.save"] = {\r\n    ability: save.value,\r\n    dc: null\r\n  };\r\n  updateData["data.save.-=value"] = null;\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate spell preparation data to the new preparation object\r\n * @private\r\n */\r\nconst _migrateSpellPreparation = function(item, updateData) {\r\n  const prep = item.data.preparation;\r\n  if ( prep && !prep.mode ) {\r\n    updateData["data.preparation.mode"] = "prepared";\r\n    updateData["data.preparation.prepared"] = item.data.prepared ? Boolean(item.data.prepared.value) : false;\r\n  }\r\n};\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Migrate from a string based weapon properties like "Heavy, Two-Handed" to an object of boolean flags\r\n * @private\r\n */\r\nconst _migrateWeaponProperties = function(item, updateData) {\r\n\r\n  // Set default activation mode for weapons\r\n  updateData["data.activation"] = {type: "action", cost: 1};\r\n\r\n  // Set default action type for weapons\r\n  updateData["data.actionType"] = {\r\n    "simpleM": "mwak",\r\n    "simpleR": "rwak",\r\n    "martialM": "mwak",\r\n    "martialR": "rwak",\r\n    "natural": "mwak",\r\n    "improv": "mwak",\r\n    "ammo": "rwak"\r\n  }[item.data.weaponType.value] || "mwak";\r\n\r\n  // Set default melee weapon range\r\n  if ( updateData["data.actionType"] === "mwak" ) {\r\n    updateData["data.range"] = {\r\n      value: updateData["data.properties.rch"] ? 10 : 5,\r\n      units: "ft"\r\n    }\r\n  }\r\n\r\n  // Map weapon property strings to boolean flags\r\n  const props = item.data.properties;\r\n  if ( props.value ) {\r\n    const labels = invertObject(CONFIG.pf1.weaponProperties);\r\n    for (let k of props.value.split(",").map(p => p.trim())) {\r\n      if (labels[k]) updateData[`data.properties.${labels[k]}`] = true;\r\n    }\r\n    updateData["data.properties.-=value"] = null;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://pf1/./module/migration.js?')},"./module/misc/chat-attack.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChatAttack", function() { return ChatAttack; });\nclass ChatAttack {\n  constructor(item, {label="", rollData={}, primaryAttack=true}={}) {\n    this._baseRollData = rollData;\n    this.primaryAttack = primaryAttack;\n    this.setItem(item);\n    this.label = label;\n\n    this.attack = {\n      flavor: "",\n      tooltip: "",\n      total: 0,\n      isCrit: false,\n      isFumble: false,\n      roll: null,\n    };\n    this.critConfirm = {\n      flavor: "",\n      tooltip: "",\n      total: 0,\n      isCrit: false,\n      isFumble: false,\n      roll: null,\n    };\n    this.hasAttack = false;\n    this.hasCritConfirm = false;\n\n    this.damage = {\n      flavor: "",\n      tooltip: "",\n      total: 0,\n      rolls: [],\n    };\n    this.critDamage = {\n      flavor : "",\n      tooltip: "",\n      total  : 0,\n      rolls: [],\n    };\n    this.hasDamage = false;\n\n    this.cards           = [];\n    this.attackNotes     = [];\n    this.effectNotes     = [];\n    this.attackNotesHTML = "";\n    this.effectNotesHTML = "";\n  }\n\n  get critRange() {\n    return getProperty(this.item, "data.data.ability.critRange") || 20;\n  }\n\n  /**\n   * Sets the attack\'s item reference.\n   * @param {ItemPF} item - The item to reference.\n   */\n  setItem(item) {\n    if (item == null) {\n      this.rollData = {};\n      this.item = null;\n      return;\n    }\n\n    this.item = item;\n    this.rollData = item.actor != null ? item.actor.getRollData() : {};\n    this.rollData.item = duplicate(this.item.data.data);\n    this.rollData = mergeObject(this.rollData, this._baseRollData);\n\n    this.setRollData();\n  }\n\n  /**\n   * Applies changes to the roll data.\n   */\n  setRollData() {\n    let data = this.rollData;\n    // Set critical hit multiplier\n    data.critMult = 1;\n    // Add critical confirmation bonus\n    data.critConfirmBonus = data.item.critConfirmBonus;\n    // Determine ability multiplier\n    if (data.item.ability.damageMult != null) data.ablMult = data.item.ability.damageMult;\n    // Lower ability multiplier for secondary attacks\n    if (this.primaryAttack === false && getProperty(data.ablMult > 0)) {\n      data.ablMult = 0.5;\n    }\n    // Set spell data\n    if (this.item.type === "spell") {\n      const spellbook = this.item.spellbook;\n      data.cl = spellbook.cl.total + (this.item.data.data.clOffset || 0);\n    }\n  }\n\n  setAttackNotesHTML() {\n    if (this.attackNotes.length === 0) {\n      this.attackNotesHTML = "";\n      return;\n    }\n\n    let result = "";\n    for (let n of this.attackNotes) {\n      if (n.length > 0) {\n        result += `<span class="tag">${n}</span>`;\n      }\n    }\n    const inner = TextEditor.enrichHTML(result, { rollData: this.rollData });\n    this.attackNotesHTML =  `<div class="flexcol property-group gm-sensitive"><label>${game.i18n.localize("PF1.AttackNotes")}</label><div class="flexrow">${inner}</div></div>`;\n  }\n\n  setEffectNotesHTML() {\n    if (this.effectNotes.length === 0) {\n      this.effectNotesHTML = "";\n      return;\n    }\n\n    let result = "";\n    for (let n of this.effectNotes) {\n      if (n.length > 0) {\n        result += `<span class="tag">${n}</span>`;\n      }\n    }\n    const inner = TextEditor.enrichHTML(result, { rollData: this.rollData });\n    this.effectNotesHTML = `<div class="flexcol property-group gm-sensitive"><label>${game.i18n.localize("PF1.EffectNotes")}</label><div class="flexrow">${inner}</div></div>`;\n  }\n\n  async addAttack({bonus=null, extraParts=[], critical=false}={}) {\n    if (!this.item) return;\n\n    this.hasAttack = true;\n    let data = this.attack;\n    if (critical === true) {\n      data = this.critConfirm;\n      extraParts.push("@critConfirmBonus");\n    }\n\n    // Roll attack\n    let roll = this.item.rollAttack({data: this.rollData, bonus: bonus, extraParts: extraParts, primaryAttack: this.primaryAttack });\n    data.roll = roll;\n    let d20 = roll.parts[0];\n    let critType = 0;\n    if ((d20.total >= this.critRange && !critical) || (d20.total === 20 && critical)) critType = 1;\n    else if (d20.total === 1) critType = 2;\n\n    // Add tooltip\n    let tooltip   = $(await roll.getTooltip()).prepend(`<div class="dice-formula">${roll.formula}</div>`)[0].outerHTML;\n    data.flavor   = critical ? game.i18n.localize("PF1.CriticalConfirmation") : this.label;\n    data.tooltip  = tooltip;\n    data.total    = roll.total;\n    data.isCrit   = critType === 1;\n    data.isFumble = critType === 2;\n\n    // Add crit confirm\n    if (!critical && d20.total >= this.critRange) {\n      this.hasCritConfirm    = true;\n      this.rollData.critMult = this.rollData.item.ability.critMult;\n\n      await this.addAttack({bonus: bonus, extraParts: extraParts, critical: true});\n    }\n\n    if (this.attackNotes === "") this.addAttackNotes();\n  }\n\n  addAttackNotes() {\n    if (!this.item) return;\n\n    let notes = [];\n    if (this.item != null && this.item.actor != null) {\n      notes = this.item.actor.getContextNotes("attacks.attack").reduce((arr, o) => {\n        for (let n of o.notes) {\n          arr.push(...n.split(/[\\n\\r]+/));\n        }\n        return arr;\n      }, []);\n    }\n    if (this.item != null && this.item.data.data.attackNotes) {\n      notes.push(...this.item.data.data.attackNotes.split(/[\\n\\r]+/));\n    }\n\n    this.attackNotes = notes;\n    this.setAttackNotesHTML();\n  }\n\n  async addDamage({extraParts=[], critical=false}={}) {\n    if (!this.item) return;\n\n    this.hasDamage = true;\n    let data = this.damage;\n    if (critical === true) data = this.critDamage;\n\n    let rollData = duplicate(this.rollData);\n    // Enforce critical multiplier\n    if (!critical) rollData.critMult = 1;\n    \n    const rolls = this.item.rollDamage({data: rollData, extraParts: extraParts, primaryAttack: this.primaryAttack, critical: critical});\n    data.rolls = rolls;\n    // Add tooltip\n    let tooltips = "";\n    let totalDamage = 0;\n    for (let roll of rolls) {\n      let tooltip = $(await roll.roll.getTooltip()).prepend(`<div class="dice-formula">${roll.roll.formula}</div>`)[0].outerHTML;\n      // Alter tooltip\n      let tooltipHtml = $(tooltip);\n      totalDamage += roll.roll.total;\n      let totalText = roll.roll.total.toString();\n      if (roll.damageType.length) totalText += ` (${roll.damageType})`;\n      tooltipHtml.find(".part-total").text(totalText);\n      tooltip = tooltipHtml[0].outerHTML;\n      \n      tooltips += tooltip;\n    }\n    // Add normal data\n    let flavor;\n    if (!critical) flavor = this.item.isHealing ? game.i18n.localize("PF1.Healing")         : game.i18n.localize("PF1.Damage");\n    else           flavor = this.item.isHealing ? game.i18n.localize("PF1.HealingCritical") : game.i18n.localize("PF1.DamageCritical");\n    let damageTypes = this.item.data.data.damage.parts.reduce((cur, o) => {\n      if (o[1] !== "" && cur.indexOf(o[1]) === -1) cur.push(o[1]);\n      return cur;\n    }, []);\n    // Add critical damage parts\n    if (critical === true && getProperty(this.item.data, "data.damage.critParts") != null) {\n      damageTypes.push(this.item.data.data.damage.critParts.reduce((cur, o) => {\n        if (o[1] !== "" && cur.indexOf(o[1]) === -1) cur.push(o[1]);\n        return cur;\n      }, []));\n    }\n\n    // Add card\n    if (critical) {\n      if (this.item.isHealing) this.cards.push({ label: game.i18n.localize("PF1.ApplyCriticalHealing"), value: -totalDamage, action: "applyDamage", });\n      else                     this.cards.push({ label: game.i18n.localize("PF1.ApplyCriticalDamage") , value:  totalDamage, action: "applyDamage", });\n    }\n    else {\n      if (this.item.isHealing) this.cards.push({ label: game.i18n.localize("PF1.ApplyHealing"), value: -totalDamage, action: "applyDamage", });\n      else                     this.cards.push({ label: game.i18n.localize("PF1.ApplyDamage") , value:  totalDamage, action: "applyDamage", });\n    }\n\n    data.flavor = damageTypes.length > 0 ? `${flavor} (${damageTypes.join(", ")})` : flavor;\n    data.tooltip = tooltips;\n    data.total = rolls.reduce((cur, roll) => {\n      return cur + roll.roll.total;\n    }, 0);\n  }\n\n  addEffectNotes() {\n    if (!this.item) return;\n\n    let notes = [];\n    if (this.item != null && this.item.actor != null) {\n      notes = this.item.actor.getContextNotes("attacks.effect").reduce((arr, o) => {\n        for (let n of o.notes) {\n          arr.push(...n.split(/[\\n\\r]+/));\n        }\n        return arr;\n      }, []);\n    }\n    if (this.item != null && this.item.data.data.effectNotes) {\n      notes.push(...this.item.data.data.effectNotes.split(/[\\n\\r]+/));\n    }\n\n    this.effectNotes = notes;\n    this.setEffectNotesHTML();\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/misc/chat-attack.js?')},"./module/misc/links.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkFunctions", function() { return LinkFunctions; });\nconst LinkFunctions = {\n  "charges": function(item, links) {\n    for (let l of links) {\n      const otherItem = this.items.find(o => o._id === l.id);\n      if (!otherItem) continue;\n\n      otherItem.links.charges = item;\n      otherItem.prepareLinks();\n    }\n  },\n};\n\n\n//# sourceURL=webpack://pf1/./module/misc/links.js?')},"./module/misc/list-tabs.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListTabs", function() { return ListTabs; });\nclass ListTabs {\n  constructor({navSelector, contentSelector, initial, callback}={}) {\n    this.active = initial;\n    this.callback = callback;\n    this._navSelector = navSelector;\n    this._nav = null;\n    this._list = null;\n    this._contentSelector = contentSelector;\n    this._content = null;\n  }\n\n  bind(html) {\n\n    // Identify navigation element\n    this._nav = html.querySelector(this._navSelector);\n    if (!this._nav) return;\n    this._list = this._nav.querySelector("select.tabs");\n    if (!this._list) return;\n\n    // Set first active tab\n    if (!this._list.querySelector("option.active")) {\n      const option = this._list.options[0];\n      option.classList.toggle("active", true);\n      this.active = option.dataset.tab;\n    }\n\n    // Identify content container\n    if (!this._contentSelector) this._content = null;\n    else if (html.matches(this._contentSelector)) this._content = html;\n    else this._content = html.querySelector(this._contentSelector);\n\n    // Initialize the active tab\n    this.activate(this.active);\n\n    // Register event\n    this._list.addEventListener("change", this._onClickNav.bind(this));\n  }\n\n  activate(tabName, {triggerCallback=false}={}) {\n\n    // Validate the requested tab name\n    const items = this._nav.querySelectorAll("select.tabs option");\n    if (!items.length) return;\n    const valid = Array.from(items).some(i => i.dataset.tab === tabName);\n    if (!valid) tabName = items[0].dataset.tab;\n\n    // Change active tab\n    for (let a of items) {\n      if (a.dataset.tab === tabName) {\n        this._list.value = a.value;\n      }\n    }\n\n    // Change active content\n    if (this._content) {\n      const tabs = this._content.querySelectorAll(".tab");\n      for (let t of tabs) {\n        t.classList.toggle("active", t.dataset.tab === tabName);\n      }\n    }\n\n    // Store the active tab\n    this.active = tabName;\n\n    // Optionally trigger the callback function\n    if (triggerCallback) this.callback(null, this, tabName);\n  }\n\n  _onClickNav(event) {\n    event.preventDefault();\n\n    const a = event.currentTarget;\n    const option = a.options[a.selectedIndex];\n    const tabName = option.dataset.tab;\n    if (tabName !== this.active) this.activate(tabName, {triggerCallback: true});\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/misc/list-tabs.js?')},"./module/patch-core.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PatchCore", function() { return PatchCore; });\n/* harmony import */ var _combat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combat.js */ "./module/combat.js");\n/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dice.js */ "./module/dice.js");\n/* harmony import */ var _low_light_vision_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./low-light-vision.js */ "./module/low-light-vision.js");\n/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./measure.js */ "./module/measure.js");\n\n\n\nconst FormApplication_close = FormApplication.prototype.close;\n\nfunction PatchCore() {\n  // Patch getTemplate to prevent unwanted indentation in things things like <textarea> elements.\n  async function PF1_getTemplate(path) {\n    if ( !_templateCache.hasOwnProperty(path) ) {\n      await new Promise(resolve => {\n        game.socket.emit(\'template\', path, resp => {\n          const compiled = Handlebars.compile(resp.html, { preventIndent: true });\n          Handlebars.registerPartial(path, compiled);\n          _templateCache[path] = compiled;\n          console.log(`Foundry VTT | Retrieved and compiled template ${path}`);\n          resolve(compiled);\n        });\n      });\n    } \n    return _templateCache[path];\n  }\n\n  // Patch TokenHUD.getData to show resource bars even if their value is 0\n  const TokenHUD_getData = TokenHUD.prototype.getData;\n  TokenHUD.prototype.getData = function() {\n    const data = TokenHUD_getData.call(this);\n    const bar1 = this.object.getBarAttribute("bar1");\n    const bar2 = this.object.getBarAttribute("bar2");\n    return mergeObject(data, {\n      displayBar1: bar1 != null && bar1.attribute != null && bar1.value != null,\n      displayBar2: bar2 != null && bar2.attribute != null && bar2.value != null\n    });\n  }\n\n  // Patch FormApplication\n  FormApplication.prototype.saveMCEContent = async function(updateData=null) {};\n\n  FormApplication.prototype.close = async function(options={}) {\n    await this.saveMCEContent();\n    return FormApplication_close.call(this, options);\n  };\n\n  // Patch Roll._replaceData\n  const Roll__replaceData = Roll.prototype._replaceData;\n  Roll.prototype._replaceData = function(formula) {\n    let result = Roll__replaceData.call(this, formula);\n    result = Object(_dice_js__WEBPACK_IMPORTED_MODULE_1__["_preProcessDiceFormula"])(result, this.data);\n    return result;\n  };\n\n  // Patch, patch, patch\n  Combat.prototype._getInitiativeFormula = _combat_js__WEBPACK_IMPORTED_MODULE_0__["_getInitiativeFormula"];\n  Combat.prototype.rollInitiative = _combat_js__WEBPACK_IMPORTED_MODULE_0__["_rollInitiative"];\n  window.getTemplate = PF1_getTemplate;\n}\n\n\n\n\n\n//# sourceURL=webpack://pf1/./module/patch-core.js?')},"./module/pixi/ability-template.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbilityTemplate", function() { return AbilityTemplate; });\n/**\r\n * A helper class for building MeasuredTemplates for 5e spells and abilities\r\n * @extends {MeasuredTemplate}\r\n */\r\nclass AbilityTemplate extends MeasuredTemplate {\r\n\r\n  /**\r\n   * A factory method to create an AbilityTemplate instance using provided data\r\n   * @param {string} type -             The type of template ("cone", "circle", "rect" or "ray")\r\n   * @param {number} distance -         The distance/size of the template\r\n   * @return {AbilityTemplate|null}     The template object, or null if the data does not produce a template\r\n   */\r\n  static fromData(options) {\r\n    let type = options.type;\r\n    let distance = options.distance;\r\n    if (!type) return null;\r\n    if (!distance) return null;\r\n    if (!["cone", "circle", "rect", "ray"].includes(type)) return null;\r\n\r\n    // Prepare template data\r\n    const templateData = {\r\n      t: type,\r\n      user: game.user._id,\r\n      distance: distance || 5,\r\n      direction: 0,\r\n      x: 0,\r\n      y: 0,\r\n      fillColor: options.color ? options.color : game.user.color,\r\n      texture: options.texture ? options.texture : null,\r\n      _id: randomID(16),\r\n    };\r\n\r\n    // Additional type-specific data\r\n    switch (type) {\r\n      case "cone":\r\n        if (game.settings.get("pf1", "measureStyle") === true) templateData.angle = 90;\r\n        else templateData.angle = 53.13;\r\n        break;\r\n      case "rect":\r\n        templateData.distance = distance || 5;\r\n        // templateData.width = target.value;\r\n        templateData.direction = 45;\r\n        break;\r\n      case "ray":\r\n        templateData.width = 5;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // Return the template constructed from the item data\r\n    return new this(templateData);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Creates a preview of the spell template\r\n   * @param {Event} event   The initiating click event\r\n   */\r\n  async drawPreview(event) {\r\n    const initialLayer = canvas.activeLayer;\r\n    this.draw();\r\n    this.active = true;\r\n    this.layer.activate();\r\n    this.layer.preview.addChild(this);\r\n    return this.activatePreviewListeners(initialLayer);\r\n  }\r\n\r\n  /* -------------------------------------------- */\r\n\r\n  /**\r\n   * Activate listeners for the template preview\r\n   * @param {CanvasLayer} initialLayer  The initially active CanvasLayer to re-activate after the workflow is complete\r\n   * @returns {Promise<boolean>} Returns true if placed, or false if cancelled\r\n   */\r\n  activatePreviewListeners(initialLayer) {\r\n    return new Promise(resolve => {\r\n      const handlers = {};\r\n      let moveTime = 0;\r\n\r\n      const pfStyle = game.settings.get("pf1", "measureStyle") === true;\r\n\r\n      // Update placement (mouse-move)\r\n      handlers.mm = event => {\r\n        event.stopPropagation();\r\n        let now = Date.now(); // Apply a 20ms throttle\r\n        if ( now - moveTime <= 20 ) return;\r\n        const center = event.data.getLocalPosition(this.layer);\r\n        let pos = canvas.grid.getSnappedPosition(center.x, center.y, 2);\r\n        this.data.x = pos.x;\r\n        this.data.y = pos.y;\r\n        this.refresh();\r\n        canvas.app.render();\r\n        moveTime = now;\r\n      };\r\n\r\n      // Cancel the workflow (right-click)\r\n      handlers.rc = (event, canResolve=true) => {\r\n        this.layer.preview.removeChildren();\r\n        canvas.stage.off("mousemove", handlers.mm);\r\n        canvas.stage.off("mousedown", handlers.lc);\r\n        canvas.app.view.oncontextmenu = null;\r\n        canvas.app.view.onwheel = null;\r\n        // Clear highlight\r\n        this.active = false;\r\n        const hl = canvas.grid.getHighlightLayer(`Template.${this.id}`);\r\n        hl.clear();\r\n\r\n        initialLayer.activate();\r\n        if (canResolve) resolve(false);\r\n      };\r\n\r\n      // Confirm the workflow (left-click)\r\n      handlers.lc = event => {\r\n        handlers.rc(event, false);\r\n\r\n        // Confirm final snapped position\r\n        const destination = canvas.grid.getSnappedPosition(this.x, this.y, 2);\r\n        this.data.x = destination.x;\r\n        this.data.y = destination.y;\r\n\r\n        // Create the template\r\n        canvas.scene.createEmbeddedEntity("MeasuredTemplate", this.data);\r\n        resolve(true);\r\n      };\r\n\r\n      // Rotate the template by 3 degree increments (mouse-wheel)\r\n      handlers.mw = event => {\r\n        if (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window\r\n        event.stopPropagation();\r\n        let delta, snap;\r\n        if (event.ctrlKey) {\r\n          if (this.data.t === "rect") {\r\n            delta = Math.sqrt(canvas.dimensions.distance*canvas.dimensions.distance);\r\n          }\r\n          else {\r\n            delta = canvas.dimensions.distance;\r\n          }\r\n          this.data.distance += (delta * -Math.sign(event.deltaY));\r\n        }\r\n        else {\r\n          if (pfStyle && this.data.t === "cone") {\r\n            delta = 90;\r\n            snap = event.shiftKey ? delta : 45;\r\n          }\r\n          else {\r\n            delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;\r\n            snap = event.shiftKey ? delta : 5;\r\n          }\r\n          this.data.direction += (snap * Math.sign(event.deltaY));\r\n        }\r\n        this.refresh();\r\n      };\r\n\r\n      // Activate listeners\r\n      if (this.controlIcon) this.controlIcon.removeAllListeners();\r\n      canvas.stage.on("mousemove", handlers.mm);\r\n      canvas.stage.on("mousedown", handlers.lc);\r\n      canvas.app.view.oncontextmenu = handlers.rc;\r\n      canvas.app.view.onwheel = handlers.mw;\r\n      console.log(this);\r\n      this.hitArea = new PIXI.Polygon([]);\r\n    });\r\n  }\r\n\r\n  refresh() {\r\n    if (!this.template) return;\r\n\r\n    super.refresh();\r\n\r\n    if (this.active) {\r\n      this.highlightGrid();\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/pixi/ability-template.js?')},"./module/settings.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerSystemSettings", function() { return registerSystemSettings; });\n/* harmony import */ var _config_health_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config/health.js */ "./module/config/health.js");\n/* harmony import */ var _config_experience_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config/experience.js */ "./module/config/experience.js");\n\r\n\r\n\r\nconst registerSystemSettings = function() {\r\n  /**\r\n   * Track the system version upon which point a migration was last applied\r\n   */\r\n  game.settings.register("pf1", "systemMigrationVersion", {\r\n    name: "System Migration Version",\r\n    scope: "world",\r\n    config: false,\r\n    type: Number,\r\n    default: 0\r\n  });\r\n\r\n  // Health configuration\r\n  game.settings.registerMenu("pf1",\r\n    "healthConfig", {\r\n      name: "SETTINGS.pf1HealthConfigName",\r\n      label: "SETTINGS.pf1HealthConfigLabel",\r\n      hint: "SETTINGS.pf1HealthConfigHint",\r\n      icon: "fas fa-heartbeat",\r\n      type: _config_health_js__WEBPACK_IMPORTED_MODULE_0__["HealthConfig"],\r\n      restricted: true\r\n    }\r\n  );\r\n  game.settings.register("pf1", "healthConfig", {\r\n    name: "SETTINGS.pf1HealthConfigName",\r\n    scope: "world",\r\n    default: _config_health_js__WEBPACK_IMPORTED_MODULE_0__["HealthConfig"].defaultSettings,\r\n    type: Object,\r\n    config: false,\r\n    onChange: () => {\r\n      game.actors.entities.forEach(o => { o.update({}); });\r\n      Object.values(game.actors.tokens).forEach(o => { o.update({}); });\r\n    }\r\n  });\r\n\r\n  // Experience configuration\r\n  game.settings.registerMenu("pf1",\r\n    "experienceConfig", {\r\n      name: "PF1.ExperienceConfigName",\r\n      label: "PF1.ExperienceConfigLabel",\r\n      hint: "PF1.ExperienceConfigHint",\r\n      icon: "fas fa-book",\r\n      type: _config_experience_js__WEBPACK_IMPORTED_MODULE_1__["ExperienceConfig"],\r\n      restricted: true,\r\n    }\r\n  );\r\n  game.settings.register("pf1", "experienceConfig", {\r\n    name: "PF1.ExperienceConfigName",\r\n    scope: "world",\r\n    default: _config_experience_js__WEBPACK_IMPORTED_MODULE_1__["ExperienceConfig"].defaultSettings,\r\n    type: Object,\r\n    config: false,\r\n    onChange: () => {\r\n      game.actors.entities.forEach(o => { o.update({}); });\r\n      Object.values(game.actors.tokens).forEach(o => { o.update({}); });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Register diagonal movement rule setting\r\n   */\r\n  game.settings.register("pf1", "diagonalMovement", {\r\n    name: "SETTINGS.pf1DiagN",\r\n    hint: "SETTINGS.pf1DiagL",\r\n    scope: "world",\r\n    config: true,\r\n    default: "5105",\r\n    type: String,\r\n    choices: {\r\n      "555": "SETTINGS.pf1DiagPHB",\r\n      "5105": "SETTINGS.pf1DiagDMG"\r\n    },\r\n    onChange: rule => canvas.grid.diagonalRule = rule\r\n  });\r\n\r\n  /**\r\n   * Experience rate\r\n   * @deprecated\r\n   */\r\n  game.settings.register("pf1", "experienceRate", {\r\n    name: "SETTINGS.pf1ExpRateN",\r\n    hint: "SETTINGS.pf1ExpRateL",\r\n    scope: "world",\r\n    config: false,\r\n    default: "",\r\n    type: String,\r\n    onChange: () => {\r\n      [...game.actors.entities, ...Object.values(game.actors.tokens)].filter(o => {\r\n        return o.data.type === "character";\r\n      }).forEach(o => {\r\n        o.update({});\r\n        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();\r\n      });\r\n    },\r\n  });\r\n  \r\n  /**\r\n   * System of Units\r\n   */\r\n  game.settings.register("pf1", "units", {\r\n    name: "SETTINGS.pf1UnitsN",\r\n    hint: "SETTINGS.pf1UnitsL",\r\n    scope: "world",\r\n    config: true,\r\n    default: "imperial",\r\n    type: String,\r\n    choices: {\r\n      "imperial": "Imperial (feet, lbs)",\r\n      "metric": "Metric (meters, kg)"\r\n    },\r\n    onChange: () => {\r\n      [...game.actors.entities, ...Object.values(game.actors.tokens)].filter(o => {\r\n        return o.data.type === "character";\r\n      }).forEach(o => {\r\n        o.update({});\r\n        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();\r\n      });\r\n    },\r\n  });\r\n\r\n  /**\r\n   * Option to allow the background skills optional ruleset.\r\n   */\r\n  game.settings.register("pf1", "allowBackgroundSkills", {\r\n    name: "SETTINGS.pf1BackgroundSkillsN",\r\n    hint: "SETTINGS.pf1BackgroundSkillsH",\r\n    scope: "world",\r\n    config: true,\r\n    default: false,\r\n    type: Boolean,\r\n    onChange: () => {\r\n      game.actors.entities.forEach(o => { if (o.sheet && o.sheet.rendered) o.sheet.render(true); });\r\n      Object.values(game.actors.tokens).forEach(o => { if (o.sheet && o.sheet.rendered) o.sheet.render(true); });\r\n    },\r\n  });\r\n\r\n  /**\r\n   * Option to use the Fractional Base Bonuses optional ruleset.\r\n   */\r\n  game.settings.register("pf1", "useFractionalBaseBonuses", {\r\n    name: "SETTINGS.pf1FractionalBaseBonusesN",\r\n    hint: "SETTINGS.pf1FractionalBaseBonusesH",\r\n    scope: "world",\r\n    config: true,\r\n    default: false,\r\n    type: Boolean,\r\n    onChange: () => {\r\n      game.actors.entities.forEach(o => { o.update({}); });\r\n      Object.values(game.actors.tokens).forEach(o => { o.update({}); });\r\n    },\r\n  });\r\n\r\n  /**\r\n   * Option to automatically collapse Item Card descriptions\r\n   */\r\n  game.settings.register("pf1", "autoCollapseItemCards", {\r\n    name: "SETTINGS.pf1AutoCollapseCardN",\r\n    hint: "SETTINGS.pf1AutoCollapseCardL",\r\n    scope: "client",\r\n    config: true,\r\n    default: false,\r\n    type: Boolean,\r\n    onChange: () => {\r\n      ui.chat.render();\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Option to change measure style\r\n   */\r\n  game.settings.register("pf1", "measureStyle", {\r\n    name: "SETTINGS.pf1MeasureStyleN",\r\n    hint: "SETTINGS.pf1MeasureStyleL",\r\n    scope: "world",\r\n    config: true,\r\n    default: true,\r\n    type: Boolean,\r\n  });\r\n\r\n  /**\r\n   * Low-light Vision Mode\r\n   */\r\n  game.settings.register("pf1", "lowLightVisionMode", {\r\n    name: "SETTINGS.pf1LowLightVisionModeN",\r\n    hint: "SETTINGS.pf1LowLightVisionModeH",\r\n    scope: "world",\r\n    config: true,\r\n    default: false,\r\n    type: Boolean,\r\n  });\r\n\r\n  /**\r\n   * Preload Compendiums\r\n   */\r\n  game.settings.register("pf1", "preloadCompendiums", {\r\n    name: "SETTINGS.pf1PreloadCompendiumsN",\r\n    hint: "SETTINGS.pf1PreloadCompendiumsH",\r\n    scope: "client",\r\n    config: true,\r\n    default: false,\r\n    type: Boolean,\r\n  });\r\n};\r\n\n\n//# sourceURL=webpack://pf1/./module/settings.js?')},"./module/sidebar/chat-message.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChatMessagePF", function() { return ChatMessagePF; });\nclass ChatMessagePF extends ChatMessage {\n  async render() {\n\n    // Determine some metadata\n    const data = duplicate(this.data);\n    const isWhisper = this.data.whisper.length;\n    const isVisible = this.isContentVisible;\n\n    // Construct message data\n    const messageData = {\n      message: data,\n      user: game.user,\n      author: this.user,\n      alias: this.alias,\n      cssClass: [\n        this.data.type === CONST.CHAT_MESSAGE_TYPES.IC ? "ic" : null,\n        this.data.type === CONST.CHAT_MESSAGE_TYPES.EMOTE ? "emote" : null,\n        isWhisper ? "whisper" : null,\n        this.data.blind ? "blind": null\n      ].filter(c => c !== null).join(" "),\n      isWhisper: this.data.whisper.some(id => id !== game.user._id),\n      whisperTo: this.data.whisper.map(u => {\n        let user = game.users.get(u);\n        return user ? user.name : null;\n      }).filter(n => n !== null).join(", ")\n    };\n\n    // Enrich some data for dice rolls\n    if (this.isRoll && !this.getFlag("pf1", "noRollRender")) {\n\n      // Render HTML if needed\n      if ( data.content.slice(0, 1) !== "<" ) {\n        data.content = await this.roll.render({isPrivate: !isVisible});\n      }\n\n      // Conceal some private roll information\n      if ( !isVisible ) {\n        data.flavor = `${this.user.name} privately rolled some dice`;\n        messageData.isWhisper = false;\n        messageData.alias = this.user.name;\n      }\n    }\n\n    // Define a border color\n    if ( this.data.type === CONST.CHAT_MESSAGE_TYPES.OOC ) {\n      messageData.borderColor = this.user.color;\n    }\n\n    // Render the chat message\n    let html = await renderTemplate(CONFIG.ChatMessage.template, messageData);\n    html = $(html);\n\n    // Call a hook for the rendered ChatMessage data\n    Hooks.call("renderChatMessage", this, html, messageData);\n    return html;\n\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/sidebar/chat-message.js?')},"./module/sidebar/compendium.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompendiumDirectoryPF", function() { return CompendiumDirectoryPF; });\n/* harmony import */ var _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../apps/compendium-browser.js */ "./module/apps/compendium-browser.js");\n\r\n\r\nclass CompendiumDirectoryPF extends CompendiumDirectory {\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    this.compendiums = {\r\n      spells: new _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__["CompendiumBrowser"]({ type: "spells", entityType: "Item" }),\r\n      items: new _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__["CompendiumBrowser"]({ type: "items", entityType: "Item" }),\r\n      bestiary: new _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__["CompendiumBrowser"]({ type: "bestiary", entityType: "Actor" }),\r\n      feats: new _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__["CompendiumBrowser"]({ type: "feats", entityType: "Item" }),\r\n      classes: new _apps_compendium_browser_js__WEBPACK_IMPORTED_MODULE_0__["CompendiumBrowser"]({ type: "classes", entityType: "Item" }),\r\n    };\r\n  }\r\n\r\n  static get defaultOptions() {\r\n    return mergeObject(super.defaultOptions, {\r\n      template: "systems/pf1/templates/sidebar/compendium.html",\r\n    });\r\n  }\r\n\r\n  activateListeners(html) {\r\n    super.activateListeners(html);\r\n\r\n    html.find(".compendium-footer .compendium.spells").click(e => this._onBrowseCompendium(e, "spells"));\r\n    html.find(".compendium-footer .compendium.items").click(e => this._onBrowseCompendium(e, "items"));\r\n    html.find(".compendium-footer .compendium.bestiary").click(e => this._onBrowseCompendium(e, "bestiary"));\r\n    html.find(".compendium-footer .compendium.feats").click(e => this._onBrowseCompendium(e, "feats"));\r\n    html.find(".compendium-footer .compendium.classes").click(e => this._onBrowseCompendium(e, "classes"));\r\n  }\r\n\r\n  _onBrowseCompendium(event, type) {\r\n    event.preventDefault();\r\n\r\n    this.compendiums[type]._render(true);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://pf1/./module/sidebar/compendium.js?')},"./module/socket.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeSocket", function() { return initializeSocket; });\nfunction initializeSocket() {\n  game.socket.on("system.pf1", async (args) => {\n    switch (args.eventType) {\n      case "cleanItemLink":\n        // Get actor\n        const actor = await fromUuid(args.actorUUID);\n        // Get item\n        const parentItemData = await fromUuid(args.itemUUID);\n        const parentItem = actor.items.find(o => o._id === parentItemData._id);\n        // Get link data\n        const link = args.link;\n        const linkType = args.linkType;\n        // Clean item links\n        parentItem._cleanLink(link, linkType);\n        break;\n    }\n  });\n}\n\n\n//# sourceURL=webpack://pf1/./module/socket.js?')},"./module/templates.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preloadHandlebarsTemplates", function() { return preloadHandlebarsTemplates; });\n/**\n * Define a set of template paths to pre-load\n * Pre-loaded templates are compiled and cached for fast access when rendering\n * @return {Promise}\n */\nconst preloadHandlebarsTemplates = async function() {\n\n  // Define template paths to load\n  const templatePaths = [\n\n    // Actor Sheet Partials\n    "systems/pf1/templates/actors/parts/actor-traits.html",\n    "systems/pf1/templates/actors/parts/actor-inventory.html",\n    "systems/pf1/templates/actors/parts/actor-features.html",\n    "systems/pf1/templates/actors/parts/actor-spellbook-front.html",\n    "systems/pf1/templates/actors/parts/actor-spellbook.html",\n    "systems/pf1/templates/actors/parts/actor-skills-front.html",\n    "systems/pf1/templates/actors/parts/actor-skills.html",\n    "systems/pf1/templates/actors/parts/actor-defenses.html",\n    "systems/pf1/templates/actors/parts/actor-buffs.html",\n    "systems/pf1/templates/actors/parts/actor-attacks.html",\n\n    // Item Sheet Partials\n    "systems/pf1/templates/items/parts/item-action.html",\n    "systems/pf1/templates/items/parts/item-activation.html",\n    "systems/pf1/templates/items/parts/item-description.html",\n    "systems/pf1/templates/items/parts/item-changes.html",\n    "systems/pf1/templates/items/parts/item-notes.html",\n    "systems/pf1/templates/items/parts/item-template.html",\n    "systems/pf1/templates/items/parts/item-links.html",\n    "systems/pf1/templates/items/parts/links/item-template.html",\n\n    // Misc\n    "systems/pf1/templates/misc/token-config.html",\n\n    // Apps\n    "systems/pf1/templates/apps/attack-roll-dialog.html",\n    "systems/pf1/templates/apps/links.html",\n    "systems/pf1/templates/apps/link-options.html",\n\n    // Chat\n    "systems/pf1/templates/chat/roll-ext.html",\n    "systems/pf1/templates/chat/defenses.html",\n\n    // Internal Rendering Partials\n    "systems/pf1/templates/internal/spell-description.html",\n    "systems/pf1/templates/internal/consumable-description.html",\n  ];\n\n  // Load the template parts\n  return loadTemplates(templatePaths);\n};\n\n\n//# sourceURL=webpack://pf1/./module/templates.js?')},"./module/token-config.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenConfigPF", function() { return TokenConfigPF; });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ "./module/lib.js");\n\n\nclass TokenConfigPF extends TokenConfig {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.template = "systems/pf1/templates/scene/token-config.html";\n    options.height = 480;\n    return options;\n  }\n\n  async getData(...args) {\n    let result = await super.getData(...args);\n\n    result.actor = result.actor || {};\n    result.actor["vision"] = duplicate(getProperty(this.token.actor, "data.data.attributes.vision") || {});\n\n    result.version = result.version || {};\n    result.version.v052 = Object(_lib_js__WEBPACK_IMPORTED_MODULE_0__["isMinimumCoreVersion"])("0.5.2");\n\n    return result;\n  }\n\n  async _updateActorData(tokenData) {\n    const actorData = {};\n\n    actorData["data.attributes.vision.lowLight"] = tokenData.visionLL;\n    actorData["data.attributes.vision.darkvision"] = tokenData.darkvision;\n\n    if (Object.keys(actorData).length) await this.token.actor.update(actorData);\n    return super._updateActorData(tokenData);\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/token-config.js?')},"./module/token-quick-actions.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenQuickActions", function() { return TokenQuickActions; });\nclass TokenQuickActions {\n\n  static async addTop3Attacks(app, html, data) {\n\n    let actorId = data.actorId,\n      actor = game.actors.get(actorId);\n    if (data._id && game.actors.tokens[data._id] != null) {\n      actorId = data._id;\n      actor = game.actors.tokens[actorId];\n    }\n\n    if (actor == null)\n        return;\n    \n    let quickActions = \'<div class="col actions"><div class="below">\'\n    let items = actor.data.items.filter(o => (o.type === "attack" || o.type === "spell" || o.type === "feat") && getProperty(o, "data.showInQuickbar") === true).sort((a, b) => {\n      return a.data.sort - b.data.sort;\n    });\n    items.forEach(function(item) {\n      const icon = item.img;\n      let title = "";\n      if      (item.type === "attack") title = game.i18n.localize("PF1.AttackWith").format(item.name);\n      else if (item.type === "spell")  title = game.i18n.localize("PF1.AttackWithSpell").format(item.name);\n      else if (item.type === "feat")   title = game.i18n.localize("PF1.AttackWithFeat").format(item.name);\n      const type = item.type;\n      quickActions += `<div id="${type}-${item._id}" class="control-icon token-quick-action"><img src="${icon}" width="36" height="36" title="${title}"></div>`;\n    });\n    \n    html.find(\'.col.middle\').after(quickActions + \'</div></div>\');\n    \n    items.forEach(function(item) {\n      const type = item.type;\n      html.find(`#${type}-${item._id}`).click(function(event) {\n        game.pf1.rollItemMacro(item.name, {\n          itemId: item._id,\n          itemType: type,\n          actorId: actorId\n        });\n      });\n    });\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/token-quick-actions.js?')},"./module/widgets/item-picker.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Widget_ItemPicker", function() { return Widget_ItemPicker; });\nclass Widget_ItemPicker {\n  constructor(callback, {items, columns=3}={}) {\n    /**\n     * @property\n     * The HTML element that represents this widget.\n     */\n    this.element = null;\n\n    /**\n     * @property\n     * The callback to fire if an item is clicked.\n     */\n    this.callback = callback;\n\n    /**\n     * @typedef Widget_ItemPicker_Item\n     * @type {Object}\n     * @property {string} value\n     * @property {string} label\n     */\n    /**\n     * @property\n     * @type Widget_ItemPicker_Item[]\n     * The items in this widget.\n     */\n    this._items = items;\n\n    /**\n     * @property\n     * @type {number}\n     * The maximum amount of columns shown.\n     */\n    this.columns = columns;\n  }\n\n  render(parentElem) {\n    // Generate widget\n    const rootElem = $($.parseHTML(\'<div class="widget item-picker"></div>\'));\n    // Add rows\n    let rowElem;\n    for (let a = 0; a < this._items.length; a++) {\n      const item = this._items[a];\n      if (a % this.columns === 0) {\n        rowElem = $($.parseHTML(\'<div class="row"></div>\'));\n        rootElem.append(rowElem);\n      }\n\n      const itemElem = $($.parseHTML(`<div class="item" value="${item.value}">${item.label}</div>`));\n      const widthRate = Math.floor(10000 / this.columns) / 100;\n      itemElem.css("flex", `0 0 calc(${widthRate}% - 4px)`);\n      rowElem.append(itemElem);\n    }\n    \n    // Replace parent element\n    if (!(parentElem instanceof jQuery)) parentElem = $(parentElem);\n    rootElem.css("position", "absolute");\n    rootElem.css("left", `${parentElem[0].offsetLeft}px`);\n    rootElem.css("position", `${parentElem[0].offsetBottom}px`);\n    parentElem.parent().append(rootElem);\n\n    this.element = rootElem;\n\n    window.setTimeout(() => {\n      this.activateListeners(rootElem);\n    }, 10);\n  }\n\n  activateListeners(html) {\n    // Click item callback\n    html.find(".item").click(this._onClickItem.bind(this));\n\n    // Cancel widget\n    this._cancelCallback = this._onCancel.bind(this);\n    document.addEventListener("click", this._cancelCallback);\n  }\n\n  _onCancel(event) {\n    event.preventDefault();\n\n    // Don\'t cancel if this widget was clicked\n    const target = event.target;\n    let node = target;\n    if (node === this.element[0]) return;\n    while (node.parentNode) {\n      if (node === this.element[0]) return;\n      node = node.parentNode;\n    }\n\n    this.cancel();\n  }\n\n  _onClickItem(event) {\n    event.preventDefault();\n    const a = event.currentTarget;\n\n    this.callback($(a).attr("value"));\n  }\n\n  cancel() {\n    document.removeEventListener("click", this._cancelCallback);\n    this.element.remove();\n  }\n}\n\n\n//# sourceURL=webpack://pf1/./module/widgets/item-picker.js?')},"./node_modules/color-convert/conversions.js":function(module,exports,__webpack_require__){eval("/* MIT license */\nvar cssKeywords = __webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack://pf1/./node_modules/color-convert/conversions.js?")},"./node_modules/color-convert/index.js":function(module,exports,__webpack_require__){eval("var conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\nvar route = __webpack_require__(/*! ./route */ \"./node_modules/color-convert/route.js\");\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack://pf1/./node_modules/color-convert/index.js?")},"./node_modules/color-convert/route.js":function(module,exports,__webpack_require__){eval("var conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack://pf1/./node_modules/color-convert/route.js?")},"./node_modules/color-name/index.js":function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\nmodule.exports = {\r\n\t"aliceblue": [240, 248, 255],\r\n\t"antiquewhite": [250, 235, 215],\r\n\t"aqua": [0, 255, 255],\r\n\t"aquamarine": [127, 255, 212],\r\n\t"azure": [240, 255, 255],\r\n\t"beige": [245, 245, 220],\r\n\t"bisque": [255, 228, 196],\r\n\t"black": [0, 0, 0],\r\n\t"blanchedalmond": [255, 235, 205],\r\n\t"blue": [0, 0, 255],\r\n\t"blueviolet": [138, 43, 226],\r\n\t"brown": [165, 42, 42],\r\n\t"burlywood": [222, 184, 135],\r\n\t"cadetblue": [95, 158, 160],\r\n\t"chartreuse": [127, 255, 0],\r\n\t"chocolate": [210, 105, 30],\r\n\t"coral": [255, 127, 80],\r\n\t"cornflowerblue": [100, 149, 237],\r\n\t"cornsilk": [255, 248, 220],\r\n\t"crimson": [220, 20, 60],\r\n\t"cyan": [0, 255, 255],\r\n\t"darkblue": [0, 0, 139],\r\n\t"darkcyan": [0, 139, 139],\r\n\t"darkgoldenrod": [184, 134, 11],\r\n\t"darkgray": [169, 169, 169],\r\n\t"darkgreen": [0, 100, 0],\r\n\t"darkgrey": [169, 169, 169],\r\n\t"darkkhaki": [189, 183, 107],\r\n\t"darkmagenta": [139, 0, 139],\r\n\t"darkolivegreen": [85, 107, 47],\r\n\t"darkorange": [255, 140, 0],\r\n\t"darkorchid": [153, 50, 204],\r\n\t"darkred": [139, 0, 0],\r\n\t"darksalmon": [233, 150, 122],\r\n\t"darkseagreen": [143, 188, 143],\r\n\t"darkslateblue": [72, 61, 139],\r\n\t"darkslategray": [47, 79, 79],\r\n\t"darkslategrey": [47, 79, 79],\r\n\t"darkturquoise": [0, 206, 209],\r\n\t"darkviolet": [148, 0, 211],\r\n\t"deeppink": [255, 20, 147],\r\n\t"deepskyblue": [0, 191, 255],\r\n\t"dimgray": [105, 105, 105],\r\n\t"dimgrey": [105, 105, 105],\r\n\t"dodgerblue": [30, 144, 255],\r\n\t"firebrick": [178, 34, 34],\r\n\t"floralwhite": [255, 250, 240],\r\n\t"forestgreen": [34, 139, 34],\r\n\t"fuchsia": [255, 0, 255],\r\n\t"gainsboro": [220, 220, 220],\r\n\t"ghostwhite": [248, 248, 255],\r\n\t"gold": [255, 215, 0],\r\n\t"goldenrod": [218, 165, 32],\r\n\t"gray": [128, 128, 128],\r\n\t"green": [0, 128, 0],\r\n\t"greenyellow": [173, 255, 47],\r\n\t"grey": [128, 128, 128],\r\n\t"honeydew": [240, 255, 240],\r\n\t"hotpink": [255, 105, 180],\r\n\t"indianred": [205, 92, 92],\r\n\t"indigo": [75, 0, 130],\r\n\t"ivory": [255, 255, 240],\r\n\t"khaki": [240, 230, 140],\r\n\t"lavender": [230, 230, 250],\r\n\t"lavenderblush": [255, 240, 245],\r\n\t"lawngreen": [124, 252, 0],\r\n\t"lemonchiffon": [255, 250, 205],\r\n\t"lightblue": [173, 216, 230],\r\n\t"lightcoral": [240, 128, 128],\r\n\t"lightcyan": [224, 255, 255],\r\n\t"lightgoldenrodyellow": [250, 250, 210],\r\n\t"lightgray": [211, 211, 211],\r\n\t"lightgreen": [144, 238, 144],\r\n\t"lightgrey": [211, 211, 211],\r\n\t"lightpink": [255, 182, 193],\r\n\t"lightsalmon": [255, 160, 122],\r\n\t"lightseagreen": [32, 178, 170],\r\n\t"lightskyblue": [135, 206, 250],\r\n\t"lightslategray": [119, 136, 153],\r\n\t"lightslategrey": [119, 136, 153],\r\n\t"lightsteelblue": [176, 196, 222],\r\n\t"lightyellow": [255, 255, 224],\r\n\t"lime": [0, 255, 0],\r\n\t"limegreen": [50, 205, 50],\r\n\t"linen": [250, 240, 230],\r\n\t"magenta": [255, 0, 255],\r\n\t"maroon": [128, 0, 0],\r\n\t"mediumaquamarine": [102, 205, 170],\r\n\t"mediumblue": [0, 0, 205],\r\n\t"mediumorchid": [186, 85, 211],\r\n\t"mediumpurple": [147, 112, 219],\r\n\t"mediumseagreen": [60, 179, 113],\r\n\t"mediumslateblue": [123, 104, 238],\r\n\t"mediumspringgreen": [0, 250, 154],\r\n\t"mediumturquoise": [72, 209, 204],\r\n\t"mediumvioletred": [199, 21, 133],\r\n\t"midnightblue": [25, 25, 112],\r\n\t"mintcream": [245, 255, 250],\r\n\t"mistyrose": [255, 228, 225],\r\n\t"moccasin": [255, 228, 181],\r\n\t"navajowhite": [255, 222, 173],\r\n\t"navy": [0, 0, 128],\r\n\t"oldlace": [253, 245, 230],\r\n\t"olive": [128, 128, 0],\r\n\t"olivedrab": [107, 142, 35],\r\n\t"orange": [255, 165, 0],\r\n\t"orangered": [255, 69, 0],\r\n\t"orchid": [218, 112, 214],\r\n\t"palegoldenrod": [238, 232, 170],\r\n\t"palegreen": [152, 251, 152],\r\n\t"paleturquoise": [175, 238, 238],\r\n\t"palevioletred": [219, 112, 147],\r\n\t"papayawhip": [255, 239, 213],\r\n\t"peachpuff": [255, 218, 185],\r\n\t"peru": [205, 133, 63],\r\n\t"pink": [255, 192, 203],\r\n\t"plum": [221, 160, 221],\r\n\t"powderblue": [176, 224, 230],\r\n\t"purple": [128, 0, 128],\r\n\t"rebeccapurple": [102, 51, 153],\r\n\t"red": [255, 0, 0],\r\n\t"rosybrown": [188, 143, 143],\r\n\t"royalblue": [65, 105, 225],\r\n\t"saddlebrown": [139, 69, 19],\r\n\t"salmon": [250, 128, 114],\r\n\t"sandybrown": [244, 164, 96],\r\n\t"seagreen": [46, 139, 87],\r\n\t"seashell": [255, 245, 238],\r\n\t"sienna": [160, 82, 45],\r\n\t"silver": [192, 192, 192],\r\n\t"skyblue": [135, 206, 235],\r\n\t"slateblue": [106, 90, 205],\r\n\t"slategray": [112, 128, 144],\r\n\t"slategrey": [112, 128, 144],\r\n\t"snow": [255, 250, 250],\r\n\t"springgreen": [0, 255, 127],\r\n\t"steelblue": [70, 130, 180],\r\n\t"tan": [210, 180, 140],\r\n\t"teal": [0, 128, 128],\r\n\t"thistle": [216, 191, 216],\r\n\t"tomato": [255, 99, 71],\r\n\t"turquoise": [64, 224, 208],\r\n\t"violet": [238, 130, 238],\r\n\t"wheat": [245, 222, 179],\r\n\t"white": [255, 255, 255],\r\n\t"whitesmoke": [245, 245, 245],\r\n\t"yellow": [255, 255, 0],\r\n\t"yellowgreen": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack://pf1/./node_modules/color-name/index.js?')},"./node_modules/color-string/index.js":function(module,exports,__webpack_require__){eval("/* MIT license */\nvar colorNames = __webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\");\nvar swizzle = __webpack_require__(/*! simple-swizzle */ \"./node_modules/simple-swizzle/index.js\");\n\nvar reverseNames = {};\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (colorNames.hasOwnProperty(name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {},\n\tget: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-f0-9]{3,4})$/i;\n\tvar hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar keyword = /(\\D+)/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\tvar hexAlpha;\n\n\tif (match = string.match(hex)) {\n\t\thexAlpha = match[2];\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;\n\t\t}\n\t} else if (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\t\thexAlpha = match[3];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\n\t\tif (!rgb) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t} else {\n\t\treturn null;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?(?:\\d*\\.)?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = (parseFloat(match[1]) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d*[\\.]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn (\n\t\t'#' +\n\t\thexDouble(rgba[0]) +\n\t\thexDouble(rgba[1]) +\n\t\thexDouble(rgba[2]) +\n\t\t(rgba[3] < 1\n\t\t\t? (hexDouble(Math.round(rgba[3] * 255)))\n\t\t\t: '')\n\t);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = num.toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n\n\n//# sourceURL=webpack://pf1/./node_modules/color-string/index.js?")},"./node_modules/color/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar colorString = __webpack_require__(/*! color-string */ \"./node_modules/color-string/index.js\");\nvar convert = __webpack_require__(/*! color-convert */ \"./node_modules/color-convert/index.js\");\n\nvar _slice = [].slice;\n\nvar skippedModels = [\n\t// to be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// shouldn't really be in color-convert either...\n\t'hex'\n];\n\nvar hashedModelKeys = {};\nObject.keys(convert).forEach(function (model) {\n\thashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n});\n\nvar limiters = {};\n\nfunction Color(obj, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tvar i;\n\tvar channels;\n\n\tif (obj == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (obj instanceof Color) {\n\t\tthis.model = obj.model;\n\t\tthis.color = obj.color.slice();\n\t\tthis.valpha = obj.valpha;\n\t} else if (typeof obj === 'string') {\n\t\tvar result = colorString.get(obj);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + obj);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (obj.length) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tvar newArr = _slice.call(obj, 0, channels);\n\t\tthis.color = zeroArray(newArr, channels);\n\t\tthis.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;\n\t} else if (typeof obj === 'number') {\n\t\t// this is always RGB - can be converted later on.\n\t\tobj &= 0xFFFFFF;\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(obj >> 16) & 0xFF,\n\t\t\t(obj >> 8) & 0xFF,\n\t\t\tobj & 0xFF\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tvar keys = Object.keys(obj);\n\t\tif ('alpha' in obj) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;\n\t\t}\n\n\t\tvar hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(obj));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tvar labels = convert[this.model].labels;\n\t\tvar color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(obj[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tvar limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString: function () {\n\t\treturn this.string();\n\t},\n\n\ttoJSON: function () {\n\t\treturn this[this.model]();\n\t},\n\n\tstring: function (places) {\n\t\tvar self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString: function (places) {\n\t\tvar self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray: function () {\n\t\treturn this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n\t},\n\n\tobject: function () {\n\t\tvar result = {};\n\t\tvar channels = convert[this.model].channels;\n\t\tvar labels = convert[this.model].labels;\n\n\t\tfor (var i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray: function () {\n\t\tvar rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject: function () {\n\t\tvar rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround: function (places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n\t},\n\n\talpha: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(100)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(100)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.rgb().color;\n\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.rgb().color;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight: function () {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = this.rgb();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\t\treturn rgb;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale: function () {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar rgb = this.rgb().color;\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(val, val, val);\n\t},\n\n\tfade: function (ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer: function (ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.hsl();\n\t\tvar hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix: function (mixinColor, weight) {\n\t\t// ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\t\tvar color1 = mixinColor.rgb();\n\t\tvar color2 = this.rgb();\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t}\n};\n\n// model conversion methods and static constructors\nObject.keys(convert).forEach(function (model) {\n\tif (skippedModels.indexOf(model) !== -1) {\n\t\treturn;\n\t}\n\n\tvar channels = convert[model].channels;\n\n\t// conversion methods\n\tColor.prototype[model] = function () {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (arguments.length) {\n\t\t\treturn new Color(arguments, model);\n\t\t}\n\n\t\tvar newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n\t\treturn new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (color) {\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(_slice.call(arguments), channels);\n\t\t}\n\t\treturn new Color(color, model);\n\t};\n});\n\nfunction roundTo(num, places) {\n\treturn Number(num.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (num) {\n\t\treturn roundTo(num, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tmodel.forEach(function (m) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t});\n\n\tmodel = model[0];\n\n\treturn function (val) {\n\t\tvar result;\n\n\t\tif (arguments.length) {\n\t\t\tif (modifier) {\n\t\t\t\tval = modifier(val);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = val;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(val) {\n\treturn Array.isArray(val) ? val : [val];\n}\n\nfunction zeroArray(arr, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tif (typeof arr[i] !== 'number') {\n\t\t\tarr[i] = 0;\n\t\t}\n\t}\n\n\treturn arr;\n}\n\nmodule.exports = Color;\n\n\n//# sourceURL=webpack://pf1/./node_modules/color/index.js?")},"./node_modules/simple-swizzle/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar isArrayish = __webpack_require__(/*! is-arrayish */ "./node_modules/simple-swizzle/node_modules/is-arrayish/index.js");\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n\n\n//# sourceURL=webpack://pf1/./node_modules/simple-swizzle/index.js?')},"./node_modules/simple-swizzle/node_modules/is-arrayish/index.js":function(module,exports){eval("module.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n\n\n//# sourceURL=webpack://pf1/./node_modules/simple-swizzle/node_modules/is-arrayish/index.js?")},"./pf1.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _module_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module/config.js */ "./module/config.js");\n/* harmony import */ var _module_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./module/settings.js */ "./module/settings.js");\n/* harmony import */ var _module_templates_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./module/templates.js */ "./module/templates.js");\n/* harmony import */ var _module_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./module/canvas.js */ "./module/canvas.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "measureDistances", function() { return _module_canvas_js__WEBPACK_IMPORTED_MODULE_3__["measureDistances"]; });\n\n/* harmony import */ var _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./module/actor/entity.js */ "./module/actor/entity.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActorPF", function() { return _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__["ActorPF"]; });\n\n/* harmony import */ var _module_actor_sheets_character_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./module/actor/sheets/character.js */ "./module/actor/sheets/character.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFCharacter", function() { return _module_actor_sheets_character_js__WEBPACK_IMPORTED_MODULE_5__["ActorSheetPFCharacter"]; });\n\n/* harmony import */ var _module_actor_sheets_npc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./module/actor/sheets/npc.js */ "./module/actor/sheets/npc.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPC", function() { return _module_actor_sheets_npc_js__WEBPACK_IMPORTED_MODULE_6__["ActorSheetPFNPC"]; });\n\n/* harmony import */ var _module_actor_sheets_npc_lite_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./module/actor/sheets/npc-lite.js */ "./module/actor/sheets/npc-lite.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPCLite", function() { return _module_actor_sheets_npc_lite_js__WEBPACK_IMPORTED_MODULE_7__["ActorSheetPFNPCLite"]; });\n\n/* harmony import */ var _module_actor_sheets_npc_loot_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./module/actor/sheets/npc-loot.js */ "./module/actor/sheets/npc-loot.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActorSheetPFNPCLoot", function() { return _module_actor_sheets_npc_loot_js__WEBPACK_IMPORTED_MODULE_8__["ActorSheetPFNPCLoot"]; });\n\n/* harmony import */ var _module_item_entity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./module/item/entity.js */ "./module/item/entity.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ItemPF", function() { return _module_item_entity_js__WEBPACK_IMPORTED_MODULE_9__["ItemPF"]; });\n\n/* harmony import */ var _module_item_sheets_base_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./module/item/sheets/base.js */ "./module/item/sheets/base.js");\n/* harmony import */ var _module_sidebar_compendium_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./module/sidebar/compendium.js */ "./module/sidebar/compendium.js");\n/* harmony import */ var _module_patch_core_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./module/patch-core.js */ "./module/patch-core.js");\n/* harmony import */ var _module_dice_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./module/dice.js */ "./module/dice.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DicePF", function() { return _module_dice_js__WEBPACK_IMPORTED_MODULE_13__["DicePF"]; });\n\n/* harmony import */ var _module_lib_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./module/lib.js */ "./module/lib.js");\n/* harmony import */ var _module_sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./module/sidebar/chat-message.js */ "./module/sidebar/chat-message.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ChatMessagePF", function() { return _module_sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_15__["ChatMessagePF"]; });\n\n/* harmony import */ var _module_token_quick_actions_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./module/token-quick-actions.js */ "./module/token-quick-actions.js");\n/* harmony import */ var _module_socket_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./module/socket.js */ "./module/socket.js");\n/* harmony import */ var _module_chat_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./module/chat.js */ "./module/chat.js");\n/* harmony import */ var _module_migration_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./module/migration.js */ "./module/migration.js");\n/**\r\n * The Pathfinder 1st edition game system for Foundry Virtual Tabletop\r\n * Author: Furyspark\r\n * Software License: GNU GPLv3\r\n */\r\n\r\n// Import Modules\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Add String.format\r\nif (!String.prototype.format) {\r\n  String.prototype.format = function(...args) {\r\n    return this.replace(/{(\\d+)}/g, function(match, number) { \r\n      return args[number] != null\r\n        ? args[number]\r\n        : match\r\n      ;\r\n    });\r\n  };\r\n}\r\n\r\n/* -------------------------------------------- */\r\n/*  Foundry VTT Initialization                  */\r\n/* -------------------------------------------- */\r\n\r\nHooks.once("init", async function() {\r\n  console.log(`PF1 | Initializing Pathfinder 1 System`);\r\n\r\n  // Create a PF1 namespace within the game global\r\n  game.pf1 = {\r\n    ActorPF: _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__["ActorPF"],\r\n    DicePF: _module_dice_js__WEBPACK_IMPORTED_MODULE_13__["DicePF"],\r\n    ItemPF: _module_item_entity_js__WEBPACK_IMPORTED_MODULE_9__["ItemPF"],\r\n    migrations: _module_migration_js__WEBPACK_IMPORTED_MODULE_19__,\r\n    rollItemMacro,\r\n    rollDefenses,\r\n    CompendiumDirectoryPF: _module_sidebar_compendium_js__WEBPACK_IMPORTED_MODULE_11__["CompendiumDirectoryPF"],\r\n    rollPreProcess: {\r\n      sizeRoll: _module_lib_js__WEBPACK_IMPORTED_MODULE_14__["sizeDie"],\r\n      roll: _module_lib_js__WEBPACK_IMPORTED_MODULE_14__["normalDie"],\r\n    },\r\n    migrateWorld: _module_migration_js__WEBPACK_IMPORTED_MODULE_19__["migrateWorld"],\r\n  };\r\n\r\n  // Record Configuration Values\r\n  CONFIG.PF1 = _module_config_js__WEBPACK_IMPORTED_MODULE_0__["PF1"];\r\n  CONFIG.Actor.entityClass = _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__["ActorPF"];\r\n  CONFIG.Item.entityClass = _module_item_entity_js__WEBPACK_IMPORTED_MODULE_9__["ItemPF"];\r\n  CONFIG.ui.compendium = _module_sidebar_compendium_js__WEBPACK_IMPORTED_MODULE_11__["CompendiumDirectoryPF"];\r\n  CONFIG.ChatMessage.entityClass = _module_sidebar_chat_message_js__WEBPACK_IMPORTED_MODULE_15__["ChatMessagePF"];\r\n\r\n  // Register System Settings\r\n  Object(_module_settings_js__WEBPACK_IMPORTED_MODULE_1__["registerSystemSettings"])();\r\n\r\n  // Preload Handlebars Templates\r\n  await Object(_module_templates_js__WEBPACK_IMPORTED_MODULE_2__["preloadHandlebarsTemplates"])();\r\n\r\n  // Patch Core Functions\r\n  Object(_module_patch_core_js__WEBPACK_IMPORTED_MODULE_12__["PatchCore"])();\r\n\r\n  // Register sheet application classes\r\n  Actors.unregisterSheet("core", ActorSheet);\r\n  Actors.registerSheet("PF1", _module_actor_sheets_character_js__WEBPACK_IMPORTED_MODULE_5__["ActorSheetPFCharacter"], { types: ["character"], makeDefault: true });\r\n  Actors.registerSheet("PF1", _module_actor_sheets_npc_js__WEBPACK_IMPORTED_MODULE_6__["ActorSheetPFNPC"], { types: ["npc"], makeDefault: true });\r\n  Actors.registerSheet("PF1", _module_actor_sheets_npc_lite_js__WEBPACK_IMPORTED_MODULE_7__["ActorSheetPFNPCLite"], { types: ["npc"], makeDefault: false });\r\n  Actors.registerSheet("PF1", _module_actor_sheets_npc_loot_js__WEBPACK_IMPORTED_MODULE_8__["ActorSheetPFNPCLoot"], { types: ["npc"], makeDefault: false });\r\n  Items.unregisterSheet("core", ItemSheet);\r\n  Items.registerSheet("PF1", _module_item_sheets_base_js__WEBPACK_IMPORTED_MODULE_10__["ItemSheetPF"], { types: ["class", "feat", "spell", "consumable", "equipment", "loot", "weapon", "buff", "attack", "race"], makeDefault: true });\r\n\r\n  Object(_module_socket_js__WEBPACK_IMPORTED_MODULE_17__["initializeSocket"])();\r\n});\r\n\r\n\r\n/* -------------------------------------------- */\r\n/*  Foundry VTT Setup                           */\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * This function runs after game data has been requested and loaded from the servers, so entities exist\r\n */\r\nHooks.once("setup", function() {\r\n\r\n  // Localize CONFIG objects once up-front\r\n  const toLocalize = [\r\n    "abilities", "abilitiesShort", "alignments", "currencies", "distanceUnits", "itemActionTypes", "senses", "skills", "targetTypes",\r\n    "timePeriods", "savingThrows", "ac", "acValueLabels", "featTypes", "conditions", "lootTypes", "flyManeuverabilities",\r\n    "spellPreparationModes", "weaponTypes", "weaponProperties", "spellComponents", "spellSchools", "spellLevels", "conditionTypes",\r\n    "favouredClassBonuses", "armorProficiencies", "weaponProficiencies", "actorSizes", "abilityActivationTypes", "abilityActivationTypesPlurals",\r\n    "limitedUsePeriods", "equipmentTypes", "equipmentSlots", "consumableTypes", "attackTypes", "buffTypes", "buffTargets", "contextNoteTargets",\r\n    "healingTypes", "divineFocus", "classSavingThrows", "classBAB", "classTypes", "measureTemplateTypes", "creatureTypes",\r\n  ];\r\n\r\n  const doLocalize = function(obj) {\r\n    return Object.entries(obj).reduce((obj, e) => {\r\n      if (typeof e[1] === "string") obj[e[0]] = game.i18n.localize(e[1]);\r\n      else if (typeof e[1] === "object") obj[e[0]] = doLocalize(e[1]);\r\n      return obj;\r\n    }, {});\r\n  };\r\n  for ( let o of toLocalize ) {\r\n    CONFIG.PF1[o] = doLocalize(CONFIG.PF1[o]);\r\n  }\r\n});\r\n\r\n/* -------------------------------------------- */\r\n\r\n/**\r\n * Once the entire VTT framework is initialized, check to see if we should perform a data migration\r\n */\r\nHooks.once("ready", async function() {\r\n  const NEEDS_MIGRATION_VERSION = 0.63;\r\n  let needMigration = game.settings.get("pf1", "systemMigrationVersion") < NEEDS_MIGRATION_VERSION;\r\n  if (needMigration && game.user.isGM) {\r\n    await _module_migration_js__WEBPACK_IMPORTED_MODULE_19__["migrateWorld"]();\r\n  }\r\n\r\n  game.actors.entities.forEach(obj => { obj._updateChanges({ sourceOnly: true }); });\r\n  \r\n  Hooks.on(\'renderTokenHUD\', (app, html, data) => { _module_token_quick_actions_js__WEBPACK_IMPORTED_MODULE_16__["TokenQuickActions"].addTop3Attacks(app, html, data) });\r\n});\r\n\r\n/* -------------------------------------------- */\r\n/*  Canvas Initialization                       */\r\n/* -------------------------------------------- */\r\n\r\nHooks.on("canvasInit", function() {\r\n\r\n  // Extend Diagonal Measurement\r\n  canvas.grid.diagonalRule = game.settings.get("pf1", "diagonalMovement");\r\n  SquareGrid.prototype.measureDistances = _module_canvas_js__WEBPACK_IMPORTED_MODULE_3__["measureDistances"];\r\n});\r\n\r\n\r\n/* -------------------------------------------- */\r\n/*  Other Hooks                                 */\r\n/* -------------------------------------------- */\r\n\r\nHooks.on("renderChatMessage", (app, html, data) => {\r\n  // Hide roll info\r\n  _module_chat_js__WEBPACK_IMPORTED_MODULE_18__["hideRollInfo"](app, html, data);\r\n\r\n  // Hide GM sensitive info\r\n  _module_chat_js__WEBPACK_IMPORTED_MODULE_18__["hideGMSensitiveInfo"](app, html, data);\r\n\r\n  // Optionally collapse the content\r\n  if (game.settings.get("pf1", "autoCollapseItemCards")) html.find(".card-content").hide();\r\n\r\n  // Alter chat card title color\r\n  _module_chat_js__WEBPACK_IMPORTED_MODULE_18__["addChatCardTitleGradient"](app, html, data);\r\n});\r\n\r\nHooks.on("renderChatLog", (_, html) => _module_item_entity_js__WEBPACK_IMPORTED_MODULE_9__["ItemPF"].chatListeners(html));\r\nHooks.on("renderChatLog", (_, html) => _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__["ActorPF"].chatListeners(html));\r\n\r\nHooks.on("updateOwnedItem", (actor, _, changedData) => {\r\n  if (!(actor instanceof Actor)) return;\r\n  actor.refresh();\r\n\r\n  const item = actor.getOwnedItem(changedData._id);\r\n  if (item == null) return;\r\n  actor.updateItemResources(item);\r\n});\r\nHooks.on("updateToken", (scene, sceneId, data) => {\r\n  const actor = game.actors.tokens[data._id];\r\n  if (actor != null && hasProperty(data, "actorData.items")) {\r\n    actor.refresh();\r\n\r\n    // Update items\r\n    for (let i of actor.items) {\r\n      actor.updateItemResources(i);\r\n    }\r\n  }\r\n});\r\n\r\n// Create race on actor\r\nHooks.on("preCreateOwnedItem", (actor, item) => {\r\n  if (!(actor instanceof Actor)) return;\r\n  if (actor.race == null) return;\r\n\r\n  if (item.type === "race") {\r\n    actor.race.update(item);\r\n    return false;\r\n  }\r\n});\r\n\r\nHooks.on("createOwnedItem", (actor) => {\r\n  if (!(actor instanceof Actor)) return;\r\n  actor.refresh();\r\n});\r\nHooks.on("deleteOwnedItem", (actor, ...args) => {\r\n  if (!(actor instanceof Actor)) return;\r\n  actor.refresh();\r\n});\r\n\r\n/* -------------------------------------------- */\r\n/*  Hotbar Macros                               */\r\n/* -------------------------------------------- */\r\n\r\nHooks.on("hotbarDrop", (bar, data, slot) => {\r\n  if ( data.type !== "Item" ) return;\r\n  createItemMacro(data.data, slot);\r\n  return false;\r\n});\r\n\r\n/**\r\n * Create a Macro from an Item drop.\r\n * Get an existing item macro if one exists, otherwise create a new one.\r\n * @param {Object} item     The item data\r\n * @param {number} slot     The hotbar slot to use\r\n * @returns {Promise}\r\n */\r\nasync function createItemMacro(item, slot) {\r\n  const actor = Object(_module_lib_js__WEBPACK_IMPORTED_MODULE_14__["getItemOwner"])(item);\r\n  const command = `game.pf1.rollItemMacro("${item.name}", {\\n` +\r\n  `  itemId: "${item._id}",\\n` +\r\n  `  itemType: "${item.type}",\\n` +\r\n  (actor != null ? `  actorId: "${actor._id}",\\n` : "") +\r\n  `});`;\r\n  let macro = game.macros.entities.find(m => (m.name === item.name) && (m.command === command));\r\n  if ( !macro ) {\r\n    macro = await Macro.create({\r\n      name: item.name,\r\n      type: "script",\r\n      img: item.img,\r\n      command: command,\r\n      flags: {"pf1.itemMacro": true}\r\n    }, {displaySheet: false});\r\n  }\r\n  game.user.assignHotbarMacro(macro, slot);\r\n}\r\n\r\n/**\r\n * Create a Macro from an Item drop.\r\n * Get an existing item macro if one exists, otherwise create a new one.\r\n * @param {string} itemName\r\n * @param {object} [options={}]\r\n * @return {Promise}\r\n */\r\nfunction rollItemMacro(itemName, {itemId=null, itemType=null, actorId=null}={}) {\r\n  let actor = Object(_module_lib_js__WEBPACK_IMPORTED_MODULE_14__["getActorFromId"])(actorId);\r\n  if (actor && !actor.hasPerm(game.user, "OWNER")) return ui.notifications.warn(game.i18n.localize("PF1.ErrorNoActorPermission"));\r\n  const item = actor ? actor.items.find(i => {\r\n    if (itemId != null && i._id !== itemId) return false;\r\n    if (itemType != null && i.type !== itemType) return false;\r\n    return i.name === itemName;\r\n  }) : null;\r\n  if (!item) return ui.notifications.warn(`Your controlled Actor does not have an item named ${itemName}`);\r\n\r\n  // Trigger the item roll\r\n  if (!game.keyboard.isDown("Control")) {\r\n    return item.use({skipDialog: keyboard.isDown("Shift")});\r\n  }\r\n  return item.roll();\r\n}\r\n\r\n/**\r\n * Show an actor\'s defenses.\r\n */\r\nfunction rollDefenses({actorName=null, actorId=null}={}) {\r\n  const actor = _module_actor_entity_js__WEBPACK_IMPORTED_MODULE_4__["ActorPF"].getActiveActor({actorName: actorName, actorId: actorId});\r\n  if (!actor) return ui.notifications.warn("No applicable actor found");\r\n\r\n  return actor.rollDefenses();\r\n};\r\n\r\n// Create Handlebars helpers\r\n\r\n/**\r\n * Render a MCE editor container with an optional toggle button\r\n */\r\nHandlebars.registerHelper(\'roll-editor\', function(options) {\r\n  // Find item and/or actor\r\n  const _id = (getProperty(options, "data.root.entity") || {})._id;\r\n  let actor = null, item = null;\r\n  const actors = [...Array.from(game.actors.entities), ...Array.from(game.actors.tokens)];\r\n  const items = [...Array.from(game.items.entities)];\r\n  if (_id != null) {\r\n    // Find actor or item on actor\r\n    for (let a of actors) {\r\n      if (a._id === _id) {\r\n        actor = a;\r\n      }\r\n      else {\r\n        if (item == null) item = a.items.find(o => o._id === _id);\r\n      }\r\n    }\r\n    // Find item\r\n    if (item == null) {\r\n      for (let i of items) {\r\n        if (i._id === _id) item = i;\r\n      }\r\n    }\r\n  }\r\n  const rollData = item != null ? item.getRollData() : (actor != null ? actor.getRollData() : {});\r\n  // Create editor\r\n  let target = options.hash[\'target\'],\r\n      content = options.hash[\'content\'] || "",\r\n      button = Boolean(options.hash[\'button\']),\r\n      owner = Boolean(options.hash[\'owner\']),\r\n      editable = Boolean(options.hash[\'editable\']);\r\n  if ( !target ) throw new Error("You must define the name of a target field.");\r\n\r\n  // Enrich the content\r\n  content = TextEditor.enrichHTML(content, {secrets: owner, entities: true, rollData: rollData});\r\n\r\n  // Construct the HTML\r\n  let editor = $(`<div class="editor"><div class="editor-content" data-edit="${target}">${content}</div></div>`);\r\n\r\n  // Append edit button\r\n  if ( button && editable ) editor.append($(\'<a class="editor-edit"><i class="fas fa-edit"></i></a>\'));\r\n  return new Handlebars.SafeString(editor[0].outerHTML);\r\n});\r\n\r\n\r\n\r\n// Export objects for being a library\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://pf1/./pf1.js?')}})}));